<properties
    pageTitle="Azure IoT συσκευή SDK για C - σειριοποιητής | Microsoft Azure"
    description="Μάθετε περισσότερα σχετικά με τη χρήση της βιβλιοθήκης σειριοποιητής στη συσκευή Azure IoT SDK για C"
    services="iot-hub"
    documentationCenter=""
    authors="olivierbloch"
    manager="timlt"
    editor=""/>

<tags
     ms.service="iot-hub"
     ms.devlang="cpp"
     ms.topic="article"
     ms.tgt_pltfrm="na"
     ms.workload="na"
     ms.date="09/06/2016"
     ms.author="obloch"/>

# <a name="microsoft-azure-iot-device-sdk-for-c--more-about-serializer"></a>Συσκευή Microsoft Azure IoT SDK για C-περισσότερες πληροφορίες σχετικά με το πρόγραμμα σειριοποίησης

Το [πρώτο άρθρο](iot-hub-device-sdk-c-intro.md) σε αυτήν τη σειρά εισάγονται στη **συσκευή Azure IoT SDK για C**. Το επόμενο άρθρο δώσει μια πιο λεπτομερή περιγραφή των το [**IoTHubClient**](iot-hub-device-sdk-c-iothubclient.md). Σε αυτό το άρθρο ολοκληρώνει κάλυψης του SDK, παρέχοντας μια πιο λεπτομερή περιγραφή του στοιχείου υπόλοιπο: στη βιβλιοθήκη **σειριοποιητής** .

Το άρθρο εισαγωγικό περιγράφεται πώς μπορείτε να χρησιμοποιήσετε τη βιβλιοθήκη **σειριοποιητής** για συμβάντα που θέλετε να στείλετε και να λαμβάνετε μηνύματα από διανομέα IoT. Σε αυτό το άρθρο επεκτείνουμε αυτήν τη συζήτηση, παρέχοντας μια πληρέστερη επεξήγηση του τρόπου τα δεδομένα σας με τη γλώσσα μακροεντολής **σειριοποιητής** του μοντέλου. Το άρθρο επίσης περιλαμβάνει περισσότερες λεπτομέρειες σχετικά με το πώς η βιβλιοθήκη τοποθετεί σειριακά μηνύματα (και σε ορισμένες περιπτώσεις και πώς μπορείτε να ελέγξετε τη συμπεριφορά σειριοποίησης). Επίσης, θα σας θα περιγράφουν ορισμένες παράμετροι που μπορείτε να τροποποιήσετε που καθορίζουν το μέγεθος του τα μοντέλα που δημιουργείτε.

Τέλος, το άρθρο revisits ορισμένα θέματα που καλύπτονται στην προηγούμενη άρθρα όπως το μήνυμα και χειρισμού ιδιότητα. Όπως θα σας θα βρείτε, αυτές οι δυνατότητες λειτουργούν με τον ίδιο τρόπο χρησιμοποιώντας τη βιβλιοθήκη **σειριοποιητής** τρόπο όπως με τη βιβλιοθήκη **IoTHubClient** .

Είναι όλα τα στοιχεία που περιγράφονται σε αυτό το άρθρο με βάση τα δείγματα SDK **σειριοποιητής** . Εάν θέλετε να παρακολουθήσετε κατά μήκος, ανατρέξτε στο θέμα το **simplesample\_amqp** και **simplesample\_http** εφαρμογές που περιλαμβάνονται στη συσκευή Azure IoT SDK για C.

Μπορείτε να βρείτε τη **συσκευή Azure IoT SDK για C** στο αποθετήριο δεδομένων [Microsoft Azure IoT SDK](https://github.com/Azure/azure-iot-sdks) GitHub και να προβάλετε λεπτομέρειες του API της [αναφοράς C API](http://azure.github.io/azure-iot-sdks/c/api_reference/index.html).

## <a name="the-modeling-language"></a>Η μοντελοποίηση γλώσσας

Το [άρθρο εισαγωγικό](iot-hub-device-sdk-c-intro.md) σε αυτήν τη σειρά εισάγονται στη **συσκευή Azure IoT SDK για C** μοντελοποίηση γλώσσας έως το παράδειγμα που παρέχεται στην το **simplesample\_amqp** εφαρμογής:

```
BEGIN_NAMESPACE(WeatherStation);

DECLARE_MODEL(ContosoAnemometer,
WITH_DATA(ascii_char_ptr, DeviceId),
WITH_DATA(double, WindSpeed),
WITH_ACTION(TurnFanOn),
WITH_ACTION(TurnFanOff),
WITH_ACTION(SetAirResistance, int, Position)
);

END_NAMESPACE(WeatherStation);
```

Όπως μπορείτε να δείτε τη γλώσσα μοντελοποίησης βασίζεται σε C μακροεντολές. Αρχίζετε πάντα τον ορισμό με **ΈΝΑΡΞΗΣ\_χώρο ΟΝΟΜΆΤΩΝ** και τελειώνουν πάντα με **ΤΈΛΟΣ\_χώρο ΟΝΟΜΆΤΩΝ**. Είναι συνηθισμένο ονόματος για το χώρο ονομάτων για την εταιρεία σας ή, όπως αυτό το παράδειγμα, το έργο που εργάζεστε.

Τι μεταβαίνει μέσα στο χώρο ονομάτων είναι ορισμοί μοντέλο. Σε αυτήν την περίπτωση, υπάρχει ένα μόνο μοντέλο για ένα anemometer. Και πάλι, το μοντέλο μπορείτε να δώσετε όνομα κάτι, αλλά συνήθως αυτό ονομάζεται για τη συσκευή ή τον τύπο των δεδομένων που θέλετε να ανταλλάξετε με IoT διανομέα.  

Μοντέλα περιέχουν έναν ορισμό για τα συμβάντα που μπορείτε να κάνετε εισόδου IoT διανομέα (τα *δεδομένα*), καθώς και τα μηνύματα που μπορείτε να λάβετε από διανομέα IoT (τις *Ενέργειες*). Όπως μπορείτε να δείτε από το παράδειγμα, τα συμβάντα έχουν έναν τύπο και ένα όνομα. ενέργειες έχουν ένα όνομα και προαιρετικών παραμέτρων (κάθε ένα με έναν τύπο).

Τι δεν είναι επιδεικνύεται σε αυτό το δείγμα είναι οι τύποι πρόσθετων δεδομένων που υποστηρίζονται από το SDK. Θα ασχοληθούμε με αυτόν το επόμενο.

> [AZURE.NOTE] Διανομέα IoT αναφέρεται σε μια συσκευή στέλνει ως *συμβάντα*, ενώ η γλώσσα μοντελοποίησης αναφέρεται σε αυτό ως *δεδομένων* (που ορίζονται από το χρησιμοποιώντας **WITH_DATA**) δεδομένων. Παρομοίως, διανομέα IoT αναφέρεται στα δεδομένα που στέλνετε σε συσκευές με τα *μηνύματα*, ενώ η γλώσσα μοντελοποίησης αναφέρεται σε αυτό ως *Ενέργειες* (που ορίζονται με χρήση **WITH_ACTION**). Έχετε υπόψη ότι αυτοί οι όροι μπορούν να χρησιμοποιηθούν χωρίς διάκριση σε αυτό το άρθρο.

### <a name="supported-data-types"></a>Υποστηριζόμενοι τύποι δεδομένων

Οι παρακάτω τύποι δεδομένων που υποστηρίζονται σε μοντέλα που έχουν δημιουργηθεί με τη βιβλιοθήκη **σειριοποιητής** :

| Τύπος                    | Περιγραφή                            |
|-------------------------|----------------------------------------|
| διπλά                  | Ορισμός διπλού αριθμός κινητής υποδιαστολής ακρίβειας |
| Int                     | ακέραιο αριθμό 32 bit                         |
| Αιώρηση                   | Αριθμός κινητής υποδιαστολής απλής ακρίβειας |
| μεγάλη                    | Ακέραιος μεγάλου μήκους                           |
| int8\_t                 | Ακέραιος 8 bit                          |
| Int16\_t                | Ακέραιος 16 bit                         |
| Int32\_t                | ακέραιο αριθμό 32 bit                         |
| Int64\_t                | ακέραιος 64 bit                         |
| bool                    | δυαδική τιμή                                |
| ASCII\_char\_ptr        | Συμβολοσειρά ASCII                           |
| EDM\_ΗΜΕΡΟΜΗΝΊΑ\_ΧΡΌΝΟΥ\_OFFSET | Μετατόπιση ώρας ημερομηνίας                       |
| EDM\_GUID               | GUID                                   |
| EDM\_ΔΥΑΔΙΚΌ             | δυαδικό                                 |
| ΔΉΛΩΣΗ\_ΔΟΜΉ         | σύνθετα δεδομένα τύπου                      |

Ας ξεκινήσουμε με τον τελευταίο τύπο δεδομένων. Το **DECLARE\_ΔΟΜΉ** σας επιτρέπει να ορίσετε σύνθετους τύπους δεδομένων, που είναι ομαδοποιήσεις από τους άλλους τύπους στοιχειώδεις. Αυτές οι ομαδοποιήσεις επιτρέψετε μας για να ορίσετε ένα μοντέλο που μοιάζει κάπως έτσι:

```
DECLARE_STRUCT(TestType,
double, aDouble,
int, aInt,
float, aFloat,
long, aLong,
int8_t, aInt8,
uint8_t, auInt8,
int16_t, aInt16,
int32_t, aInt32,
int64_t, aInt64,
bool, aBool,
ascii_char_ptr, aAsciiCharPtr,
EDM_DATE_TIME_OFFSET, aDateTimeOffset,
EDM_GUID, aGuid,
EDM_BINARY, aBinary
);

DECLARE_MODEL(TestModel,
WITH_DATA(TestType, Test)
);
```

Το μοντέλο περιέχει ένα συμβάν δεδομένων μονής ακρίβειας του τύπου **TestType**. **TestType** είναι ένα σύνθετο τύπο που περιλαμβάνει πολλές μέλη, οι οποίες αποτελούν συνολικά δείχνουν την στοιχειώδεις τύπους που υποστηρίζονται από το **πρόγραμμα σειριοποίησης** μοντελοποίηση γλώσσας.

Με ένα μοντέλο ως εξής, θα σας να συντάξετε κώδικα για την αποστολή δεδομένων σε διανομέα IoT που εμφανίζεται ως εξής:

```
TestModel* testModel = CREATE_MODEL_INSTANCE(MyThermostat, TestModel);

testModel->Test.aDouble = 1.1;
testModel->Test.aInt = 2;
testModel->Test.aFloat = 3.0f;
testModel->Test.aLong = 4;
testModel->Test.aInt8 = 5;
testModel->Test.auInt8 = 6;
testModel->Test.aInt16 = 7;
testModel->Test.aInt32 = 8;
testModel->Test.aInt64 = 9;
testModel->Test.aBool = true;
testModel->Test.aAsciiCharPtr = "ascii string 1";

time_t now;
time(&now);
testModel->Test.aDateTimeOffset = GetDateTimeOffset(now);

EDM_GUID guid = { { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F } };
testModel->Test.aGuid = guid;

unsigned char binaryArray[3] = { 0x01, 0x02, 0x03 };
EDM_BINARY binaryData = { sizeof(binaryArray), &binaryArray };
testModel->Test.aBinary = binaryData;

SendAsync(iotHubClientHandle, (const void*)&(testModel->Test));
```

Βασικά, θα σας είστε εκχωρώντας μια τιμή σε κάθε μέλος της δομής **έλεγχο** και, στη συνέχεια, κλήση **SendAsync** για να στείλετε το συμβάν **δοκιμής** δεδομένων στο cloud. **SendAsync** είναι μια συνάρτηση Βοήθειας που στέλνει ένα συμβάν δεδομένων μονής ακρίβειας IoT διανομέα:

```
void SendAsync(IOTHUB_CLIENT_LL_HANDLE iotHubClientHandle, const void *dataEvent)
{
    unsigned char* destination;
    size_t destinationSize;
    if (SERIALIZE(&destination, &destinationSize, *(const unsigned char*)dataEvent) ==
    {
        // null terminate the string
        char* destinationAsString = (char*)malloc(destinationSize + 1);
        if (destinationAsString != NULL)
        {
            memcpy(destinationAsString, destination, destinationSize);
            destinationAsString[destinationSize] = '\0';
            IOTHUB_MESSAGE_HANDLE messageHandle = IoTHubMessage_CreateFromString(destinationAsString);
            if (messageHandle != NULL)
            {
                IoTHubClient_SendEventAsync(iotHubClientHandle, messageHandle, sendCallback, (void*)0);

                IoTHubMessage_Destroy(messageHandle);
            }
            free(destinationAsString);
        }
        free(destination);
    }
}
```

Αυτή η συνάρτηση τοποθετεί σειριακά το συμβάν που δίνεται δεδομένων και το αποστέλλει IoT διανομέα, χρησιμοποιώντας **IoTHubClient\_SendEventAsync**. Πρόκειται για τον ίδιο κωδικό που αναφέρονται σε προηγούμενα άρθρα (**SendAsync** ενσωματώνει της λογικής σε μια συνάρτηση εύκολη).

Μία άλλη συνάρτηση Βοήθειας χρησιμοποιούνται στον προηγούμενο κώδικα είναι **GetDateTimeOffset**. Αυτή η συνάρτηση μετατρέπει τη δεδομένη στιγμή σε μια τιμή του τύπου **EDM\_ΗΜΕΡΟΜΗΝΊΑ\_ΧΡΌΝΟΥ\_ΜΕΤΑΤΌΠΙΣΗ**:

```
EDM_DATE_TIME_OFFSET GetDateTimeOffset(time_t time)
{
    struct tm newTime;
    gmtime_s(&newTime, &time);
    EDM_DATE_TIME_OFFSET dateTimeOffset;
    dateTimeOffset.dateTime = newTime;
    dateTimeOffset.fractionalSecond = 0;
    dateTimeOffset.hasFractionalSecond = 0;
    dateTimeOffset.hasTimeZone = 0;
    dateTimeOffset.timeZoneHour = 0;
    dateTimeOffset.timeZoneMinute = 0;
    return dateTimeOffset;
}
```

Εάν εκτελέσετε αυτόν τον κωδικό, το ακόλουθο μήνυμα αποστέλλεται με διανομέα IoT:

```
{"aDouble":1.100000000000000, "aInt":2, "aFloat":3.000000, "aLong":4, "aInt8":5, "auInt8":6, "aInt16":7, "aInt32":8, "aInt64":9, "aBool":true, "aAsciiCharPtr":"ascii string 1", "aDateTimeOffset":"2015-09-14T21:18:21Z", "aGuid":"00010203-0405-0607-0809-0A0B0C0D0E0F", "aBinary":"AQID"}
```

Σημειώστε ότι η σειριοποίηση JSON, που είναι η μορφή που δημιουργήθηκαν από τη βιβλιοθήκη **σειριοποιητής** . Επίσης, σημειώστε ότι κάθε μέλος του αντικειμένου αλληλουχίας JSON συμφωνεί με τα μέλη της **TestType** που ορίσαμε μας μοντέλου. Οι τιμές ταιριάζουν επίσης ακριβώς αυτά που χρησιμοποιούνται στον κώδικα. Ωστόσο, σημειώστε ότι τα δυαδικά δεδομένα είναι κωδικοποίηση base64: "AQID" είναι η base64 κωδικοποίηση των {0x01, 0x02, 0x03}.

Αυτό το παράδειγμα δείχνει το πλεονέκτημα της χρήσης της βιβλιοθήκης **σειριοποιητής** --δίνει τη δυνατότητα μας για να στείλετε JSON στο cloud, χωρίς να χρειάζεται να αντιμετωπίσετε ρητά σειριοποίησης στην εφαρμογή μας. Μόνο που έχετε να ανησυχείτε αν θα ρύθμιση τις τιμές από τα συμβάντα δεδομένων στο μοντέλο μας και, στη συνέχεια, κλήση απλό API για να στείλετε τα συμβάντα στο cloud.

Με αυτές τις πληροφορίες, θα σας να ορίσετε μοντέλα τα οποία περιλαμβάνουν την περιοχή υποστηριζόμενους τύπους δεδομένων, συμπεριλαμβανομένων των σύνθετοι τύποι (θα μπορούσε να ακόμα περιλαμβάνονται σύνθετοι τύποι μέσα σε άλλες σύνθετοι τύποι). Ωστόσο, εσείς σειριοποιηθεί JSON που δημιουργούνται από το παραπάνω παράδειγμα εμφανίζει τα ένα σημαντικό σημείο. Καθορίζει *τον τρόπο* στείλουμε δεδομένων με τη βιβλιοθήκη **σειριοποιητής** ακριβώς πώς διαμορφώνεται η JSON. Που είναι συγκεκριμένο σημείο τι θα ασχοληθούμε Επόμενο.

## <a name="more-about-serialization"></a>Περισσότερες πληροφορίες σχετικά με σειριοποίησης

Στην προηγούμενη ενότητα επισημαίνει ένα παράδειγμα του αποτελέσματος που δημιουργήθηκαν από τη βιβλιοθήκη **σειριοποιητής** . Σε αυτήν την ενότητα, θα σας θα εξηγούν τον τρόπο στη βιβλιοθήκη τοποθετεί σειριακά δεδομένων και πώς μπορείτε να ελέγξετε αυτήν τη συμπεριφορά χρησιμοποιώντας το σειριοποίησης APIs.

Για να προχωρήσετε τη συζήτηση σε σειριοποίησης, θα σας θα λειτουργούν με ένα νέο μοντέλο βάσει μιας θερμοστάτη. Πρώτα, ας παρέχουν πληροφορίες σχετικά με το σενάριο Προσπαθούμε να διεύθυνση.

Θέλουμε να μια θερμοστάτη που μετρά θερμοκρασίας και υγρασίας του μοντέλου. Κάθε τμήμα δεδομένων πρόκειται να αποσταλούν διανομέα IoT διαφορετικά. Από προεπιλογή, το ingresses θερμοστάτη ένα συμβάν θερμοκρασίας μία φορά κάθε 2 λεπτά; ένα συμβάν υγρασία είναι ingressed μία φορά κάθε 15 λεπτά. Όταν κάποιο συμβάν ingressed, αυτό πρέπει να συμπεριλάβετε μια χρονική σήμανση που εμφανίζει την ώρα που το αντίστοιχο θερμοκρασίας ή υγρασία έγινε η μέτρηση.

Δεδομένο αυτό το σενάριο, θα σας δείξουμε δύο διαφορετικούς τρόπους για να τα δεδομένα του μοντέλου και θα σας θα εξηγούν το εφέ ότι έχει μοντελοποίηση στο αποτέλεσμα αλληλουχίας.

### <a name="model-1"></a>Μοντέλο 1

Εδώ είναι η πρώτη έκδοση ενός μοντέλου που υποστηρίζει το προηγούμενο σενάριο:

```
BEGIN_NAMESPACE(Contoso);

DECLARE_STRUCT(TemperatureEvent,
int, Temperature,
EDM_DATE_TIME_OFFSET, Time);

DECLARE_STRUCT(HumidityEvent,
int, Humidity,
EDM_DATE_TIME_OFFSET, Time);

DECLARE_MODEL(Thermostat,
WITH_DATA(TemperatureEvent, Temperature),
WITH_DATA(HumidityEvent, Humidity)
);

END_NAMESPACE(Contoso);
```

Σημειώστε ότι το μοντέλο περιλαμβάνει δύο συμβάντα δεδομένων: **θερμοκρασίας** και **υγρασίας**. Σε αντίθεση με τα προηγούμενα παραδείγματα, τον τύπο της κάθε συμβάντος είναι μια δομή που ορίζονται από το χρησιμοποιώντας **DECLARE\_ΔΟΜΉ**. **TemperatureEvent** περιλαμβάνει μια μέτρηση θερμοκρασίας και μια χρονική σήμανση; **HumidityEvent** περιέχει μια μέτρηση υγρασία και μια χρονική σήμανση. Αυτό το μοντέλο μας παρέχει φυσικό τρόπο για να του μοντέλου δεδομένων για το σενάριο που περιγράφονται παραπάνω. Όταν σας στείλουμε ένα συμβάν στο cloud, θα σας στείλουμε είτε θερμοκρασίας/χρονικής σήμανσης ή σε ένα ζεύγος υγρασία/χρονικής σήμανσης.

Μπορούμε να στείλουμε ένα συμβάν θερμοκρασίας στο cloud χρησιμοποιώντας κώδικα όπως οι εξής:

```
time_t now;
time(&now);
thermostat->Temperature.Temperature = 75;
thermostat->Temperature.Time = GetDateTimeOffset(now);

unsigned char* destination;
size_t destinationSize;
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Θα σας θα χρησιμοποιήσετε σχεδιασμένου τιμές για θερμοκρασίας και υγρασίας στο δείγμα κώδικα, αλλά να φανταστείτε ότι θα σας στην πραγματικότητα ανακτάτε αυτές τις τιμές από δειγματοληψία το αντίστοιχο αισθητήρες στην το θερμοστάτη.

Ο κώδικας παραπάνω χρησιμοποιεί ο Βοηθός **GetDateTimeOffset** που έχει εισαχθεί προηγουμένως. Για τους λόγους που θα γίνει απαλοιφή νεότερη έκδοση, αυτόν τον κωδικό διαχωρίζει ρητά την εργασία σειριοποίησης και αποστολής το συμβάν. Τον προηγούμενο κώδικα τοποθετεί σειριακά θερμοκρασίας συμβάντος σε buffer. Στη συνέχεια, **sendMessage** είναι μια συνάρτηση Βοήθειας (περιλαμβάνονται στο **simplesample\_amqp**) που στέλνει το συμβάν σε διανομέα IoT:

```
static void sendMessage(IOTHUB_CLIENT_HANDLE iotHubClientHandle, const unsigned char* buffer, size_t size)
{
    static unsigned int messageTrackingId;
    IOTHUB_MESSAGE_HANDLE messageHandle = IoTHubMessage_CreateFromByteArray(buffer, size);
    if (messageHandle != NULL)
    {
        IoTHubClient_SendEventAsync(iotHubClientHandle, messageHandle, sendCallback, (void*)(uintptr_t)messageTrackingId);

        IoTHubMessage_Destroy(messageHandle);
    }
    free((void*)buffer);
}
```

Αυτός ο κώδικας είναι ένα υποσύνολο του του βοηθητικού προγράμματος **SendAsync** που περιγράφονται στην προηγούμενη ενότητα, ώστε να σας δεν θα μεταβείτε επάνω από αυτό ξανά εδώ.

Όταν μπορούμε να εκτελέσουμε τον προηγούμενο κώδικα για να στείλετε το συμβάν θερμοκρασία, αποστέλλεται αυτήν τη φόρμα αλληλουχίας του συμβάντος με διανομέα IoT:

```
{"Temperature":75, "Time":"2015-09-17T18:45:56Z"}
```

Θα σας στέλνετε θερμοκρασία που δεν είναι τύπου **TemperatureEvent** και δομή που περιέχει ένα μέλος της **θερμοκρασίας** και την **ώρα** . Ενημερώνεται απευθείας στο παράθυρο δεδομένων αλληλουχίας.

Ομοίως, μπορούμε να στείλουμε ένα συμβάν υγρασία με αυτόν τον κώδικα:

```
thermostat->Humidity.Humidity = 45;
thermostat->Humidity.Time = GetDateTimeOffset(now);
if (SERIALIZE(&destination, &destinationSize, thermostat->Humidity) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Η φόρμα αλληλουχίας που αποστέλλονται σε διανομέα IoT εμφανίζεται ως εξής:

```
{"Humidity":45, "Time":"2015-09-17T18:45:56Z"}
```

Ξανά, αυτή είναι όπως αναμένεται.

Με αυτό το μοντέλο, μπορείτε να φανταστείτε πώς πρόσθετα συμβάντα μπορούν εύκολα να προστεθούν. Μπορείτε να καθορίσετε περισσότερες δομές χρησιμοποιώντας **DECLARE\_ΔΟΜΉ**, και να συμπεριλάβετε το αντίστοιχο συμβάν το μοντέλο χρησιμοποιώντας **με\_ΔΕΔΟΜΈΝΩΝ**.

Τώρα, ας τροποποίηση του μοντέλου, έτσι ώστε να περιλαμβάνει τα ίδια δεδομένα αλλά με μια διαφορετική δομή.

### <a name="model-2"></a>Μοντέλο 2

Εξετάστε το ενδεχόμενο να αυτό το εναλλακτικό μοντέλο με την παραπάνω:

```
DECLARE_MODEL(Thermostat,
WITH_DATA(int, Temperature),
WITH_DATA(int, Humidity),
WITH_DATA(EDM_DATE_TIME_OFFSET, Time)
);
```

Σε αυτήν την περίπτωση θα σας διαγράψατε το **DECLARE\_ΔΟΜΉ** μακροεντολές και απλώς καθορίζει τα στοιχεία δεδομένων από το σενάριο Χρήση απλής τύπων από τη γλώσσα μοντελοποίησης.

Μόνο για τη χρονική στιγμή Παράβλεψη Ας το συμβάν **ώρα** . Με αυτήν την ακύρωση, ακολουθεί τον κώδικα στο εισόδου **θερμοκρασίας**:

```
time_t now;
time(&now);
thermostat->Temperature = 75;

unsigned char* destination;
size_t destinationSize;
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Αυτός ο κωδικός στέλνει το ακόλουθο συμβάν αλληλουχίας IoT διανομέα:

```
{"Temperature":75}
```

Και τον κωδικό για την αποστολή της εκδήλωσης υγρασία εμφανίζεται ως εξής:

```
thermostat->Humidity = 45;
if (SERIALIZE(&destination, &destinationSize, thermostat->Humidity) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Αυτός ο κωδικός αυτή στέλνει IoT διανομέα:

```
{"Humidity":45}
```

Μέχρι στιγμής εξακολουθούν να υπάρχουν χωρίς εκπλήξεις. Τώρα ας αλλάξουμε πώς χρησιμοποιούμε τη μακροεντολή SERIALIZE.

Η μακροεντολή **SERIALIZE** μπορεί να διαρκέσει συμβάντων πολλά δεδομένα ως ορίσματα. Αυτό σας επιτρέπει να σειριοποίηση το συμβάν **θερμοκρασίας** και **υγρασίας** μεταξύ τους και να τις στείλετε σε διανομέα IoT σε μία κλήση:

```
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature, thermostat->Humidity) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Που μπορεί να προβλέψει ότι το αποτέλεσμα του αυτός ο κώδικας είναι οποία αποστέλλονται τα συμβάντα δύο δεδομένων με διανομέα IoT:

[

{"Θερμοκρασίας": 75},

{"Υγρασία": 45}

]

Με άλλα λόγια, ίσως αναμένατε ότι αυτός ο κώδικας είναι ίδια με την αποστολή **θερμοκρασίας** και **υγρασίας** ξεχωριστά. Είναι απλώς μια ευκολία για τη μεταβίβαση και τα δύο συμβάντα **SERIALIZE** στην ίδια κλήση. Ωστόσο, που δεν είναι πεζών και κεφαλαίων γραμμάτων. Αντί για αυτό, τον παραπάνω κώδικα αποστέλλει αυτό το συμβάν δεδομένων μονής ακρίβειας IoT διανομέα:

{"Θερμοκρασίας": 75, "υγρασία": 45}

Αυτό μπορεί να φαίνεται ασυνήθιστο, επειδή το μοντέλο ορίζει **θερμοκρασίας** και **υγρασίας** ως δύο *ξεχωριστές* συμβάντα:

```
DECLARE_MODEL(Thermostat,
WITH_DATA(int, Temperature),
WITH_DATA(int, Humidity),
WITH_DATA(EDM_DATE_TIME_OFFSET, Time)
);
```

Περισσότερα για το σημείο, θα σας δεν μοντέλου αυτά τα συμβάντα όπου **θερμοκρασίας** και **υγρασίας** είναι με την ίδια διάρθρωση:

```
DECLARE_STRUCT(TemperatureAndHumidityEvent,
int, Temperature,
int, Humidity,
);

DECLARE_MODEL(Thermostat,
WITH_DATA(TemperatureAndHumidityEvent, TemperatureAndHumidity),
);
```

Εάν χρησιμοποιήσαμε αυτό το μοντέλο, θα ήταν πιο εύκολη για να κατανοήσετε τον τρόπο **θερμοκρασίας** και **υγρασίας** θα αποσταλούν στο ίδιο μήνυμα αλληλουχίας. Ωστόσο δεν μπορεί να είναι Απαλοιφή για ποιο λόγο να λειτουργεί με αυτόν τον τρόπο, όταν έχετε στείλει δύο συμβάντα δεδομένων **SERIALIZE** χρησιμοποιώντας μοντέλο 2.

Αυτή η συμπεριφορά είναι πιο κατανοητό Εάν γνωρίζετε τις υποθέσεις που πραγματοποιεί στη βιβλιοθήκη **σειριοποιητής** . Για να κάνετε νόημα της παρούσας επιστρέψτε στο μοντέλο μας:

```
DECLARE_MODEL(Thermostat,
WITH_DATA(int, Temperature),
WITH_DATA(int, Humidity),
WITH_DATA(EDM_DATE_TIME_OFFSET, Time)
);
```

Θεωρήστε ότι αυτό το μοντέλο σε όρους προσανατολισμένα σε αντικείμενα. Σε αυτήν την περίπτωση θα σας μοντελοποίησης μια φυσική συσκευή (μια θερμοστάτη) και αυτήν τη συσκευή περιλαμβάνει χαρακτηριστικά όπως **θερμοκρασίας** και **υγρασίας**.

Μπορούμε να στείλουμε την κατάσταση ολόκληρου του μας μοντέλο με κώδικα, όπως οι εξής:

```
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature, thermostat->Humidity, thermostat->Time) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Υπό την προϋπόθεση ότι οι τιμές της θερμοκρασίας, ορίζονται υγρασία και την ώρα, βλέπουμε ένα συμβάν όπως αυτό που αποστέλλονται σε διανομέα IoT:

```
{"Temperature":75, "Humidity":45, "Time":"2015-09-17T18:45:56Z"}
```

Μερικές φορές μπορεί να θέλετε μόνο να στείλετε *ορισμένες* ιδιότητες του μοντέλου στο cloud (αυτό είναι ιδιαίτερα true εάν το μοντέλο περιέχει ένα μεγάλο αριθμό συμβάντα δεδομένων). Είναι χρήσιμο για να στείλετε μόνο ένα υποσύνολο των δεδομένων συμβάντα, όπως στο προηγούμενο παράδειγμά μας:

```
{"Temperature":75, "Time":"2015-09-17T18:45:56Z"}
```

Αυτό δημιουργεί ακριβώς το ίδιο συμβάν αλληλουχίας σαν να είχατε ορίσαμε μια **TemperatureEvent** με ένα μέλος **θερμοκρασίας** και **χρόνου** , όπως ακριβώς κάναμε με μοντέλο 1. Σε αυτήν την περίπτωση ήταν δυνατό να δημιουργηθεί ακριβώς το ίδιο αλληλουχίας συμβάν χρησιμοποιώντας ένα διαφορετικό μοντέλο (μοντέλο 2), επειδή θα σας που ονομάζεται **SERIALIZE** με διαφορετικό τρόπο.

Το σημαντικό σημείο είναι ότι εάν δώσετε συμβάντων πολλά δεδομένα στη **SERIALIZE,** στη συνέχεια, θεωρείται ότι κάθε συμβάντος είναι μια ιδιότητα στο σε ένα αντικείμενο JSON.

Ο καλύτερος τρόπος εξαρτάται από το που και πώς να σκεφτείτε το μοντέλο. Εάν στέλνετε "συμβάντα" στο cloud και κάθε συμβάντος περιέχει ένα ορισμένο σύνολο ιδιοτήτων, στη συνέχεια, η πρώτη προσέγγιση καθιστά πολύ νόημα. Σε αυτήν την περίπτωση θα χρησιμοποιούσατε **DECLARE\_ΔΟΜΉ** για να ορίσετε τη δομή του κάθε συμβάν και, στη συνέχεια, να τις συμπεριλάβετε στο μοντέλο σας με το **με\_ΔΕΔΟΜΈΝΩΝ** μακροεντολής. Στη συνέχεια, στείλτε κάθε συμβάντος όπως κάναμε στο παραπάνω παράδειγμα πρώτη. Σε αυτήν την προσέγγιση να δώσετε μόνο ένα συμβάν δεδομένων μονής ακρίβειας στη **ΣΕΙΡΙΟΠΟΙΗΤΉΣ**.

Εάν πιστεύετε ότι σχετικά με το μοντέλο σας με τον τρόπο προσανατολισμένα σε αντικείμενα, στη συνέχεια, τη δεύτερη προσέγγιση μπορεί να προτιμήσεις σας. Σε αυτήν την περίπτωση, τα στοιχεία που ορίζονται από το χρησιμοποιώντας **με\_ΔΕΔΟΜΈΝΩΝ** είναι οι "Ιδιότητες" του αντικειμένου σας. Έχετε στείλει όποιο υποσύνολο συμβάντων **SERIALIZE** που σας αρέσει, ανάλογα με τον όγκο της σας "του αντικειμένου" κατάσταση στην οποία θέλετε να στείλετε στο cloud.

Nether προσέγγιση είναι προς τα δεξιά ή λάθος. Απλώς να γνωρίζουν πώς λειτουργεί η βιβλιοθήκη **σειριοποιητής** και επιλέξτε την προσέγγιση μοντελοποίηση που ταιριάζει καλύτερα στις ανάγκες σας.

## <a name="message-handling"></a>Χειρισμό μηνυμάτων

Μέχρι στιγμής σε αυτό το άρθρο περιλαμβάνει μόνο αναφέρονται αποστολή συμβάντα IoT διανομέα και δεν έχει απαντήσει λαμβάνετε μηνύματα. Ο λόγος για αυτό είναι ότι οι τι πρέπει να γνωρίζετε σχετικά με τη λήψη μηνυμάτων έχει σε μεγάλο βαθμό καλύπτεται σε μια [προηγούμενη το άρθρο](iot-hub-device-sdk-c-intro.md). Ανάκληση από αυτό το άρθρο επεξεργασία μηνυμάτων με την καταχώρηση μιας συνάρτησης επιστροφής κλήσης μήνυμα:

```
IoTHubClient_SetMessageCallback(iotHubClientHandle, IoTHubMessage, myWeather)
```

Στη συνέχεια, συντάξτε τη συνάρτηση επιστροφής κλήσης που ενεργοποιείται όταν λαμβάνετε ένα μήνυμα:

```
static IOTHUBMESSAGE_DISPOSITION_RESULT IoTHubMessage(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    IOTHUBMESSAGE_DISPOSITION_RESULT result;
    const unsigned char* buffer;
    size_t size;
    if (IoTHubMessage_GetByteArray(message, &buffer, &size) != IOTHUB_MESSAGE_OK)
    {
        printf("unable to IoTHubMessage_GetByteArray\r\n");
        result = EXECUTE_COMMAND_ERROR;
    }
    else
    {
        /*buffer is not zero terminated*/
        char* temp = malloc(size + 1);
        if (temp == NULL)
        {
            printf("failed to malloc\r\n");
            result = EXECUTE_COMMAND_ERROR;
        }
        else
        {
            memcpy(temp, buffer, size);
            temp[size] = '\0';
            EXECUTE_COMMAND_RESULT executeCommandResult = EXECUTE_COMMAND(userContextCallback, temp);
            result =
                (executeCommandResult == EXECUTE_COMMAND_ERROR) ? IOTHUBMESSAGE_ABANDONED :
                (executeCommandResult == EXECUTE_COMMAND_SUCCESS) ? IOTHUBMESSAGE_ACCEPTED :
                IOTHUBMESSAGE_REJECTED;
            free(temp);
        }
    }
    return result;
}
```

Αυτή η υλοποίηση του **IoTHubMessage** κλήσεις τη συγκεκριμένη συνάρτηση για κάθε ενέργεια στο μοντέλο σας. Για παράδειγμα, εάν το μοντέλο ορίζει αυτήν την ενέργεια:

```
WITH_ACTION(SetAirResistance, int, Position)
```

Πρέπει να καθορίσετε μια συνάρτηση με αυτήν την υπογραφή:

```
EXECUTE_COMMAND_RESULT SetAirResistance(ContosoAnemometer* device, int Position)
{
    (void)device;
    (void)printf("Setting Air Resistance Position to %d.\r\n", Position);
    return EXECUTE_COMMAND_SUCCESS;
}
```

**SetAirResistance** καλείται, στη συνέχεια, όταν το μήνυμα αποστέλλεται στη συσκευή σας.

Τι θα σας δεν κάνει επεξήγηση είναι ακόμη πώς φαίνεται η σειριακή έκδοση του μηνύματος. Με άλλα λόγια, εάν θέλετε να στείλετε ένα μήνυμα **SetAirResistance** στη συσκευή σας, τι που μοιάζει;

Εάν στέλνετε ένα μήνυμα σε μια συσκευή, μπορείτε να το κάνετε μέσω της υπηρεσίας Azure IoT SDK. Εξακολουθεί να πρέπει να γνωρίζετε σχετικά με τη συμβολοσειρά για την αποστολή για να καλέσετε μια συγκεκριμένη ενέργεια. Η γενική μορφή για την αποστολή ενός μηνύματος εμφανίζεται ως εξής:

```
{"Name" : "", "Parameters" : "" }
```

Στέλνετε ένα αντικείμενο αλληλουχίας JSON με δύο ιδιότητες: **όνομα** είναι το όνομα της ενέργειας (μήνυμα) και **τις παραμέτρους** περιέχει τις παραμέτρους των εν λόγω ενεργειών.

Για παράδειγμα, για να καλέσετε **SetAirResistance** μπορείτε να στείλετε το μήνυμα σε μια συσκευή:

```
{"Name" : "SetAirResistance", "Parameters" : { "Position" : 5 }}
```

Το όνομα της ενέργειας πρέπει να αντιστοιχεί ακριβώς μια ενέργεια που ορίζονται στο μοντέλο σας. Τα ονόματα παραμέτρων πρέπει να συμφωνούν με φυσική παρουσία. Επίσης, σημειώστε διάκριση πεζών-κεφαλαίων. **Όνομα** και **παραμέτρους** είναι πάντα κεφαλαία γράμματα. Βεβαιωθείτε ότι ανάλογα με την περίπτωση, το όνομα της ενέργειας και οι παράμετροι στο μοντέλο σας. Σε αυτό το παράδειγμα, το όνομα της ενέργειας είναι "SetAirResistance" και δεν "setairresistance".

Αυτή η ενότητα περιγράφεται όλα όσα πρέπει να γνωρίζω πότε συμβάντα αποστολή και λήψη μηνυμάτων με τη βιβλιοθήκη **σειριοποιητής** . Πριν περάσετε στην, ας καλύπτει ορισμένες παράμετροι που μπορείτε να ρυθμίσετε τις παραμέτρους που ελέγχουν είναι το μέγεθος του μοντέλου.

## <a name="macro-configuration"></a>Ρύθμιση παραμέτρων μακροεντολής

Εάν χρησιμοποιείτε τη βιβλιοθήκη **σειριοποιητής** σημαντικό τμήμα του SDK πρέπει να γνωρίζετε βρίσκεται στη βιβλιοθήκη του azure-c-κοινή χρήση-βοηθητικού προγράμματος.
Εάν έχετε κλωνοποιηθεί του αποθετηρίου Azure-iot-sdks από GitHub χρησιμοποιώντας την επιλογή--περιοδικότητας, στη συνέχεια, θα βρείτε εδώ αυτήν τη βιβλιοθήκη κοινόχρηστων βοηθητικού προγράμματος:

```
.\\c\\azure-c-shared-utility
```

Εάν που δεν έχουν κλωνοποιηθεί στη βιβλιοθήκη, μπορείτε να το βρείτε [εδώ](https://github.com/Azure/azure-c-shared-utility).

Μέσα από τη βιβλιοθήκη κοινόχρηστων βοηθητικού προγράμματος, θα βρείτε παρακάτω φάκελο:

```
azure-c-shared-utility\\macro\_utils\_h\_generator.
```

Αυτός ο φάκελος περιέχει μια λύση Visual Studio, που ονομάζεται **μακροεντολής\_βοηθητικά προγράμματα\_h\_generator.sln**:

  ![](media/iot-hub-device-sdk-c-serializer/01-macro_utils_h_generator.PNG)

Το πρόγραμμα σε αυτήν τη λύση δημιουργεί το **μακροεντολής\_utils.h** αρχείου. Υπάρχει μια μακροεντολή προεπιλεγμένη\_αρχείο utils.h που περιλαμβάνεται στο SDK. Αυτή η λύση σάς επιτρέπει να τροποποιήσετε ορισμένες παραμέτρους και, στη συνέχεια, δημιουργήστε ξανά το αρχείο κεφαλίδας που βασίζονται σε αυτές τις παραμέτρους.

Οι δύο παράμετροι κλειδιού για να ενημερώνουν και να είναι **nArithmetic** και **nMacroParameters** που ορίζονται σε αυτές τις δύο γραμμές που βρίσκονται στη μακροεντολή\_utils.tt:

```
<#int nArithmetic=1024;#>
<#int nMacroParameters=124;/*127 parameters in one macro deﬁnition in C99 in chapter 5.2.4.1 Translation limits*/#>

```

Αυτές οι τιμές είναι τις προεπιλεγμένες παραμέτρους περιλαμβάνεται με το SDK. Κάθε παράμετρο περιλαμβάνει τα παρακάτω σημασία:

-   nMacroParameters – ελέγχει τις παραμέτρους μπορείτε να έχετε σε ένα DECLARE\_ΜΟΝΤΈΛΟ ορισμό της μακροεντολής.

-   nArithmetic – ελέγχει τον συνολικό αριθμό των μελών που επιτρέπεται σε ένα μοντέλο.

Αυτές οι παράμετροι είναι σημαντικές συμβαίνει επειδή ελέγχουν πόσο μεγάλο μπορεί να είναι το μοντέλο. Για παράδειγμα, εξετάστε το ενδεχόμενο να αυτόν τον ορισμό μοντέλου:

```
DECLARE_MODEL(MyModel,
WITH_DATA(int, MyData)
);
```

Όπως προαναφέρθηκε, **DECLARE\_ΜΟΝΤΈΛΟ** είναι απλώς μια μακροεντολή C. Τα ονόματα του μοντέλου και το **με\_ΔΕΔΟΜΈΝΩΝ** δήλωση (ακόμη άλλης μακροεντολής) είναι παραμέτρους **DECLARE\_ΜΟΝΤΈΛΟ**. **nMacroParameters** καθορίζει πόσες παραμέτρους μπορεί να συμπεριληφθεί σε **DECLARE\_ΜΟΝΤΈΛΟ**. Αποτελεσματική, αυτή καθορίζει πόσες δεδομένων συμβάν ενέργεια δηλώσεις και μπορείτε να έχετε. Ως εκ τούτου, με το προεπιλεγμένο όριο 124 αυτό σημαίνει ότι μπορείτε να ορίσετε ένα μοντέλο με ένα συνδυασμό περίπου 60 ενέργειες και συμβάντα δεδομένων. Εάν προσπαθήσετε να υπερβαίνει αυτό το όριο, θα λάβετε σφάλματα προγράμματος μεταγλώττισης που μοιάζει με αυτό:

  ![](media/iot-hub-device-sdk-c-serializer/02-nMacroParametersCompilerErrors.PNG)

Η παράμετρος **nArithmetic** είναι περισσότερα σχετικά με τις εσωτερικές λειτουργίες του γλώσσα μακροεντολών από την εφαρμογή σας.  Ελέγχει τον συνολικό αριθμό των μελών, μπορείτε να έχετε στο μοντέλο σας, συμπεριλαμβανομένων των μακροεντολών **DECLARE_STRUCT** . Εάν ξεκινήσετε βλέπουν σφάλματα προγράμματος μεταγλώττισης όπως αυτή, στη συνέχεια, θα πρέπει να προσπαθείτε αύξηση **nArithmetic**:

   ![](media/iot-hub-device-sdk-c-serializer/03-nArithmeticCompilerErrors.PNG)

Εάν θέλετε να αλλάξετε αυτές τις παραμέτρους, τροποποιήστε τις τιμές στη μακροεντολή\_utils.tt αρχείων, μεταγλωττίσετε ξανά τη μακροεντολή\_βοηθητικά προγράμματα\_h\_generator.sln λύση και εκτελέστε το μεταγλωττισμένο πρόγραμμα. Όταν το κάνετε αυτό, μια νέα μακροεντολή\_δημιουργείται και τοποθετείται στο αρχείο utils.h του. \\κοινών\\inc καταλόγου.

Για να χρησιμοποιήσετε τη νέα έκδοση της μακροεντολής\_utils.h, καταργήστε το πακέτο NuGet **σειριοποιητής** από τη λύση σας και στη θέση περιλαμβάνει το έργο Visual Studio **σειριοποιητής** . Αυτή η δυνατότητα επιτρέπει τον κωδικό για να μεταγλωττίσετε σε σχέση με το πηγαίου κώδικα της βιβλιοθήκης σειριοποιητής. Αυτό περιλαμβάνει ενημερωμένα μακροεντολής\_utils.h. Εάν θέλετε να το κάνετε αυτό **simplesample\_amqp**, ξεκινήστε με την κατάργηση του πακέτου NuGet για τη βιβλιοθήκη σειριοποιητής από τη λύση:

   ![](media/iot-hub-device-sdk-c-serializer/04-serializer-github-package.PNG)

Στη συνέχεια, προσθέστε αυτό το έργο στη λύση του Visual Studio σας:

> . \\c\\σειριοποιητής\\Δημιουργία\\windows\\serializer.vcxproj

Όταν ολοκληρώσετε τη διαδικασία, τη λύση σας θα πρέπει να μοιάζει ως εξής:

   ![](media/iot-hub-device-sdk-c-serializer/05-serializer-project.PNG)

Τώρα όταν μεταγλώττιση τη λύση σας, η μακροεντολή ενημερωμένη\_utils.h περιλαμβάνει το δυαδικό αριθμό.

Σημειώστε ότι η αυξάνοντας αυτές τις τιμές που είναι αρκετά υψηλή ώστε να υπερβαίνει προγράμματος μεταγλώττισης όρια. Σε αυτό το σημείο, το **nMacroParameters** είναι η κύρια παράμετρος με τον οποίο θα ενδιαφέρονται. Οι προδιαγραφές C99 Καθορίζει ότι τουλάχιστον 127 παράμετροι επιτρέπονται στον ορισμό μιας μακροεντολής. Το πρόγραμμα μεταγλώττισης Microsoft ακολουθεί ακριβώς την προδιαγραφή (και έχει όριο 127), επομένως δεν θα μπορείτε να αυξήσετε **nMacroParameters** πέρα από την προεπιλεγμένη. Άλλα προγράμματα μεταγλώττισης μπορεί να σας επιτρέπει να κάνετε (για παράδειγμα, το πρόγραμμα μεταγλώττισης GNU υποστηρίζει ανώτερο όριο).

Μέχρι στιγμής μας έχετε καλύπτεται σχεδόν όλα τα στοιχεία που πρέπει να γνωρίζετε σχετικά με τη σύνταξη κώδικα με τη βιβλιοθήκη **σειριοποιητής** . Πριν από τη σύναψη, ας τρόπος για να αναθεωρήσετε ορισμένα θέματα από το προηγούμενο άρθρα που ίσως αναρωτιέστε σχετικά με.

## <a name="the-lower-level-apis"></a>Τα API κατώτερου επιπέδου

Το δείγμα εφαρμογής στην οποία εστιασμένη σε αυτό το άρθρο είναι **simplesample\_amqp**. Αυτό το δείγμα χρησιμοποιεί το υψηλότερου επιπέδου (η μη-"α") API για συμβάντα αποστολή και λήψη μηνυμάτων. Εάν χρησιμοποιείτε αυτά τα API, εκτελεί ένα νήμα παρασκηνίου που αναλαμβάνει τόσο συμβάντα αποστολή και λήψη μηνυμάτων. Ωστόσο, μπορείτε να χρησιμοποιήσετε τα API κατώτερου επιπέδου (α) για να αποφύγετε αυτό το νήμα φόντου και να λαμβάνουν ρητή έλεγχο κατά την αποστολή συμβάντων και λήψη μηνυμάτων από το cloud.

Όπως περιγράφεται σε ένα [προηγούμενο άρθρο](iot-hub-device-sdk-c-iothubclient.md), υπάρχει ένα σύνολο συναρτήσεων που αποτελείται από τα API υψηλότερου επιπέδου:

-   IoTHubClient\_CreateFromConnectionString

-   IoTHubClient\_SendEventAsync

-   IoTHubClient\_SetMessageCallback

-   IoTHubClient\_Destroy

Αυτά τα API εκδηλώνονται σε **simplesample\_amqp**.

Υπάρχει επίσης μια ανάλογος σύνολο API κατώτερου επιπέδου.

-   IoTHubClient\_α\_CreateFromConnectionString

-   IoTHubClient\_α\_SendEventAsync

-   IoTHubClient\_α\_SetMessageCallback

-   IoTHubClient\_α\_καταστροφή

Σημειώστε ότι τα API κατώτερου επιπέδου λειτουργεί ακριβώς όπως περιγράφεται στα προηγούμενα άρθρα. Μπορείτε να χρησιμοποιήσετε το πρώτο σύνολο των API, εάν θέλετε ένα νήμα παρασκηνίου χειρισμού συμβάντων αποστολή και λήψη μηνυμάτων. Μπορείτε να χρησιμοποιήσετε το δεύτερο σύνολο των API εάν θέλετε ρητή έλεγχο κατά την αποστολή ή λήψη δεδομένων από διανομέα IoT. Είτε σύνολο εργασίας APIs εξίσου καλά με τη βιβλιοθήκη **σειριοποιητής** .

Για παράδειγμα πώς χρησιμοποιούνται τα API κατώτερου επιπέδου με τη βιβλιοθήκη **σειριοποιητής** , ανατρέξτε στο θέμα το **simplesample\_http** εφαρμογής.

## <a name="additional-topics"></a>Πρόσθετα θέματα

Ορισμένα άλλα θέματα αξίζει η αναφορά είναι ξανά την ιδιότητα χειρισμός, χρησιμοποιώντας τα διαπιστευτήρια εναλλακτική συσκευή και επιλογές ρύθμισης παραμέτρων. Αυτά είναι όλα τα θέματα που καλύπτονται σε ένα [προηγούμενο άρθρο](iot-hub-device-sdk-c-iothubclient.md). Το κύριο σημείο είναι όλες αυτές τις δυνατότητες λειτουργούν με τον ίδιο τρόπο με τη βιβλιοθήκη **σειριοποιητής** τρόπο όπως με τη βιβλιοθήκη **IoTHubClient** . Για παράδειγμα, εάν θέλετε να επισυνάψετε ιδιότητες σε ένα συμβάν από το μοντέλο σας, μπορείτε χρησιμοποιήσετε **IoTHubMessage\_ιδιότητες** και **χάρτη**\_**AddorUpdate**, τον ίδιο τρόπο όπως περιγράφεται προηγουμένως:

```
MAP_HANDLE propMap = IoTHubMessage_Properties(message.messageHandle);
sprintf_s(propText, sizeof(propText), "%d", i);
Map_AddOrUpdate(propMap, "SequenceNumber", propText);
```

Εάν το συμβάν έχει που δημιουργούνται από τη βιβλιοθήκη **σειριοποιητής** ή δημιουργήθηκε με μη αυτόματο τρόπο χρησιμοποιώντας τη βιβλιοθήκη **IoTHubClient** δεν έχει σημασία.

Για τα διαπιστευτήρια εναλλακτική συσκευή, χρησιμοποιώντας **IoTHubClient\_α\_δημιουργία** λειτουργεί το ίδιο καλά ως **IoTHubClient\_CreateFromConnectionString** για την κατανομή μιας **IOTHUB\_προγράμματος-ΠΕΛΆΤΗ\_ΧΕΙΡΙΣΜΟΎ**.

Τέλος, εάν χρησιμοποιείτε τη βιβλιοθήκη **σειριοποιητής** , μπορείτε να ορίσετε επιλογές ρύθμισης παραμέτρων με **IoTHubClient\_α\_SetOption** ακριβώς όπως όταν χρησιμοποιείτε τη βιβλιοθήκη **IoTHubClient** .

Μια δυνατότητα που είναι μοναδικό στη βιβλιοθήκη **σειριοποιητής** είναι η προετοιμασία APIs. Πριν ξεκινήσετε να εργάζεστε με τη βιβλιοθήκη, πρέπει να καλέσετε **σειριοποιητής\_προετοιμασία**:

```
serializer_init(NULL);
```

Αυτό γίνεται μόνο πριν καλέσετε **IoTHubClient\_CreateFromConnectionString**.

Ομοίως, όταν ολοκληρώσετε τη διαδικασία εργάζεστε με τη βιβλιοθήκη, την τελευταία κλήση θα κάνετε είναι να **σειριοποιητής\_deinit**:

```
serializer_deinit();
```

Διαφορετικά, όλες οι άλλες δυνατότητες που αναφέρονται παραπάνω λειτουργούν με τον ίδιο στη βιβλιοθήκη **σειριοποιητής** όπως εμφανίζονται στη βιβλιοθήκη **IoTHubClient** . Για περισσότερες πληροφορίες σχετικά με οποιαδήποτε από αυτά τα θέματα, ανατρέξτε στο [άρθρο προηγούμενη](iot-hub-device-sdk-c-iothubclient.md) σε αυτήν τη σειρά.

## <a name="next-steps"></a>Επόμενα βήματα

Σε αυτό το άρθρο περιγράφει με λεπτομέρεια τις μοναδικές πτυχές της βιβλιοθήκης **σειριοποιητής** που περιέχονται στη **συσκευή Azure IoT SDK για C**. Με τις πληροφορίες που θα πρέπει να έχετε μια καλή Κατανόηση του τρόπου χρήσης μοντέλων για συμβάντα αποστολή και λήψη μηνυμάτων από διανομέα IoT.

Έτσι ολοκληρώνεται επίσης τη σειρά τριών τμημάτων σχετικά με τον τρόπο για να αναπτύξετε εφαρμογές με τη **συσκευή Azure IoT SDK για C**. Αυτό πρέπει να αρκετές πληροφορίες όχι μόνο για να ξεκινήσετε, αλλά σας δώσει γνώσεις σχετικά με τον τρόπο που λειτουργούν τα API. Για περισσότερες πληροφορίες, υπάρχουν μερικά δείγματα στο SDK δεν καλύπτεται εδώ. Διαφορετικά, την [τεκμηρίωση SDK](https://github.com/Azure/azure-iot-sdks) είναι ένας χρήσιμος πόρος για πρόσθετες πληροφορίες.


Για να μάθετε περισσότερα σχετικά με την ανάπτυξη IoT διανομέα, ανατρέξτε στο θέμα το [SDK διανομέα IoT][lnk-sdks].

Για να εξερευνήσετε περαιτέρω τις δυνατότητες του IoT διανομέα, ανατρέξτε στα θέματα:

- [Προσομοίωση μια συσκευή με το SDK IoT πύλης][lnk-gateway]

[lnk-sdks]: iot-hub-devguide-sdks.md

[lnk-gateway]: iot-hub-linux-gateway-sdk-simulated-device.md
