<properties 
    pageTitle="Αναφορά στην ανάλυση σε εφαρμογή ιδέες | Microsoft Azure" 
    description="Αναφορά για δηλώσεις στην ανάλυση, το εργαλείο ισχυρή αναζήτησης της εφαρμογής ιδέες. " 
    services="application-insights" 
    documentationCenter=""
    authors="alancameronwills" 
    manager="douge"/>

<tags 
    ms.service="application-insights" 
    ms.workload="tbd" 
    ms.tgt_pltfrm="ibiza" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.date="10/27/2016" 
    ms.author="awills"/>

# <a name="reference-for-analytics"></a>Αναφορά για ανάλυση

[Ανάλυση](app-insights-analytics.md) είναι η δυνατότητα ισχυρή αναζήτησης της [Εφαρμογής ιδέες](app-insights-overview.md). Αυτές οι σελίδες περιγράφουν τη γλώσσα ερωτήματος ανάλυσης.

> [AZURE.NOTE] [Μονάδα δίσκου δοκιμή ανάλυσης μας προσομοιωμένη δεδομένα](https://analytics.applicationinsights.io/demo) κατά την εφαρμογή σας δεν είναι αποστολή δεδομένων σε εφαρμογή ιδέες ακόμη.

## <a name="index"></a>Ευρετήριο


**Ενημερώστε** [ενημερώστε](#let-clause)


**Ερωτήματα και τελεστών** [Καταμέτρηση](#count-operator)  |  [αξιολόγηση](#evaluate-operator) | [επέκταση](#extend-operator) | [συνδέσμου](#join-operator) | [όριο](#limit-operator) | [mvexpand](#mvexpand-operator) | [ανάλυση](#parse-operator) | [έργου](#project-operator) | [έργου-δεν βρίσκομαι στον υπολογιστή](#project-away-operator) | [περιοχή](#range-operator) | [μείωση](#reduce-operator) | [απόδοση οδηγία](#render-directive) | [Περιορισμός όρος](#restrict-clause) | [Ταξινόμηση](#sort-operator) | [Σύνοψη](#summarize-operator) | [λαμβάνουν](#take-operator) | [επάνω](#top-operator) | [ένθετες επάνω](#top-nested-operator) | [ένωσης](#union-operator) | [όπου](#where-operator) | [πού στο](#where-in-operator)

**Συναθροίσεις** [οποιαδήποτε](#any)  |  [argmax](#argmax) | [argmin](#argmin) | [avg](#avg) | [buildschema](#buildschema) | [Πλήθος](#count) | [countif](#countif) | [dcount](#dcount) | [dcountif](#dcountif) | [makelist](#makelist) | [makeset](#makeset) | [max](#max) | [min](#min) | [εκατοστημόριο](#percentile) | [εκατοστημόριου](#percentiles) | [percentilesw](#percentilesw) | [percentilew](#percentilew) | [stdev](#stdev) | [άθροισμα](#sum) | [διακύμανση](#variance)

**Scalars** [Σταθερές Boolean](#boolean-literals)  |  [Οι τελεστές Boolean](#boolean-operators) | [αποκλίσεων](#casts) | [ανυσματική συγκρίσεις](#scalar-comparisons) | [gettype](#gettype) | [κατακερματισμός](#hash) | [iff](#iff) | [isnotnull](#isnotnull) | [isnull](#isnull) | [notnull](#notnull) | [toscalar](#toscalar)

**Αριθμοί** [Αριθμητικοί τελεστές](#arithmetic-operators)  |  [Αριθμητικές σταθερές](#numeric-literals) | [abs](#abs) | [Ανακύκλωσης](#bin) | [exp](#exp) | [floor](#floor) | [γάμμα](#gamma) | [καταγραφής](#log) | [rand](#rand) | [sqrt](#sqrt) | [todouble](#todouble) | [toint](#toint) | [tolong](#tolong)

**Ημερομηνίας και ώρας** [Ημερομηνίας και ώρας παραστάσεις](#date-and-time-expressions)  |  [Ημερομηνίας και ώρας](#date-and-time-literals) | [πριν](#ago) | [datepart](#datepart) | [dayofmonth](#dayofmonth) | [dayofweek](#dayofweek) | [dayofyear](#dayofyear) | [endofday](#endofday) | [endofmonth](#endofmonth) | [endofweek](#endofweek) | [endofyear](#endofyear) | [getmonth](#getmonth) | [getyear](#getyear) | [τώρα](#now) | [startofday](#startofday) | [startofmonth](#startofmonth) | [startofweek](#startofweek) | [startofyear](#startofyear) | [todatetime](#todatetime) | [totimespan](#totimespan) | [weekofyear](#weekofyear)

**Συμβολοσειρά** [GUID](#guids)  |  [Ασαφή συμβολοσειρές κειμένου](#obfuscated-string-literals) | [Συμβολοσειρές κειμένου](#string-literals) | [συγκρίσεις συμβολοσειρών](#string-comparisons) | [countof](#countof) | [εξαγάγετε](#extract) | [isempty](#isempty) | [isnotempty](#isnotempty) | [notempty](#notempty)| [parseurl](#parseurl) | [Αντικατάσταση](#replace) | [Διαίρεση](#split) | [strcat](#strcat) | [strlen](#strlen) | [δευτερεύουσα συμβολοσειρά](#substring) | [tolower](#tolower) | [toupper](#toupper)

**Πίνακες, αντικείμενα και δυναμικές** [Λεκτικές σταθερές πίνακα και αντικειμένων](#array-and-object-literals)  |  [Δυναμικό αντικείμενο συναρτήσεις](#dynamic-object-functions) | [δυναμικών αντικειμένων στους όρους σας επιτρέπουν να](#dynamic-objects-in-let-clauses) | [διαδρομή JSON παραστάσεις](#json-path-expressions) | [ονόματα](#names) | [arraylength](#arraylength) | [extractjson](#extractjson) | [parsejson](#parsejson) | [περιοχή](#range) | [todynamic](#todynamic) | [treepath](#treepath)



## <a name="let"></a>Ενημερώστε

### <a name="let-clause"></a>Ενημερώστε τον όρο FROM

**Σε πίνακα σας επιτρέπουν να - ονομασία ενός πίνακα**

    let recentReqs = requests | where timestamp > ago(3d); 
    recentReqs | count

**Συναρτήσεις ανυσμάτων σας επιτρέπουν να - ονομασία μιας τιμής**

    let interval = 3d; 
    requests | where timestamp > ago(interval)

**Λάμδα σας επιτρέπουν να - ονομασία μιας συνάρτησης**

    let Recent = 
       (interval:timespan) { requests | where timestamp > ago(interval) };
    Recent(3h) | count

    let us_date = (t:datetime) { strcat(getmonth(t),'/',dayofmonth(t),'/',getyear(t)) }; 
    requests | summarize count() by bin(timestamp, 1d) | project count_, day=us_date(timestamp)

Ένας όρος που σας επιτρέπουν να συνδέει ένα [όνομα](#names) με ένα αποτέλεσμα σε μορφή πίνακα, ανυσματική τιμή ή συνάρτηση. Ο όρος είναι ένα πρόθεμα για ένα ερώτημα και το εύρος της σύνδεσης είναι το ερώτημα. (Σας επιτρέπουν να δεν παρέχει κάποιο τρόπο για να όνομα πράγματα που μπορείτε να χρησιμοποιήσετε αργότερα σε περίοδο λειτουργίας σας.)

**Σύνταξη**

    let name = scalar_constant_expression ; query

    let name = query ; query

    let name = (parameterName : type [, ...]) { plain_query }; query

    let name = (parameterName : type [, ...]) { scalar_expression }; query

* *Τύπος:* `bool`, `int`, `long`, `double`, `string`, `timespan`, `datetime`, `guid`,[`dynamic`](#dynamic-type)
* *plain_query:* Ένα ερώτημα το πρόθεμα δεν από έναν όρο να επιτρέπεται.

**Παραδείγματα**

    let rows = (n:long) { range steps from 1 to n step 1 };
    rows(10) | ...


Ιδιο-σύνδεσμος:

    let Recent = events | where timestamp > ago(7d);
    Recent | where name contains "session_started" 
  	| project start = timestamp, session_id
  	| join (Recent 
        | where name contains "session_ended" 
        | project stop = timestamp, session_id)
      on session_id
  	| extend duration = stop - start 


## <a name="queries-and-operators"></a>Ερωτήματα και τελεστών

Ένα ερώτημα σας τηλεμετρίας αποτελείται από μια αναφορά σε μια ροή προέλευσης, ακολουθούμενο από μια διοχέτευση των φίλτρων. Για παράδειγμα:


```AIQL
requests // The request table starts this pipeline.
| where client_City == "London" // filter the records
   and timestamp > ago(3d)
| count 
```
    
Κάθε φίλτρο το πρόθεμα το χαρακτήρα καθέτου `|` είναι μια παρουσία του *τελεστή*, με ορισμένες παράμετροι. Η είσοδος για να τον τελεστή είναι ο πίνακας που είναι το αποτέλεσμα από την προηγούμενη διαδικασία. Στις περισσότερες περιπτώσεις, [ανυσματική παραστάσεις](#scalars) έχουν τις παραμέτρους των στηλών της εισόδου. Σε ορισμένες περιπτώσεις, οι παράμετροι είναι τα ονόματα των στηλών εισαγωγής και, σε ορισμένες περιπτώσεις, η παράμετρος είναι ένα δεύτερο πίνακα. Το αποτέλεσμα του ερωτήματος είναι πάντα έναν πίνακα, ακόμα και αν έχει μόνο μία στήλη και μία γραμμή.

Τα ερωτήματα μπορεί να περιέχει αλλαγές μονή γραμμή, αλλά τερματίζονται από μια κενή γραμμή. Ενδέχεται να περιέχουν σχόλια μεταξύ `//` και στο τέλος της γραμμής.

Ένα ερώτημα μπορεί να έχει το πρόθεμα με μία ή περισσότερες [σας επιτρέπουν να όρους](#let-clause), οι οποίοι καθορίζουν scalars, πίνακες ή συναρτήσεις που μπορούν να χρησιμοποιηθούν μέσα στο ερώτημα.

```AIQL

    let interval = 3d ;
    let city = "London" ;
    let req = (city:string) {
      requests
      | where client_City == city and timestamp > ago(interval) };
    req(city) | count
```

> `T`χρησιμοποιείται στα παρακάτω παραδείγματα ερωτήματος για να καταδείξετε παραπάνω πίνακα διοχέτευσης ή προέλευση.
> 

### <a name="count-operator"></a>Τελεστής Count

Το `count` τελεστή επιστρέφει τον αριθμό των εγγραφές (γραμμές) στο σύνολο εγγραφών της εισαγωγής.

**Σύνταξη**

    T | count

**Ορίσματα**

* *T*: τα δεδομένα σε μορφή πίνακα των οποίων οι εγγραφές έχουν προς μέτρηση.

**Επιστρέφει**

Αυτή η συνάρτηση επιστρέφει έναν πίνακα με μία μόνο εγγραφή και στήλη τύπου `long`. Η τιμή του κελιού μόνο είναι ο αριθμός των εγγραφών στο *T*. 

**Παράδειγμα**

```AIQL
requests | count
```

### <a name="evaluate-operator"></a>αξιολόγηση τελεστή

`evaluate`είναι ένας μηχανισμός επέκταση που επιτρέπει την εξειδικευμένες αλγόριθμους που θα προσαρτηθούν στα ερωτήματα.

`evaluate`πρέπει να είναι η τελευταία τελεστή στη διοχέτευση ερωτήματος (με εξαίρεση τυχόν `render`). Δεν πρέπει να εμφανίζεται στο σώμα μιας συνάρτησης.

[αξιολόγηση autocluster](#evaluate-autocluster) | [αξιολόγηση καλάθι](#evaluate-basket) | [αξιολόγηση diffpatterns](#evaluate-diffpatterns) | [αξιολόγηση extractcolumns](#evaluate-extractcolumns)

#### <a name="evaluate-autocluster"></a>αξιολόγηση autocluster

     T | evaluate autocluster()

AutoCluster εντοπίζει κοινά μοτίβα διακριτό χαρακτηριστικών (διαστάσεις) στα δεδομένα και θα μείωση των αποτελεσμάτων του αρχικού ερωτήματος (εάν είναι 100 ή 100 γραμμές k) σε ένα μικρό αριθμό των μοτίβα. AutoCluster αναπτύχθηκε για να σας βοηθήσει να αναλύσετε αποτυχίες (π.χ., εξαιρέσεις, παρουσιάζει σφάλμα) αλλά πιθανώς να εργαστείτε σε οποιαδήποτε φιλτραρισμένου συνόλου δεδομένων. 

**Σύνταξη**

    T | evaluate autocluster( arguments )

**Επιστρέφει**

AutoCluster επιστρέφει ένα σύνολο (συνήθως μικρά) μοτίβων που καταγραφή τμήματα των δεδομένων με το κοινόχρηστο κοινές τιμές σε πολλές διακριτές χαρακτηριστικά. Κάθε μοτίβο αντιπροσωπεύεται από μια γραμμή στα αποτελέσματα. 

Οι πρώτες δύο στήλες είναι το πλήθος και το ποσοστό των γραμμών εκτός του αρχικού ερωτήματος που καταγράφονται από το μοτίβο. Οι υπόλοιπες στήλες που προέρχονται από το αρχικό ερώτημα και τους τιμή είναι μια συγκεκριμένη τιμή από τη στήλη ή ' *' δηλαδή τιμές μεταβλητών. 

Σημειώστε ότι δεν είναι ασυνεχή τα μοτίβα: αυτοί ενδέχεται να επικάλυψη και συνήθως δεν καλύπτουν όλες τις αρχικές γραμμές. Μερικές γραμμές δεν μπορεί να περιλαμβάνονται στην οποιαδήποτε μοτίβο.

**Συμβουλές**

* Χρήση `where` και `project` στο σωλήνα εισόδου για να μειώσετε τα δεδομένα για να ακριβώς τι που σας ενδιαφέρει.
* Όταν βρείτε μια γραμμή ενδιαφέρον, ίσως θέλετε να διερευνήσουν περαιτέρω, προσθέτοντας τις τιμές που θα σας `where` φίλτρο.

**Ορίσματα (όλα προαιρετικά)**

* `output=all | values | minimal` 

    Η μορφή για τα αποτελέσματα. Οι στήλες Count και τοις εκατό εμφανίζονται πάντα στα αποτελέσματα. 

 * `all`-όλες τις στήλες από την είσοδο είναι εξόδου
 * `values`-φιλτράρει στήλες με μόνο ' *' στα αποτελέσματα
 * `minimal`-επίσης φιλτράρει στήλες, οι οποίες είναι ίδιες για όλες τις γραμμές του αρχικού ερωτήματος. 


* `min_percent=`*διπλά* (προεπιλεγμένο: 1)

    Το ελάχιστο ποσοστό κάλυψη των γραμμών που δημιουργήθηκε.

    Παράδειγμα:`T | evaluate autocluster("min_percent=5.5")`


* `num_seeds=`*int* (προεπιλεγμένο: 25) 

    Ο αριθμός των σπόρων καθορίζει τον αριθμό των σημείων αρχικό τοπικής αναζήτησης του αλγόριθμου. Σε ορισμένες περιπτώσεις, ανάλογα με τη δομή των δεδομένων, αλλά αύξηση του αριθμού των σπόρων αυξάνει τον αριθμό (ή ποιότητα) των αποτελεσμάτων μέσω χώρος αυξημένη αναζήτησης στην πιο αργά ανταλλαγή ερωτήματος. Το όρισμα num_seeds έχει μείωση των αποτελεσμάτων και στις δύο κατευθύνσεις, ώστε να μειώνοντας το κάτω από 5 θα επιτύχετε βελτιώσεις απόδοσης ελάχιστος και αύξηση πάνω από 50 σπάνια θα δημιουργήσει επιπλέον μοτίβα.

    Παράδειγμα:`T | evaluate autocluster("num_seeds=50")`


* `size_weight=`*0 < διπλά < 1*+ (προεπιλογή: 0,5)

    Παρέχει ορισμένα έλεγχο το υπόλοιπο μεταξύ γενική (υψηλή κάλυψης) και ενημερωτικό (πολλά κοινόχρηστο τιμές). Αύξηση size_weight συνήθως μειώνει τον αριθμό των μοτίβων και κάθε μοτίβο έχει την τάση να καλύψετε ένα μεγαλύτερο ποσοστό. Μείωση size_weight συνήθως παράγει πιο συγκεκριμένες μοτίβα με πιο κοινόχρηστες τιμές και μικρότερο ποσοστό κάλυψης. Η εμφάνιση σύνθετων ρυθμίσεων τύπος είναι μια σταθμισμένη γεωμετρικό μέσο μεταξύ της κανονικοποιημένης γενική βαθμολογία και ενημερωτικό βαθμολογία με size_weight και 1-size_weight ως τα βάρη. 

    Παράδειγμα:`T | evaluate autocluster("size_weight=0.8")`


* `weight_column=`*column_name*

    Θεωρεί ότι κάθε γραμμή σε την είσοδο σύμφωνα με το καθορισμένο βάρος (από προεπιλογή κάθε γραμμή έχει ένα πάχος του "1"), κοινή χρήση της στήλης πάχος είναι να λαμβάνουν δειγματοληψία λογαριασμό ή bucketing/συνάθροιση των δεδομένων που είναι ήδη ενσωματωμένο σε κάθε γραμμή.

    Παράδειγμα:`T | evaluate autocluster("weight_column=sample_Count")` 



#### <a name="evaluate-basket"></a>αξιολόγηση καλάθι

     T | evaluate basket()

Καλάθι εντοπίζει όλα τα μοτίβα συχνές διακριτό χαρακτηριστικών (διαστάσεις) στα δεδομένα και θα επιστρέψει όλα τα μοτίβα συχνές που διαβιβάζεται το όριο συχνότητα του αρχικού ερωτήματος. Καλάθι εγγυάται για να βρείτε όλα τα μοτίβα συχνές των δεδομένων αλλά δεν εγγυάται να έχουν πολυωνυμική χρόνου εκτέλεσης. Το χρόνο εκτέλεσης του ερωτήματος είναι γραμμική τον αριθμό των γραμμών, αλλά σε ορισμένες περιπτώσεις μπορεί να είναι εκθετική τον αριθμό των στηλών (διαστάσεις). Καλάθι βασίζεται στον αλγόριθμο Apriori που αναπτύχθηκαν αρχικά για καλάθι εξόρυξης δεδομένων ανάλυσης. 

**Επιστρέφει**

Όλα τα μοτίβα που εμφανίζονται σε περισσότερα από ένα καθορισμένο κλάσμα (προεπιλογή 0.05) τα συμβάντα.

**Ορίσματα (όλα προαιρετικά)**


* `threshold=`*0.015 < διπλά < 1* (προεπιλεγμένο: 0.05) 

    Ορίζει το ελάχιστο λόγο από τις γραμμές που θεωρούνται συχνές (μοτίβα με μικρότερο μέγεθος αναλογία δεν θα επιστραφούν).

    Παράδειγμα:`T | evaluate basket("threshold=0.02")`


* `weight_column=`*column_name*

    Θεωρεί ότι κάθε γραμμή σε την είσοδο σύμφωνα με το καθορισμένο βάρος (από προεπιλογή κάθε γραμμή έχει ένα πάχος του "1"), κοινή χρήση της στήλης πάχος είναι να λαμβάνουν δειγματοληψία λογαριασμό ή bucketing/συνάθροιση των δεδομένων που είναι ήδη ενσωματωμένο σε κάθε γραμμή.

    Παράδειγμα: T | αξιολόγηση basket("weight_column=sample_Count")


* `max_dims=`*1 < int* (προεπιλεγμένο: 5)

    Ορίζει τη μέγιστη αριθμό των μη συσχετισμένο διαστάσεις ανά καλάθι, περιορισμένη από προεπιλογή για να μειώσετε το χρόνο εκτέλεσης του ερωτήματος.


* `output=minimize` | `all` 

    Η μορφή για τα αποτελέσματα. Οι στήλες Count και τοις εκατό εμφανίζονται πάντα στα αποτελέσματα.

 * `minimize`-φιλτράρει στήλες με μόνο ' *' στα αποτελέσματα.
 * `all`-όλες τις στήλες από την είσοδο είναι εξόδου.




#### <a name="evaluate-diffpatterns"></a>αξιολόγηση diffpatterns

     requests | evaluate diffpatterns("split=success")

Diffpatterns συγκρίνει δύο συνόλων δεδομένων από την ίδια δομή και βρίσκει μοτίβα διακριτό χαρακτηριστικών (διαστάσεις) που χαρακτηρίζουν διαφορές μεταξύ των δύο συνόλων δεδομένων. Diffpatterns αναπτύχθηκε για να σας βοηθήσει να αναλύσετε αποτυχίες (π.χ., σύγκρισης αποτυχιών σε μη αποτυχίες σε ένα συγκεκριμένο χρονικό διάστημα), αλλά πιθανώς να βρείτε διαφορές μεταξύ της οποιαδήποτε δύο συνόλων δεδομένων από την ίδια δομή. 

**Σύνταξη**

`T | evaluate diffpatterns("split=`*BinaryColumn*`" [, arguments] )`

**Επιστρέφει**

Diffpatterns επιστρέφει ένα σύνολο (συνήθως μικρά) μοτίβων που καταγραφή διαφορετικά τμήματα των δεδομένων σε δύο σύνολα το (δηλαδή ένα μοτίβο καταγραφή ένα μεγάλο ποσοστό των γραμμών του πρώτου συνόλου δεδομένων και χαμηλό ποσοστό των γραμμών στο δεύτερο σύνολο). Κάθε μοτίβο αντιπροσωπεύεται από μια γραμμή στα αποτελέσματα.

Οι πρώτες τέσσερις στήλες είναι το πλήθος και το ποσοστό των γραμμών εκτός του αρχικού ερωτήματος που καταγράφονται από το μοτίβο σε κάθε σύνολο, πέμπτη στήλη είναι η διαφορά (σε στιγμές απόλυτη ποσοστό) μεταξύ των δύο συνόλων. Οι υπόλοιπες στήλες που προέρχονται από το αρχικό ερώτημα και τους τιμή είναι μια συγκεκριμένη τιμή από τη στήλη ή * δηλαδή τιμές μεταβλητών. 

Σημειώστε ότι δεν έχουν distinct τα μοτίβα: αυτοί ενδέχεται να επικάλυψη και συνήθως δεν καλύπτουν όλες τις αρχικές γραμμές. Μερικές γραμμές δεν μπορεί να περιλαμβάνονται στην οποιαδήποτε μοτίβο.

**Συμβουλές**

* Χρησιμοποιήστε το πού και του project στο σωλήνα εισόδου για να μειώσετε τα δεδομένα για να ακριβώς τι που σας ενδιαφέρει.

* Όταν βρείτε μια γραμμή ενδιαφέρον, που μπορεί να θέλετε να διερευνήσουν περαιτέρω, προσθέτοντας τις συγκεκριμένες τιμές για το φιλτράρισμα θέση σας.

**Ορίσματα**

* `split=`*όνομα στήλης* (απαιτείται)

    Η στήλη πρέπει να έχει ακριβώς δύο τιμές. Εάν είναι απαραίτητο, δημιουργήστε μια τέτοια στήλη:

    `requests | extend fault = toint(resultCode) >= 500` <br/>
    `| evaluate diffpatterns("split=fault")`

* `target=`*συμβολοσειρά*

    Ενημερώνει αλγόριθμο για να αναζητήσετε μόνο μοτίβα που έχουν μεγαλύτερο ποσοστό του συνόλου δεδομένων προορισμού, ο προορισμός πρέπει να είναι μία από τις δύο τιμές της στήλης διαίρεση.

    `requests | evaluate diffpatterns("split=success", "target=false")`

* `threshold=`*0.015 < διπλά < 1* (προεπιλεγμένο: 0.05) 

    Ορίζει τη διαφορά ελάχιστους μοτίβο (αναλογία) μεταξύ των δύο συνόλων.

    `requests | evaluate diffpatterns("split=success", "threshold=0.04")`

* `output=minimize | all`

    Η μορφή για τα αποτελέσματα. Οι στήλες Count και τοις εκατό εμφανίζονται πάντα στα αποτελέσματα. 

 * `minimize`-φιλτράρει στήλες με μόνο ' *' στα αποτελέσματα
 * `all`-όλες τις στήλες από την είσοδο είναι εξόδου

* `weight_column=`*column_name*

    Θεωρεί ότι κάθε γραμμή σε την είσοδο σύμφωνα με το καθορισμένο βάρος (από προεπιλογή κάθε γραμμή έχει ένα πάχος του "1"). Κοινή χρήση μιας στήλης πάχος είναι να λαμβάνουν δειγματοληψία λογαριασμό ή bucketing/συνάθροιση των δεδομένων που είναι ήδη ενσωματωμένο σε κάθε γραμμή.

    `requests | evaluate autocluster("weight_column=itemCount")`






#### <a name="evaluate-extractcolumns"></a>αξιολόγηση extractcolumns

     exceptions | take 1000 | evaluate extractcolumns("details=json") 

Extractcolumns χρησιμοποιείται για να εμπλουτίσετε έναν πίνακα με πολλές στήλες απλό που είναι δυναμικά που έχουν εξαχθεί από (ημιδιαφανές) δομημένες στήλες με βάση τον τύπο τους. Προς το παρόν υποστηρίζει μόνο, στήλες json δύο δυναμικής και συμβολοσειράς σειριοποίηση jsons.


* `max_columns=`*int* (προεπιλεγμένο: 10) 

    Ο αριθμός των νέων στηλών προστέθηκαν είναι δυναμική και μπορεί να είναι πολύ μεγάλο (στην πραγματικότητα είναι ο αριθμός των διακριτές κλειδιά σε όλες τις εγγραφές json), ώστε να σας πρέπει να περιορίσετε τη χρήση του. Τις νέες στήλες είναι ταξινομημένες σε φθίνουσα σειρά με βάση τους συχνότητα και έως max_columns προστίθενται στον πίνακα.

    `T | evaluate extractcolumns("json_column_name=json", "max_columns=30")`


* `min_percent=`*διπλά* (προεπιλεγμένο: 10.0) 

    Ένας άλλος τρόπος για να περιορίσετε τις νέες στήλες, παραβλέποντας στήλες των οποίων συχνότητα είναι χαμηλότερη από min_percent.

    `T | evaluate extractcolumns("json_column_name=json", "min_percent=60")`


* `add_prefix=`*bool* (προεπιλεγμένο: true) 

    Εάν είναι αληθές το όνομα της στήλης σύνθετη θα προστεθεί ως πρόθεμα στα ονόματα των στηλών που έχουν εξαχθεί.


* `prefix_delimiter=`*συμβολοσειρά* (προεπιλεγμένο: "_") 

    Εάν add_prefix = true η παράμετρος αυτή καθορίζει το διαχωριστικό που θα χρησιμοποιηθεί για τη συνένωση τα ονόματα των τις νέες στήλες.

    `T | evaluate extractcolumns("json_column_name=json",` <br/>
    `"add_prefix=true", "prefix_delimiter=@")`


* `keep_original=`*bool* (προεπιλεγμένο: false) 

    Εάν είναι αληθές τις αρχικές στήλες (json) θα διατηρηθούν στον πίνακα εξόδου.


* `output=query | table` 

    Η μορφή για τα αποτελέσματα. 

 * `table`-Το αποτέλεσμα είναι στον ίδιο πίνακα, όπως έχει ληφθεί μείον το καθορισμένες στήλες εισόδου συν νέες στήλες που έχουν εξαχθεί από τις στήλες εισόδου.
 * `query`-Το αποτέλεσμα είναι μια συμβολοσειρά που αντιπροσωπεύει το ερώτημα που μπορείτε να κάνετε για να πετύχετε το αποτέλεσμα ως πίνακα. 




### <a name="extend-operator"></a>επέκταση τελεστή

     T | extend duration = stopTime - startTime

Προσάρτηση μία ή περισσότερες στήλες υπολογισμού σε έναν πίνακα. 


**Σύνταξη**

    T | extend ColumnName = Expression [, ...]

**Ορίσματα**

* *T:* Ο πίνακας εισαγωγής.
* *ColumnName:* Το όνομα ενός στηλών για να προσθέσετε. [Ονόματα](#names) διάκριση πεζών-κεφαλαίων και μπορεί να περιέχει αλφαβητική σειρά, αριθμών ή '_' χαρακτήρες. Χρήση `['...']` ή `["..."]` να προσφοράς ονόματα με άλλους χαρακτήρες ή τις λέξεις-κλειδιά.
* *Παράσταση:* Τον υπολογισμό των υπάρχοντα στηλών.

**Επιστρέφει**

Ένα αντίγραφο της εισαγωγής πίνακα, με πρόσθετες καθορισμένες στήλες.

**Συμβουλές**

* Χρήση [`project`](#project-operator) αντί για αυτό, εάν θέλετε επίσης να αποθέσετε ή μετονομασία ορισμένες στήλες.
* Μην χρησιμοποιείτε `extend` απλώς για να λάβετε ένα μικρότερο όνομα για να χρησιμοποιήσετε σε μια μεγάλη παράσταση. `...| extend x = anonymous_user_id_from_client | ... func(x) ...` 

    Τα εγγενή στήλες του πίνακα έχουν καταχωρηθεί στο ευρετήριο; το νέο όνομα Καθορίζει μια επιπλέον στήλη που δεν έχει ευρετήριο, ώστε το ερώτημα είναι πιθανό να εκτελεστεί πιο αργά.

**Παράδειγμα**

```AIQL
traces
| extend
    Age = now() - timestamp
```


### <a name="join-operator"></a>Τελεστής συνδέσμου

    Table1 | join (Table2) on CommonColumn

Συγχωνεύει τις γραμμές από δύο πίνακες με τιμές που ταιριάζουν της καθορισμένης στήλης.


**Σύνταξη**

    Table1 | join [kind=Kind] (Table2) on CommonColumn [, ...]

**Ορίσματα**

* *Πίνακας1* - το 'αριστερή πλευρά' του συνδέσμου.
* *Πίνακας2* - 'δεξιά πλευρά' του συνδέσμου. Μπορεί να είναι μια παράσταση ένθετο ερώτημα που παράγει έναν πίνακα.
* *CommonColumn* - μια στήλη που έχει το ίδιο όνομα στους δύο πίνακες.
* *Είδος* - καθορίζει τον τρόπο γραμμές από τους δύο πίνακες πρέπει να συμφωνεί.

**Επιστρέφει**

Ένας πίνακας με:

* Μια στήλη για κάθε στήλη σε κάθε έναν από τους δύο πίνακες, όπως τα πλήκτρα με τα αντίστοιχα. Τις στήλες στη δεξιά πλευρά θα αυτόματα μετονομαστεί εάν υπάρχουν υπάρχει διένεξη ονόματος.
* Μια γραμμή για κάθε συμφωνία μεταξύ των πινάκων εισαγωγής. Συμφωνία είναι μια γραμμή επιλεγμένο από έναν πίνακα που έχει την ίδια τιμή για όλα τα `on` πεδία ως μια γραμμή στον άλλο πίνακα. 

* `Kind`δεν έχει καθοριστεί

    Μόνο μία γραμμή από την αριστερή πλευρά είναι αντιστοιχισμένος για κάθε τιμή του `on` κλειδί. Το αποτέλεσμα περιέχει μια γραμμή για κάθε αντιστοιχία αυτής της γραμμής με τις γραμμές από τα δεξιά.

* `Kind=inner`
 
     Υπάρχει μια γραμμή στο αποτέλεσμα για κάθε συνδυασμό των γραμμών που συμφωνούν από αριστερά και δεξιά.

* `kind=leftouter`(or `kind=rightouter` or `kind=fullouter`)

     Εκτός από την εσωτερική συμφωνίες, υπάρχει μια γραμμή για κάθε γραμμή σε αριστερά (ή/και δεξιά), ακόμα και αν δεν έχει καμία αντιστοιχία. Σε αυτή την περίπτωση, τα κελιά αταίριαστων εξόδου περιέχουν τιμές null.

* `kind=leftanti`

     Επιστρέφει όλες τις εγγραφές από την αριστερή πλευρά που δεν έχουν αντιστοιχίσεις από τα δεξιά. Ο πίνακας αποτελεσμάτων περιλαμβάνει μόνο τις στήλες από την αριστερή πλευρά. 
 
Εάν υπάρχουν πολλές γραμμές με τις ίδιες τιμές για αυτά τα πεδία, θα λάβετε γραμμές για όλους τους συνδυασμούς.

**Συμβουλές**

Για καλύτερες επιδόσεις:

* Χρήση `where` και `project` για να μειώσετε τους αριθμούς γραμμών και στηλών σε πίνακες εισόδου, πριν από την `join`. 
* Εάν ένας πίνακας είναι πάντα μικρότερη από την άλλη, χρησιμοποιήστε το ως (εκτροπή) αριστερή πλευρά της συνένωσης.
* Οι στήλες για την αντιστοίχιση συνδέσμου πρέπει να έχουν το ίδιο όνομα. Χρησιμοποιήστε τον τελεστή έργου, εάν είναι απαραίτητο για να μετονομάσετε μια στήλη σε έναν από τους πίνακες.

**Παράδειγμα**

Λήψη εκτεταμένες δραστηριότητες από ένα αρχείο καταγραφής σε ποια ορισμένες σήμανση καταχωρήσεων στην αρχή και στο τέλος μιας δραστηριότητας. 

```AIQL
    let Events = MyLogTable | where type=="Event" ;
    Events
  	| where Name == "Start"
  	| project Name, City, ActivityId, StartTime=timestamp
  	| join (Events
           | where Name == "Stop"
           | project StopTime=timestamp, ActivityId)
        on ActivityId
  	| project City, ActivityId, StartTime, StopTime, Duration, StopTime, StartTime

```


### <a name="limit-operator"></a>Τελεστής όριο

     T | limit 5

Επιστρέφει μέχρι τον καθορισμένο αριθμό των γραμμών από τον πίνακα εισαγωγής. Δεν υπάρχει εγγυημένη επιστρέφονται ποιες εγγραφές. (Για να επιστρέψετε συγκεκριμένες εγγραφές, χρησιμοποιήστε [`top`](#top-operator).)

**Ψευδώνυμο**`take`

**Σύνταξη**

    T | limit NumberOfRows


**Συμβουλές**

`Take`είναι μια απλή και αποτελεσματικός τρόπος για να δείτε ένα δείγμα των αποτελεσμάτων σας όταν εργάζεστε με αλληλεπίδραση. Έχετε υπόψη ότι αυτή δεν εγγυάται για να δημιουργήσουν συγκεκριμένες γραμμές ή για την παραγωγή τους με κάποια συγκεκριμένη σειρά.

Υπάρχει ένα μη ρητή όριο στον αριθμό των γραμμών που επιστρέφονται στο πρόγραμμα-πελάτη, ακόμα και εάν δεν χρησιμοποιείτε το `take`. Για να σηκώστε αυτό το όριο, χρησιμοποιήστε το `notruncation` επιλογή αίτησης προγράμματος-πελάτη.



### <a name="mvexpand-operator"></a>Τελεστής mvexpand

    T | mvexpand listColumn 

Επεκτείνει μια λίστα από ένα κελί (JSON) πληκτρολογήσατε δυναμικής ώστε κάθε καταχώρηση έχει μια ξεχωριστή γραμμή. Όλα τα κελιά σε μια αναπτυγμένη γραμμή θα δημιουργηθεί διπλότυπη επαφή. 

(Δείτε επίσης: [`summarize makelist`](#summarize-operator) που εκτελεί την αντίθετη λειτουργία.)

**Παράδειγμα**

Ας υποθέσουμε ότι ο πίνακας εισαγωγής είναι:

|A:INT|B:String|D:Dynamic|
|---|---|---|
|1|"hello"|{"αριθμός-κλειδί": "τιμή"}|
|2|"διεθνείς"|[0,1, "k", "v"]|

    mvexpand D

Αποτέλεσμα είναι:

|A:INT|B:String|D:Dynamic|
|---|---|---|
|1|"hello"|{"αριθμός-κλειδί": "τιμή"}|
|2|"διεθνείς"|0|
|2|"διεθνείς"|1|
|2|"διεθνείς"|"k"|
|2|"διεθνείς"|"v"|


**Σύνταξη**

    T | mvexpand  [bagexpansion=(bag | array)] ColumnName [limit Rowlimit]

    T | mvexpand  [bagexpansion=(bag | array)] [Name =] ArrayExpression [to typeof(Typename)] [limit Rowlimit]

**Ορίσματα**

* *ColumnName:* Στο αποτέλεσμα, πίνακες στην καθορισμένη στήλη έχουν αναπτυχθεί σε πολλές γραμμές. 
* *ArrayExpression:* Μια παράσταση δώσουν ενός πίνακα. Εάν χρησιμοποιείται αυτήν τη φόρμα, προστίθεται μια νέα στήλη και διατηρείται το υπάρχον.
* *Όνομα:* Ένα όνομα για τη νέα στήλη.
* *Typename:* Μετατρέπει ρητά ανεπτυγμένο παράστασης σε έναν συγκεκριμένο τύπο
* *RowLimit:* Ο μέγιστος αριθμός των γραμμών που δημιουργούνται από κάθε γραμμή του αρχικού. Η προεπιλογή είναι 128.

**Επιστρέφει**

Πολλές γραμμές για κάθε μία από τις τιμές σε κάθε πίνακα στη στήλη με όνομα ή στην παράσταση πίνακα.

Ανεπτυγμένο στήλη έχει πάντα δυναμικής τύπο. Χρησιμοποιήστε μια απόκλιση όπως `todatetime()` ή `toint()` εάν θέλετε να υπολογίσετε ή συνάθροιση τιμών.

Υποστηρίζονται δύο καταστάσεις επεκτάσεις τσάντα ιδιότητα:

* `bagexpansion=bag`: Ομάδες ιδιοτήτων έχουν αναπτυχθεί σε ομάδες ιδιοτήτων μοναδικής καταχώρησης. Αυτή είναι η προεπιλεγμένη επέκτασης.
* `bagexpansion=array`: Ομάδες ιδιοτήτων έχουν αναπτυχθεί σε δύο στοιχείο `[` *αριθμού-κλειδιού*`,`*τιμή* `]` πίνακα δομές, επιτρέποντάς ομοιόμορφη πρόσβαση σε κλειδιά και οι τιμές (καθώς και, για παράδειγμα, εκτελεί μια συνάθροιση διακριτό πλήθος επάνω από τα ονόματα των ιδιοτήτων). 

**Παραδείγματα**


    exceptions | take 1 
  	| mvexpand details[0]

Διαιρεί μια εγγραφή εξαίρεση σε γραμμές για κάθε στοιχείο στο πεδίο λεπτομερειών.



### <a name="parse-operator"></a>Τελεστής ανάλυσης

    T | parse "I got 2 socks for my birthday when I was 63 years old" 
    with * "got" counter:long " " present "for" * "was" year:long *


    T | parse kind=relaxed
          "I got no socks for my birthday when I was 63 years old" 
    with * "got" counter:long " " present "for" * "was" year:long * 

    T |  parse kind=regex "I got socks for my 63rd birthday" 
    with "(I|She) got" present "for .*?" year:long * 

Εξάγει τιμές από μια συμβολοσειρά. Να χρησιμοποιήσετε αντιστοίχιση απλά ή κανονική παράσταση.

**Σύνταξη**

    T | parse [kind=regex|relaxed] SourceText 
        with [Match | Column [: Type [*]] ]  ...

**Ορίσματα**

* `T`: Ο πίνακας εισαγωγής.
* `kind`: 
 * `simple`(προεπιλογή): το `Match` συμβολοσειρές είναι απλή συμβολοσειρές.
 * `relaxed`: Εάν το κείμενο δεν ανάλυση ως τον τύπο της στήλης, η στήλη έχει οριστεί σε null και η ανάλυση συνεχίζει 
 * `regex`: το `Match` κανονικές εκφράσεις είναι συμβολοσειρές.
* `Text`: Μια στήλη ή άλλες παράσταση που αξιολογείται σε ή μπορεί να μετατραπεί σε μια συμβολοσειρά.
* *Αντιστοιχία:* Ταιριάζει με το επόμενο τμήμα της συμβολοσειράς και να απορρίψετε την.
* *Στήλης:* Εκχωρήστε το επόμενο τμήμα της συμβολοσειράς σε αυτήν τη στήλη. Εάν δεν υπάρχει, δημιουργείται τη στήλη.
* *Τύπος:* Ανάλυση στο επόμενο τμήμα της συμβολοσειράς ως καθορισμένου τύπου, όπως int, ημερομηνία, διπλή. 


**Επιστρέφει**

Ο πίνακας εισαγωγής, εκτεταμένης σύμφωνα με τη λίστα των στηλών.

Τα στοιχεία του `with` όρος αντιστοιχίζονται σε σχέση με το κείμενο προέλευσης με τη σειρά. Κάθε στοιχείο chews απενεργοποίηση ενός μπλοκ κειμένου προέλευσης: 

* Μια συμβολοσειρά κειμένου ή κανονική παράσταση μετακινεί το δρομέα που ταιριάζει με τη διάρκεια της αντιστοίχισης.
* Σε μια ανάλυση regex, μια κανονική παράσταση μπορεί να χρησιμοποιεί τον τελεστή Ελαχιστοποίηση '; ' για να μετακινήσετε το παρακάτω Ταίριασμα όσο το δυνατόν πιο σύντομα.
* Ένα όνομα στήλης με έναν τύπο αναλύει το κείμενο ως καθορισμένο τύπο. Εκτός εάν είδος = χαλαρή, μια επιτυχής ανάλυσης ακυρώνει αντιστοίχιση ολόκληρου του μοτίβου.
* Ένα όνομα στήλης χωρίς έναν τύπο, ή με τον τύπο 'συμβολοσειράς', αντιγράφει τον ελάχιστο αριθμό χαρακτήρων για να μεταβείτε σε το παρακάτω match.
* ' *' Παραλείπει τον ελάχιστο αριθμό χαρακτήρων για να μεταβείτε σε το παρακάτω match. Μπορείτε να χρησιμοποιήσετε '*' στην αρχή και στο τέλος του μοτίβου, ή μετά από έναν τύπο, εκτός από τη συμβολοσειρά ή μεταξύ των συμφωνίες συμβολοσειρά.

Όλα τα στοιχεία σε ένα μοτίβο ανάλυσης πρέπει να συμφωνεί με σωστά. Διαφορετικά, θα παραχθεί κανένα αποτέλεσμα. Η εξαίρεση σε αυτόν τον κανόνα που είναι, όταν είδος = συνεχίζει χαλαρή, εάν αποτύχει η ανάλυση μια μεταβλητή που πληκτρολογήσατε, το υπόλοιπο του ανάλυσης.

**Παραδείγματα**

*Απλή:*

```AIQL

// Test without reading a table:
 range x from 1 to 1 step 1 
 | parse "I got 2 socks for my birthday when I was 63 years old" 
    with 
     *   // skip until next match
     "got" 
     counter: long // read a number
     " " // separate fields
     present // copy string up to next match
     "for" 
     *  // skip until next match
     "was" 
     year:long // parse number
     *  // skip rest of string
```

x | Μετρητής | παρουσίαση | Έτος
---|---|---|---
1 | 2 | SOCKS | 63

*Υπάρξουν:*

Όταν τα δεδομένα εισόδου περιέχει σωστή συμφωνία για κάθε στήλη που πληκτρολογήσατε, μια χαλαρή ανάλυσης παράγει τα ίδια αποτελέσματα με μια απλή ανάλυσης. Αλλά εάν μία από τις στήλες που πληκτρολογήσατε δεν ανάλυση σωστά, μια χαλαρή ανάλυσης συνεχίζει να επεξεργάζεται το υπόλοιπο του μοτίβου, ενώ μια απλή ανάλυσης σταματήσει και δεν για τη δημιουργία οποιαδήποτε αποτελέσματος.


```AIQL

// Test without reading a table:
 range x from 1 to 1 step 1 
 | parse kind="relaxed"
        "I got several socks for my birthday when I was 63 years old" 
    with 
     *   // skip until next match
     "got" 
     counter: long // read a number
     " " // separate fields
     present // copy string up to next match
     "for" 
     *  // skip until next match
     "was" 
     year:long // parse number
     *  // skip rest of string
```


x  | παρουσίαση | Έτος
---|---|---
1 |  SOCKS | 63


*Regex:*

```AIQL

// Run a test without reading a table:
range x from 1 to 1 step 1 
// Test string:
| extend s = "Event: NotifySliceRelease (resourceName=Scheduler, totalSlices=27, sliceNumber=16, lockTime=02/17/2016 08:41, releaseTime=02/17/2016 08:41:00, previousLockTime=02/17/2016 08:40:00)" 
// Parse it:
| parse kind=regex s 
  with ".*?[a-zA-Z]*=" resource 
       ", total.*?sliceNumber=" slice:long *
       "lockTime=" lock
       ",.*?releaseTime=" release 
       ",.*?previousLockTime=" previous:date 
       ".*\\)"
| project-away x, s
```

πόρων | φέτα | Κλείδωμα | τελική έκδοση | προηγούμενη
---|---|---|---|---
Χρονοδιάγραμμα | 16 | 02/17/2016 08:41:00 | 02/17/2016 08:41 | 2016-02-17T08:40:00Z

### <a name="project-operator"></a>Τελεστής έργου

    T | project cost=price*quantity, price

Επιλέξτε τις στήλες για να συμπεριλάβετε, μετονομασία ή απόρριψη και εισαγάγετε νέο υπολογιζόμενες στήλες. Η σειρά των στηλών στο αποτέλεσμα καθορίζεται από τη σειρά τα ορίσματα. Μόνο οι στήλες που καθορίζονται στα ορίσματα περιλαμβάνονται στο αποτέλεσμα: τα υπόλοιπα αρχεία στην είσοδο χάνονται.  (Δείτε επίσης: `extend`.)


**Σύνταξη**

    T | project ColumnName [= Expression] [, ...]

**Ορίσματα**

* *T:* Ο πίνακας εισαγωγής.
* *ColumnName:* Το όνομα της στήλης για να εμφανίζονται στο αποτέλεσμα. Εάν δεν υπάρχει καμία *παράσταση*, μια στήλη με αυτό το όνομα πρέπει να εμφανίζονται με την είσοδο. [Ονόματα](#names) διάκριση πεζών-κεφαλαίων και μπορεί να περιέχει αλφαβητική σειρά, αριθμών ή '_' χαρακτήρες. Χρήση `['...']` ή `["..."]` να προσφοράς ονόματα με άλλους χαρακτήρες ή τις λέξεις-κλειδιά.
* *Παράσταση:* Προαιρετικό ανυσματική παράσταση αναφορά εισαγωγής στηλών. 

    Είναι νομικά για να λάβετε μια νέα υπολογιζόμενη στήλη με το ίδιο όνομα με μια υπάρχουσα στήλη την είσοδο.

**Επιστρέφει**

Έναν πίνακα που έχει τις στήλες που ονομάζεται ως ορίσματα και ως πολλές γραμμές, όταν ο πίνακας εισαγωγής.

**Παράδειγμα**

Το παρακάτω παράδειγμα εμφανίζει διάφορα είδη χειρισμούς που μπορεί να γίνει χρησιμοποιώντας το `project` τελεστή. Ο πίνακας εισαγωγής `T` έχει τρεις στήλες τύπου `int`: `A`, `B`, και `C`. 

```AIQL
T
| project
    X=C,               // Rename column C to X
    A=2*B,             // Calculate a new column A from the old B
    C=strcat("-",tostring(C)), // Calculate a new column C from the old C
    B=2*B,              // Calculate a new column B from the old B
    ['where'] = client_City // rename, using a keyword as a column name
```

### <a name="project-away-operator"></a>Τελεστής έργου-δεν βρίσκομαι στον υπολογιστή

    T | project-away column1, column2, ...

Εξαίρεση καθορισμένες στήλες. Το αποτέλεσμα περιέχει όλες τις στήλες εισόδου εκτός από αυτά που μπορείτε να ονομάσετε.

### <a name="range-operator"></a>Τελεστής περιοχής

    range LastWeek from ago(7d) to now() step 1d

Δημιουργεί έναν πίνακα μίας στήλης τιμών. Παρατηρήστε ότι δεν έχει μια διαδικασία εισαγωγής. 

|LastWeek|
|---|
|09:10:04.627 2015-12-05|
|09:10:04.627 2015-12-06|
|...|
|09:10:04.627 2015-12-12|



**Σύνταξη**

    range ColumnName from Start to Stop step Step

**Ορίσματα**

* *ColumnName:* Το όνομα του τη μία στήλη στον πίνακα εξόδου.
* *Έναρξη:* Τη μικρότερη τιμή στο αποτέλεσμα.
* *Διακοπή:* Η υψηλότερη τιμή δημιουργείται στο το αποτέλεσμα (ή σε ένα όριο για την υψηλότερη τιμή, εάν *βήμα* βήματα πάνω από αυτή την τιμή).
* *Βήμα:* Η διαφορά μεταξύ των δύο διαδοχικές τιμές. 

Τα ορίσματα πρέπει να είναι τιμές αριθμών, ημερομηνίας ή χρονικό διάστημα. Όπου δεν είναι δυνατό να αναφέρονται οι στήλες του κάθε πίνακα. (Εάν θέλετε να υπολογίσετε την περιοχή που βασίζεται σε έναν πίνακα του εισαγωγής, χρησιμοποιήστε την [περιοχή *συνάρτηση*](#range), ίσως με τον [τελεστή mvexpand](#mvexpand-operator).) 

**Επιστρέφει**

Ένας πίνακας με μία μόνο στήλη που ονομάζεται *ColumnName*, οι τιμές των οποίων είναι να *ξεκινήσετε*, *Έναρξη* + *βήμα*,... μέχρι και *Διακοπή*.

**Παράδειγμα**  

```AIQL
range Steps from 1 to 8 step 3
```

Έναν πίνακα με μία μόνο στήλη που ονομάζεται `Steps` του οποίου ο τύπος είναι `long` και των οποίων οι τιμές είναι `1`, `4`, και `7`.

**Παράδειγμα**

    range LastWeek from bin(ago(7d),1d) to now() step 1d

Ένας πίνακας με τα μεσάνυχτα στο τις τελευταίες επτά ημέρες. Η συνάρτηση Ανακύκλωσης (floor) μειώνει κάθε φορά στην αρχή της ημέρας.

**Παράδειγμα**  

```AIQL
range timestamp from ago(4h) to now() step 1m
| join kind=fullouter
  (traces
      | where timestamp > ago(4h)
      | summarize Count=count() by bin(timestamp, 1m)
  ) on timestamp
| project Count=iff(isnull(Count), 0, Count), timestamp
| render timechart  
```

Δείχνει πώς το `range` τελεστής μπορεί να χρησιμοποιηθεί για να δημιουργήσετε ένα μικρό, ad-hoc, διάσταση πίνακα το οποίο χρησιμοποιείται για να εισάγουν μηδενικά όπου τα δεδομένα προέλευσης δεν έχει τιμές.

### <a name="reduce-operator"></a>μείωση τελεστή

    exceptions | reduce by outerMessage

Προσπαθεί να ομαδοποιήσετε παρόμοιες καρτέλες. Για κάθε ομάδα, τον τελεστή εξάγει τα `Pattern` θεωρεί ότι περιγράφει καλύτερα αυτής της ομάδας, και το `Count` εγγραφών σε αυτήν την ομάδα.


![](./media/app-insights-analytics-reference/reduce.png)

**Σύνταξη**

    T | reduce by  ColumnName [ with threshold=Threshold ]

**Ορίσματα**

* *ColumnName:* Η στήλη για να εξετάσετε. Πρέπει να είναι τύπου συμβολοσειράς.
* *Όριο:* Μια τιμή στην περιοχή {0 έως 1}. Η προεπιλογή είναι 0.001. Για μεγάλες εισροές, πρέπει να είναι μικρές όριο. 

**Επιστρέφει**

Δύο στήλες, `Pattern` και `Count`. Σε πολλές περιπτώσεις, το μοτίβο θα είναι μια ολοκληρωμένη τιμή από τη στήλη. Σε ορισμένες περιπτώσεις, να τον προσδιορισμό κοινών όρων και αντικατάσταση των μεταβλητών τμημάτων με ' *'.

Για παράδειγμα, το αποτέλεσμα της `reduce by city` ενδέχεται να περιλαμβάνουν: 

|Μοτίβο | Καταμέτρηση |
|---|---|
| Σαν * | 5182 |
| Άγιος * | 2846 |
| Μόσχα | 3726 |
| \*-σε-\* | ούτε |
| Παρίσι | 27163 |


### <a name="render-directive"></a>απόδοση οδηγία

    T | render [ table | timechart  | barchart | piechart ]

Απόδοση κατευθύνει το επίπεδο παρουσίασης πώς μπορείτε να εμφανίσετε τον πίνακα. Θα πρέπει να το τελευταίο στοιχείο της διοχέτευσης. Πρόκειται για μια εύκολη εναλλακτική λύση χρησιμοποιώντας τα στοιχεία ελέγχου της εμφάνισης, επιτρέποντάς σας να αποθηκεύσετε ένα ερώτημα με μια συγκεκριμένη παρουσίαση μέθοδο.

### <a name="restrict-clause"></a>Περιορισμός όρος 

Καθορίζει το σύνολο των ονομάτων πινάκων διαθέσιμο για τους τελεστές που ακολουθούν. Για παράδειγμα:

    let e1 = requests | project name, client_City;
    let e2 =  requests | project name, success;
    // Exclude predefined tables from the union:
    restrict access to (e1, e2);
    union * |  take 10 

### <a name="sort-operator"></a>Τελεστής ταξινόμησης 

    T | sort by country asc, price desc

Ταξινομήστε τις γραμμές του πίνακα εισαγωγής σε σειρά κατά μία ή περισσότερες στήλες.

**Ψευδώνυμο**`order`

**Σύνταξη**

    T  | sort by Column [ asc | desc ] [ `,` ... ]

**Ορίσματα**

* *T:* Ο πίνακας εισόδου για την ταξινόμηση.
* *Στήλης:* Στήλη *T* από την οποία θέλετε να ταξινομήσετε. Ο τύπος των τιμών πρέπει να είναι αριθμητικό, η ημερομηνία, ώρα ή συμβολοσειρά.
* `asc`Ταξινόμηση κατά σε αύξουσα σειρά, χαμηλή στην υψηλή. Η προεπιλογή είναι `desc`, φθίνουσα υψηλή σε χαμηλό.

**Παράδειγμα**

```AIQL
Traces
| where ActivityId == "479671d99b7b"
| sort by Timestamp asc
```
Όλες οι γραμμές σε ανιχνεύσεις πίνακα που έχουν ένα συγκεκριμένο `ActivityId`, ταξινομημένα κατά τους χρονικής σήμανσης.

### <a name="summarize-operator"></a>Σύνοψη τελεστή

Δημιουργεί έναν πίνακα που συγκεντρώνει τα περιεχόμενα του πίνακα εισαγωγής.
 
    requests
  	| summarize count(), avg(duration), makeset(client_City) 
      by client_CountryOrRegion

Ένας πίνακας που εμφανίζει τον αριθμό, διάρκεια αίτησης average και σύνολο πόλεων σε κάθε χώρα. Υπάρχει μια γραμμή στο αποτέλεσμα για κάθε χώρα distinct. Οι στήλες εξόδου εμφανίζουν το πλήθος, μέσος όρος διάρκειας, πόλεις και χώρα. Παραβλέπονται όλες τις άλλες στήλες εισόδου.


    T | summarize count() by price_range=bin(price, 10.0)

Ένας πίνακας που εμφανίζει τον αριθμό των στοιχείων έχουν τιμές σε κάθε χρονικό διάστημα [0,10.0], [10.0,20.0], και ούτω καθεξής. Αυτό το παράδειγμα έχει μια στήλη για τη μέτρηση και μία για την περιοχή τιμών. Παραβλέπονται όλες τις άλλες στήλες εισόδου.


**Σύνταξη**

    T | summarize
         [  [ Column = ] Aggregation [ `,` ... ] ]
         [ by
            [ Column = ] GroupExpression [ `,` ... ] ]

**Ορίσματα**

* *Στήλης:* Προαιρετικό όνομα για μια στήλη αποτελεσμάτων. Η προεπιλογή είναι ένα όνομα που προέρχονται από την παράσταση. [Ονόματα](#names) διάκριση πεζών-κεφαλαίων και μπορεί να περιέχει αλφαβητική σειρά, αριθμών ή '_' χαρακτήρες. Χρήση `['...']` ή `["..."]` να προσφοράς ονόματα με άλλους χαρακτήρες ή τις λέξεις-κλειδιά.
* *Συγκέντρωσης:* Μια κλήση σε μια συνάρτηση συνάθροισης όπως `count()` ή `avg()`, με ονόματα στηλών ως ορίσματα. Ανατρέξτε στο θέμα [συναθροίσεων](#aggregations).
* *GroupExpression:* Μια παράσταση των στηλών, η οποία παρέχει ένα σύνολο διακριτές τιμές. Συνήθως είναι είτε ένα όνομα στήλης που ήδη παρέχει ένα περιορισμένο σύνολο τιμών, ή `bin()` με μια στήλη αριθμητικών ή χρονικής ως όρισμα. 

Εάν παρέχεται μια παράσταση αριθμητική ή χρόνου χωρίς τη χρήση `bin()`, ανάλυση εφαρμόζει αυτόματα το με ένα χρονικό διάστημα `1h` για τις περιπτώσεις, ή `1.0` για τους αριθμούς.

Εάν δεν μπορείτε να παράσχετε μια *GroupExpression,* ολόκληρο τον πίνακα συνοψίζονται σε μια γραμμή εξόδου.



**Επιστρέφει**

Οι γραμμές εισαγωγής τοποθετούνται σε ομάδες που έχουν τις ίδιες τιμές από την `by` παραστάσεων. Στη συνέχεια, οι συναρτήσεις συνάθροισης καθορισμένο υπολογίζονται επάνω από κάθε ομάδα, δημιουργώντας μια γραμμή για κάθε ομάδα. Το αποτέλεσμα περιέχει το `by` στήλες και επίσης τουλάχιστον μία στήλη για κάθε υπολογιστεί συγκεντρωτική τιμή. (Ορισμένες από τις συναρτήσεις συνάθροισης επιστρέφουν πολλές στήλες).

Το αποτέλεσμα έχει όσες γραμμές έχουν distinct συνδυασμούς `by` τιμές. Εάν θέλετε να συνοψίσετε πάνω από περιοχές των αριθμητικών τιμών, χρησιμοποιήστε `bin()` για να μειώσετε περιοχές διακριτές τιμές.

**Σημείωση**

Παρόλο που μπορείτε να παράσχετε αυθαίρετο παραστάσεις τόσο για τη συγκέντρωση και παραστάσεις ομαδοποίησης, είναι πιο αποδοτικό να χρησιμοποιήστε ονόματα στηλών απλό ή εφαρμόστε `bin()` σε μια στήλη αριθμητικών.



### <a name="take-operator"></a>λήψη τελεστή

Ψευδώνυμο του [ορίου](#limit-operator)


### <a name="top-operator"></a>Τελεστής επάνω

    T | top 5 by Name desc nulls first

Επιστρέφει την πρώτη εγγραφές *N* ταξινομημένες κατά καθορισμένες στήλες.


**Σύνταξη**

    T | top NumberOfRows by Sort_expression [ `asc` | `desc` ] [`nulls first`|`nulls last`] [, ... ]

**Ορίσματα**

* *NumberOfRows:* Ο αριθμός των γραμμών του *T* για να επιστρέψει.
* *Sort_expression:* Μια παράσταση με την οποία θέλετε να ταξινομήσετε τις γραμμές. Συνήθως, είναι απλώς ένα όνομα στήλης. Μπορείτε να καθορίσετε περισσότερες από μία sort_expression.
* `asc`ή `desc` (προεπιλογή) μπορεί να εμφανίζονται στο στοιχείο ελέγχου εάν είναι στην πραγματικότητα από το "κάτω" ή "επάνω" στην περιοχή επιλογής.
* `nulls first`ή `nulls last` στοιχεία ελέγχου όπου εμφανίζονται οι τιμές null. `First`είναι η προεπιλογή για `asc`, `last` είναι η προεπιλογή για `desc`.


**Συμβουλές**

`top 5 by name`είναι ισοδύναμη superficially `sort by name | take 5`. Ωστόσο, εκτελείται πιο γρήγορα και πάντα επιστρέφει ταξινομήσει τα αποτελέσματα, ενώ το `take` όπως δεν εγγυάται.

### <a name="top-nested-operator"></a>Τελεστής ένθετες επάνω

    requests 
  	| top-nested 5 of name by count()  
    , top-nested 3 of performanceBucket by count() 
    , top-nested 3 of client_CountryOrRegion by count()
  	| render barchart 

Υπολογίζονται ιεραρχική αποτελέσματα, όπου κάθε επίπεδο είναι Διερεύνηση από το προηγούμενο επίπεδο. Είναι χρήσιμο για την απάντηση σε ερωτήσεις που σας φαίνεται σαν "Τι είναι η επάνω γραμμή 5 αιτήσεις, για καθένα από αυτά, τι είναι το Κάδοι καλύτερες επιδόσεις 3 και για κάθε μία από αυτές που έχουν τις χώρες αρχή 3 τις αιτήσεις προέρχονται από;"

**Σύνταξη**

   T | αρχή ένθετες N της ΣΤΉΛΗΣ με ΣΥΝΆΘΡΟΙΣΗ [,...]

**Ορίσματα**

* N:INT - αριθμός γραμμών για να επιστρέψετε ή να περάσει στο επόμενο επίπεδο. Σε ένα ερώτημα με τρία επίπεδα όπου N είναι 5, 3 και 3, ο συνολικός αριθμός των γραμμών που θα 45.
* ΣΤΉΛΗ - μια στήλη για την ομαδοποίηση κατά για συγκέντρωση. 
* ΣΥΝΆΘΡΟΙΣΗ - μια [συνάρτηση συνάθροισης](#aggregations) για να εφαρμόσετε σε κάθε ομάδα γραμμών. Τα αποτελέσματα της αυτές τις συγκεντρώσεις θα καθορίσει τις καλύτερες ομάδες για να εμφανίζονται.


### <a name="union-operator"></a>Τελεστής συνένωσης

     Table1 | union Table2, Table3

Λαμβάνει δύο ή περισσότερους πίνακες και επιστρέφει τις γραμμές του όλες τις. 

**Σύνταξη**

    T | union [ kind= inner | outer ] [ withsource = ColumnName ] Table2 [ , ...]  

    union [ kind= inner | outer ] [ withsource = ColumnName ] Table1, Table2 [ , ...]  

**Ορίσματα**

* *Πίνακας1*, *πίνακας2* ...
 *  Το όνομα του πίνακα, όπως είναι οι `requests`, ή έναν πίνακα που ορίζεται σε ένα που [σας επιτρέπουν να όρο](#let-clause); ή
 *  Ένα ερώτημα παράσταση, όπως`(requests | where success=="True")`
 *  Ένα σύνολο πινάκων που ορίζονται με ένα χαρακτήρα μπαλαντέρ. Για παράδειγμα, `e*` θα φόρμας Ένωσης όλους τους πίνακες που ορίζονται στο προηγούμενο σας επιτρέπουν να όρους του οποίου το όνομα που ξεκίνησε με "e", μαζί με τον πίνακα 'εξαιρέσεις'.
* `kind`: 
 * `inner`-Το αποτέλεσμα έχει το υποσύνολο των στηλών που είναι κοινά και για όλους τους πίνακες εισαγωγής.
 * `outer`-Το αποτέλεσμα έχει όλες τις στήλες που προκύπτουν σε οποιαδήποτε από τα δεδομένα εισόδου. Τα κελιά που δεν έχουν οριστεί με μια γραμμή εισαγωγής έχουν οριστεί σε `null`.
* `withsource=`*ColumnName:* Εάν καθοριστεί, το αποτέλεσμα θα περιλαμβάνει μια στήλη που ονομάζεται *ColumnName* του οποίου την τιμή υποδεικνύει ποιος πίνακας προέλευσης πρόσθεσε κάθε γραμμή.

**Επιστρέφει**

Είναι ένας πίνακας με όσο το δυνατόν περισσότερες γραμμές που υπάρχουν σε όλους τους πίνακες εισαγωγής και όσο το δυνατόν περισσότερες στήλες που υπάρχουν είναι τα ονόματα στήλης μοναδικών τιμών σε τα δεδομένα εισόδου.

**Παράδειγμα**

```AIQL

let ttrr = requests | where timestamp > ago(1h);
let ttee = exceptions | where timestamp > ago(1h);
union tt* | count
```
Ένωση όλων των πινάκων των οποίων τα ονόματα ξεκινούν "tt".


**Παράδειγμα**

```AIQL

union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```
Τον αριθμό των διακριτές στους χρήστες που έχουν παραχθεί είτε ένα `exceptions` συμβάν ή μια `traces` συμβάν πάνω από την προηγούμενη ημέρα. Στο αποτέλεσμα, η στήλη 'Πίνακας ' προέλευσης θα υποδηλώνουν "Ερώτημα" ή "Εντολή".

```AIQL
exceptions
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Αυτή η έκδοση αποτελεσματική παράγει το ίδιο αποτέλεσμα. Φιλτράρει κάθε πίνακα πριν από τη δημιουργία της Ένωσης.

### <a name="where-operator"></a>όπου τελεστή

     requests | where resultCode==200

Φίλτρα πίνακα στο υποσύνολο των γραμμές που ικανοποιούν ένα κατηγόρημα.

**Ψευδώνυμο**`filter`

**Σύνταξη**

    T | where Predicate

**Ορίσματα**

* *T:* Το σε μορφή πίνακα εισόδου των οποίων οι εγγραφές πρέπει να είναι δυνατό το φιλτράρισμα.
* *Κατηγορήματος:* A `boolean` [παράσταση](#boolean) των στηλών του *T*. Αξιολογείται για κάθε γραμμή σε *T*.

**Επιστρέφει**

Γραμμές σε *T* για την οποία είναι *κατηγορήματος* `true`.

**Συμβουλές**

Για να λάβετε τις καλύτερες επιδόσεις:

* **Χρησιμοποιήστε απλή συγκρίσεις** μεταξύ των ονομάτων στηλών και σταθερές. ('Σταθεράς' σημαίνει ότι σταθερά επάνω από τον πίνακα -, ώστε να `now()` και `ago()` είναι OK και, επομένως, ανυσματική τιμές εκχωρούνται με χρήση μιας [ `let` όρος](#let-clause).)

    Για παράδειγμα, προτιμάτε `where Timestamp >= ago(1d)` να `where floor(Timestamp, 1d) == ago(1d)`.

* **Simplest όροι πρώτης**: Εάν έχετε πολλούς όρους conjoined με `and`, πρώτα τοποθέτηση τους όρους που αφορούν μόνο μία στήλη. Επομένως, `Timestamp > ago(1d) and OpId == EventId` είναι καλύτερη από το αντίστροφο.


**Παράδειγμα**

```AIQL
traces
| where Timestamp > ago(1h)
    and Source == "Kuskus"
    and ActivityId == SubActivityIt 
```

Εγγραφές που δεν είναι παλαιότερα από 1 ώρα, και προέρχονται από την προέλευση που ονομάζεται "Kuskus", και έχετε δύο στήλες με την ίδια τιμή. 

Παρατηρήστε ότι θέτει τη σύγκριση μεταξύ δύο στήλες τελευταία, καθώς δεν είναι δυνατό να χρησιμοποιούν το ευρετήριο και επιβάλει μια σάρωση.


### <a name="where-in-operator"></a>θέση του τελεστή

    requests | where resultCode !in (200, 201)

    requests | where resultCode in (403, 404)

**Σύνταξη**

    T | where col in (expr1, expr2, ...)
    T | where col !in (expr1, expr2, ...)

**Ορίσματα**

* `col`: Μια στήλη του πίνακα.
* `expr1`...: Μια λίστα από παραστάσεις ανυσματική.

Χρήση `in` χρησιμοποιείται για να συμπεριλάβετε μόνο γραμμές στις οποίες `col` είναι ίση με μία από τις παραστάσεις `expr1...`.

Χρήση `!in` για να συμπεριλάβετε μόνο γραμμές στις οποίες `col` δεν είναι ίσο με οποιαδήποτε από τις παραστάσεις `expr1...`.  


## <a name="aggregations"></a>Συναθροίσεις

Συγκεντρώσεις είναι συναρτήσεις που χρησιμοποιούνται για το συνδυασμό τιμών σε ομάδες που έχουν δημιουργηθεί με τη [Σύνοψη λειτουργία](#summarize-operator). Για παράδειγμα, σε αυτό το ερώτημα, dcount() είναι μια συνάρτηση συνάθροισης:

    requests | summarize dcount(name) by success

### <a name="any"></a>οποιαδήποτε 

    any(Expression)

Τυχαία επιλέγει μία γραμμή της ομάδας και επιστρέφει την τιμή της παράστασης.

Αυτό είναι χρήσιμο, για παράδειγμα, όταν κάποια στήλη έχει μεγάλου αριθμού παρόμοια τιμές (π.χ., μια στήλη "σφάλμα κείμενο") και θέλετε να δείγμα αυτήν τη στήλη μία φορά σε κάθε μια μοναδική τιμή του αριθμού-κλειδιού σύνθετης ομάδας. 

**Παράδειγμα**  

```

traces 
| where timestamp > now(-15min)  
| summarize count(), any(message) by operation_Name 
| top 10 by count_level desc 
```

<a name="argmin"></a>
<a name="argmax"></a>
### <a name="argmin-argmax"></a>argmin, argmax

    argmin(ExprToMinimize, * | ExprToReturn  [ , ... ] )
    argmax(ExprToMaximize, * | ExprToReturn  [ , ... ] ) 

Εντοπίζει μια γραμμή στην ομάδα που ελαχιστοποιεί/Μεγιστοποίηση *ExprToMaximize*και επιστρέφει την τιμή του *ExprToReturn* (ή `*` για να επιστρέψετε σε ολόκληρη τη γραμμή).

**Συμβουλή**: οι στήλες που εισήχθησαν μέσω έχουν μετονομαστεί αυτόματα. Για να βεβαιωθείτε ότι χρησιμοποιείτε τα σωστά ονόματα, εξετάστε τα αποτελέσματα χρησιμοποιώντας `take 5` πριν διοχέτευση τα αποτελέσματα σε ένα άλλο τελεστή.

**Παραδείγματα**

Για κάθε όνομα αίτηση, εμφάνιση κατά την αίτηση μεγαλύτερου Παρουσιάστηκε:

    requests | summarize argmax(duration, timestamp) by name

Εμφάνιση όλων των λεπτομερειών της αίτησης μεγαλύτερου, όχι μόνο τη χρονική σήμανση:

    requests | summarize argmax(duration, *) by name


Βρείτε τη χαμηλότερη τιμή κάθε μέτρησης, μαζί με τη χρονική σήμανση και άλλων δεδομένων:

    metrics 
  	| summarize minValue=argmin(value, *) 
      by name


![](./media/app-insights-analytics-reference/argmin.png)
 


### <a name="avg"></a>συνάρτηση AVG

    avg(Expression)

Υπολογίζει τον μέσο όρο των *παράσταση* κατά μήκος της ομάδας.

### <a name="buildschema"></a>buildschema

    buildschema(DynamicExpression)

Επιστρέφει το ελάχιστο σχήμα που δέχεται όλων των τιμών της *DynamicExpression*. 

Θα πρέπει να είναι ο τύπος στήλης παραμέτρου `dynamic` -μια τσάντα πίνακα ή την ιδιότητα. 

**Παράδειγμα**

    exceptions | summarize buildschema(details)

Αποτέλεσμα:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Σημειώστε ότι `indexer` χρησιμοποιείται για να επισημάνετε το σημείο όπου θα πρέπει να χρησιμοποιήσετε ένα αριθμητικό ευρετήριο. Για αυτό το σχήμα, ορισμένες έγκυρες διαδρομές θα (αν υποθέσουμε ότι αυτά τα ευρετήρια παράδειγμα βρίσκονται στην περιοχή):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)

**Παράδειγμα**

Έστω ότι η στήλη εισόδου έχει τρία δυναμικές τιμές:

| |
|---|
|`{"x":1, "y":3.5}`
|`{"x":"somevalue", "z":[1, 2, 3]}`
|`{"y":{"w":"zzz"}, "t":["aa", "bb"], "z":["foo"]}`


Το σχήμα που προκύπτει πρέπει να είναι:

    { 
      "x":["int", "string"], 
      "y":["double", {"w": "string"}], 
      "z":{"`indexer`": ["int", "string"]}, 
      "t":{"`indexer`": "string"} 
    }

Το σχήμα σας ενημερώνει μας που:

* Το αντικείμενο ρίζας είναι ένα κοντέινερ με τέσσερις ιδιότητες που ονομάζεται x, y, z και t.
* Η ιδιότητα που ονομάζεται "x" που θα μπορούσε να είναι του τύπου "int" ή του τύπου "συμβολοσειρά".
* Η ιδιότητα που ονομάζεται "ν" που θα μπορούσε είτε του τύπου "δύο" ή άλλο κοντέινερ με μια ιδιότητα που ονομάζεται "w" του τύπου "συμβολοσειρά".
* Το ``indexer`` λέξεων-κλειδιών υποδεικνύει ότι "ω" και "t" πίνακες.
* Κάθε στοιχείο στον πίνακα "ω" είναι μια int ή μιας συμβολοσειράς.
* "t" είναι ένας πίνακας συμβολοσειρών.
* Κάθε ιδιότητα είναι προαιρετική ρητά και οποιαδήποτε πίνακα μπορεί να είναι κενή.

##### <a name="schema-model"></a>Μοντέλο σχήματος

Η σύνταξη του σχήματος επιστρέφεται είναι:

    Container ::= '{' Named-type* '}';
    Named-type ::= (name | '"`indexer`"') ':' Type;
    Type ::= Primitive-type | Union-type | Container;
    Union-type ::= '[' Type* ']';
    Primitive-type ::= "int" | "string" | ...;

Είναι ισοδύναμη με ένα υποσύνολο των σχολίων τύπος γραφομηχανή, κωδικοποιηθεί ως μια δυναμική τιμή. Στη γραφομηχανή, το σχήμα παράδειγμα πρέπει να είναι:

    var someobject: 
    { 
      x?: (number | string), 
      y?: (number | { w?: string}), 
      z?: { [n:number] : (int | string)},
      t?: { [n:number]: string } 
    }


### <a name="count"></a>Καταμέτρηση

    count([ Predicate ])

Επιστρέφει μια μέτρηση γραμμών για την οποία *κατηγορήματος* αξιολογείται σε `true`. Εάν δεν υπάρχει *κατηγορήματος* έχει καθοριστεί, επιστρέφει τον συνολικό αριθμό των εγγραφών στην ομάδα. 

**Συμβουλή επιδόσεων**: χρήση `summarize count(filter)` αντί`where filter | summarize count()`

> [AZURE.NOTE] Αποφύγετε τη χρήση count() για να βρείτε τον αριθμό των αιτήσεων, εξαιρέσεις ή άλλα συμβάντα που έχουν προκύψει. Όταν [δειγματοληψία](app-insights-sampling.md) είναι σε λειτουργία, τον αριθμό των σημείων δεδομένων διατηρούνται στο ιδέες εφαρμογή θα είναι μικρότερος από τον αριθμό του αρχικού συμβάντα. Εναλλακτικά, χρησιμοποιήστε `summarize sum(itemCount)...`. Η ιδιότητα itemCount απεικονίζει τον αριθμό των αρχικό συμβάντων, που αντιπροσωπεύονται από κάθε σημείο δεδομένων διατηρούνται.

### <a name="countif"></a>COUNTIF

    countif(Predicate)

Επιστρέφει μια μέτρηση γραμμών για την οποία *κατηγορήματος* αξιολογείται σε `true`.

**Συμβουλή επιδόσεων**: χρήση `summarize countif(filter)` αντί`where filter | summarize count()`

> [AZURE.NOTE] Αποφύγετε τη χρήση countif() για να βρείτε τον αριθμό των αιτήσεων, εξαιρέσεις ή άλλα συμβάντα που έχουν προκύψει. Όταν [δειγματοληψία](app-insights-sampling.md) είναι σε λειτουργία, ο αριθμός των σημείων δεδομένων θα είναι μικρότερη από τον αριθμό των πραγματική συμβάντα. Εναλλακτικά, χρησιμοποιήστε `summarize sum(itemCount)...`. Η ιδιότητα itemCount απεικονίζει τον αριθμό των αρχικό συμβάντα που αντιπροσωπεύονται από κάθε σημείο δεδομένων διατηρούνται.

### <a name="dcount"></a>DCount

    dcount( Expression [ ,  Accuracy ])

Επιστρέφει μια εκτίμηση του αριθμού διακριτών τιμών της *παράσταση* στην ομάδα. (Για να δημιουργήσετε μια λίστα διακριτές τιμές, χρησιμοποιήστε [`makeset`](#makeset).)

*Ακρίβεια*, εάν καθοριστεί, ελέγχει το υπόλοιπο μεταξύ ταχύτητας και ακρίβειας.

 * `0`= τουλάχιστον ακριβή και πιο ασφαλής υπολογισμού.
 * `1`η προεπιλογή, η οποία υπολοίπων ακρίβεια και υπολογισμού χρόνου; πληροφορίες σχετικά με το σφάλμα 0,8%.
 * `2`= πιο ακριβή και πιο αργές Υπολογισμός; πληροφορίες σχετικά με το σφάλμα 0,4%.

**Παράδειγμα**

    pageViews 
  	| summarize cities=dcount(client_City) 
      by client_CountryOrRegion

![](./media/app-insights-analytics-reference/dcount.png)


### <a name="dcountif"></a>dcountif

    dcountif( Expression, Predicate [ ,  Accuracy ])

Επιστρέφει μια εκτίμηση του αριθμού διακριτών τιμών της *Εκφρ* γραμμών στην ομάδα για την οποία *κατηγορήματος* είναι αληθής. (Για να δημιουργήσετε μια λίστα διακριτές τιμές, χρησιμοποιήστε [`makeset`](#makeset).)

*Ακρίβεια*, εάν καθοριστεί, ελέγχει το υπόλοιπο μεταξύ ταχύτητας και ακρίβειας.

 * `0`= τουλάχιστον ακριβή και πιο ασφαλής υπολογισμού.
 * `1`η προεπιλογή, η οποία υπολοίπων ακρίβεια και υπολογισμού χρόνου; πληροφορίες σχετικά με το σφάλμα 0,8%.
 * `2`= πιο ακριβή και πιο αργές Υπολογισμός; πληροφορίες σχετικά με το σφάλμα 0,4%.

**Παράδειγμα**

    pageViews 
  	| summarize cities=dcountif(client_City, client_City startswith "St") 
      by client_CountryOrRegion


### <a name="makelist"></a>makelist

    makelist(Expr [ ,  MaxListSize ] )

Επιστρέφει μια `dynamic` πίνακα (JSON) όλων των τιμών της *παράσταση* στην ομάδα. 

* *MaxListSize* είναι μια προαιρετική ακέραιο όριο για το μέγιστο αριθμό των στοιχείων που επιστρέφονται (η προεπιλογή είναι *128*).

### <a name="makeset"></a>makeset

    makeset(Expression [ , MaxSetSize ] )

Επιστρέφει μια `dynamic` πίνακα (JSON) του συνόλου των διακριτές τιμές που τίθεται σε *παράσταση* στην ομάδα. (Συμβουλή: για να καταμετρήσετε μόνο διακριτές τιμές, χρησιμοποιήστε [`dcount`](#dcount).)
  
*  *MaxSetSize* είναι μια προαιρετική ακέραιο όριο για το μέγιστο αριθμό των στοιχείων που επιστρέφονται (η προεπιλογή είναι *128*).

**Παράδειγμα**

    pageViews 
  	| summarize cities=makeset(client_City) 
      by client_CountryOrRegion

![](./media/app-insights-analytics-reference/makeset.png)

Δείτε επίσης το [ `mvexpand` τελεστή](#mvexpand-operator) για τη συνάρτηση αντίθετη.


### <a name="max-min"></a>Max, min

    max(Expr)

Υπολογίζει τη μέγιστη τιμή *παράσταση*.
    
    min(Expr)

Υπολογίζει την ελάχιστη *παράσταση*.

**Συμβουλή**: Αυτό σας δίνει το ελάχιστο ή μέγιστο σε ξεχωριστή - για παράδειγμα, η μεγαλύτερη ή χαμηλότερη τιμή. Αλλά, εάν θέλετε να χρησιμοποιήσετε άλλες στήλες στη γραμμή - για παράδειγμα, το όνομα του προμηθευτή με τη χαμηλότερη τιμή - [argmin ή argmax](#argmin-argmax).


<a name="percentile"></a>
<a name="percentiles"></a>
<a name="percentilew"></a>
<a name="percentilesw"></a>
### <a name="percentile-percentiles-percentilew-percentilesw"></a>συνάρτηση PERCENTILE, εκατοστημόριου, percentilew, percentilesw

    percentile(Expression, Percentile)

Επιστρέφει μια εκτίμηση για το καθορισμένο εκατοστημόριο στην ομάδα *παράσταση* . Την ακρίβεια εξαρτάται από την πυκνότητα πληθυσμού στην περιοχή από το εκατοστημόριο.
    
    percentiles(Expression, Percentile1 [ , Percentile2 ...] )

Όπως `percentile()`, αλλά υπολογίζει έναν αριθμό εκατοστημόριο τιμών (που είναι μεγαλύτερη από τον υπολογισμό κάθε εκατοστημόριο μεμονωμένα).

    percentilew(Expression, WeightExpression, Percentile)

Σταθμισμένου εκατοστημόριο. Χρησιμοποιήστε αυτήν την επιλογή για προ-συγκεντρωτικά δεδομένα.  `WeightExpression`είναι ένας ακέραιος αριθμός που υποδεικνύει τον αριθμό των γραμμών αρχικό αντιπροσωπεύονται από κάθε Συγκεντρωτική γραμμή.

    percentilesw(Expression, WeightExpression, Percentile1, [, Percentile2 ...])

Όπως `percentilew()`, αλλά υπολογίζει έναν αριθμό εκατοστημόριο τιμών.

**Παραδείγματα**


Η τιμή του `duration` που είναι μεγαλύτερος από 95% του δείγματος Ορισμός και μικρότερη από 5% του συνόλου δείγμα, υπολογίζεται για κάθε όνομα αίτηση:

    request 
  	| summarize percentile(duration, 95)
      by name

Παράλειψη "με..." για να υπολογίσετε για ολόκληρο τον πίνακα.

Υπολογισμός ταυτόχρονα πολλές εκατοστημόριου για τα ονόματα διαφορετικό αίτηση:

    
    requests 
  	| summarize 
        percentiles(duration, 5, 20, 50, 80, 95) 
      by name

![](./media/app-insights-analytics-reference/percentiles.png)

Τα αποτελέσματα που εμφανίζονται για την αίτηση /Events/Index, 5% των αιτήσεων είναι απαντήσει σε λιγότερο από 2.44s, ήμισυ τους στο 3.52s, και 5% είναι μικρότερη από 6.85s.

Υπολογισμός πολλών στατιστικά στοιχεία:

    requests 
  	| summarize 
        count(), 
        avg(Duration),
        percentiles(Duration, 5, 50, 95)
      by name

#### <a name="weighted-percentiles"></a>Σταθμισμένου εκατοστημόριου

Χρησιμοποιήστε τις συναρτήσεις σταθμισμένων εκατοστημόριο στις περιπτώσεις όπου τα δεδομένα έχουν προ-συγκέντρωσης. 

Για παράδειγμα, ας υποθέσουμε ότι η εφαρμογή σας εκτελεί πολλών χιλιάδων λειτουργίες ανά δευτερόλεπτο και θέλετε να μάθετε τους λανθάνοντος χρόνου. Η απλή λύση θα ήταν για να δημιουργήσετε μια αίτηση εφαρμογής ιδέες ή ένα προσαρμοσμένο συμβάν για κάθε εργασία. Αυτό θα δημιουργήσει πολλές κίνηση, παρόλο που προσαρμόσιμη δειγματοληψία θα τεθούν σε ισχύ για να μειώσετε το. Αλλά αποφασίσετε να εφαρμόσετε μια ακόμα καλύτερη λύση: θα συντάσσετε ορισμένες κώδικα στην εφαρμογή για να συγκεντρώσετε τα δεδομένα πριν από την αποστολή σε εφαρμογή ιδέες. Η συγκεντρωτική σύνοψη θα σταλεί σε τακτά χρονικά διαστήματα, ίσως μείωση του ρυθμού δεδομένων σε μερικά σημεία ανά λεπτό.

Τον κωδικό λαμβάνει μια ροή των μετρήσεων λανθάνοντα χρόνο σε χιλιοστά του δευτερολέπτου. Για παράδειγμα:
    
     { 15, 12, 2, 21, 2, 5, 35, 7, 12, 22, 1, 15, 18, 12, 26, 7 }

Αυτό καταμετρά τις διαστάσεις στις ακόλουθες θέσεις:`{ 10, 20, 30, 40, 50, 100 }`

Περιοδικά, δημιουργεί μια σειρά από TrackEvent κλήσεις, μία για κάθε χρωματισμού, με το προσαρμοσμένο μετρήσεις σε κάθε κλήση: 

    foreach (var latency in bins.Keys)
    { telemetry.TrackEvent("latency", null, 
         new Dictionary<string, double>
         ({"latency", latency}, {"opCount", bins[latency]}}); }

Στην ανάλυση, βλέπετε μια τέτοια ομάδα συμβάντων ως εξής:

`opCount` | `latency`| σημασία
---|---|---
8 | 10 | = 8 λειτουργίες στον Κάδο τα 10
6 | 20 | = 6 λειτουργίες στον Κάδο 20ms
3 | 30 | = 3 λειτουργίες στον Κάδο 30ms
1 | 40 | = 1 λειτουργίες στον Κάδο 40ms

Για να λάβετε μια ακριβή εικόνα από την αρχική κατανομή των των αδρανειών συμβάντος, χρησιμοποιούμε `percentilesw`:

    customEvents | summarize percentilesw(latency, opCount, 20, 50, 80)

Τα αποτελέσματα είναι ίδια όπως αν είχατε χρησιμοποιήσαμε απλό `percentiles` στο αρχικό σύνολο των μετρήσεων.

> [AZURE.NOTE] Σταθμισμένων τιμές εκατοστημόριου βρίσκονται δεν ισχύει για το [δείγμα δεδομένων](app-insights-sampling.md), όπου κάθε γραμμή του δείγματος αντιπροσωπεύει τυχαία δείγμα του αρχικού γραμμές, αντί για έναν Κάδο. Οι συναρτήσεις απλό εκατοστημόριο είναι κατάλληλο για τα δεδομένα δείγματος.

#### <a name="estimation-error-in-percentiles"></a>Σφάλμα εκτίμησης σε εκατοστημόριου

Το συγκεντρωτικό αποτέλεσμα εκατοστημόριου παρέχει μια κατά προσέγγιση τιμή χρησιμοποιώντας [T σύνοψη](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf). 

Ορισμένα σημαντικά σημεία: 

* Τα όρια το σφάλμα εκτίμησης ανάλογα με την τιμή του το ζητήθηκε εκατοστημόριο. Την καλύτερη ακρίβεια είναι στα άκρα της [0..100] κλίμακα, εκατοστημόριου 0 και 100 είναι τα ακριβή ελάχιστες και μέγιστες της κατανομής. Την ακρίβεια μειώνει σταδιακά προς τη μέση της κλίμακας. Είναι χειρότερες στο τη διάμεσο και έχει φτάσει το 1%. 
* Σφάλμα ορίων εξετάζονται σε την κατάταξη, όχι στην την τιμή. Ας υποθέσουμε ότι εκατοστημόριο (X, 50) επέστρεψε τιμή Xm. Εκτίμηση εγγυάται ότι τουλάχιστον 49% και το πολύ 51% των τιμών του X είναι μικρότερο του Xm. Υπάρχει όριο θεωρητική σχετικά με τη διαφορά μεταξύ Xm και πραγματική διάμεση τιμή του X.

### <a name="stdev"></a>συνάρτηση STDEV

     stdev(Expr)

Επιστρέφει την τυπική απόκλιση *Εκφρ* επάνω από την ομάδα.

### <a name="variance"></a>Διακύμανση

    variance(Expr)

Επιστρέφει τη διακύμανση *Εκφρ* επάνω από την ομάδα.

### <a name="sum"></a>άθροισμα

    sum(Expr)

Επιστρέφει το άθροισμα των *Εκφρ* επάνω από την ομάδα.                      


## <a name="scalars"></a>Scalars

[αποκλίσεων](#casts) | [συγκρίσεις](#scalar-comparisons)
<br/>
[gettype](#gettype) | [κατακερματισμός](#hash) | [iff](#iff) |  [isnull](#isnull) | [isnotnull](#isnotnull) | [notnull](#notnull) | [toscalar](#toscalar)

Οι υποστηριζόμενοι τύποι είναι:

| Τύπος      | Επιπλέον ονόματα   | Ισοδύναμη τύπου .NET |
| --------- | -------------------- | -------------------- |
| `bool`    | `boolean`            | `System.Boolean`     |
| `datetime`| `date`               | `System.DateTime`    |
| `dynamic` |                      | `System.Object`      |
| `guid`    | `uuid`, `uniqueid`   | `System.Guid`        |
| `int`     |                      | `System.Int32`       |
| `long`    |                      | `System.Int64`       |
| `double`  | `real`               | `System.Double`      |
| `string`  |                      | `System.String`      |
| `timespan`| `time`               | `System.TimeSpan`    |

### <a name="casts"></a>Αποκλίσεων

Μπορείτε να μετατραπεί από έναν τύπο σε μια άλλη. Σε γενικές γραμμές, εάν η μετατροπή έχει νόημα, θα λειτουργήσει:

    todouble(10), todouble("10.6")
    toint(10.6) == 11
    floor(10.6) == 10
    toint("200")
    todatetime("2016-04-28 13:02")
    totimespan("1.5d"), totimespan("1.12:00:00")
    toguid("00000000-0000-0000-0000-000000000000")
    tostring(42.5)
    todynamic("{a:10, b:20}")

Ελέγξτε εάν μια συμβολοσειρά που μπορεί να μετατραπεί σε ένα συγκεκριμένο τύπο:

    iff(notnull(todouble(customDimensions.myValue)),
       ..., ...)

### <a name="scalar-comparisons"></a>Ανυσματική συγκρίσεις

||
---|---
`<` |Λιγότερο
`<=`|Μικρότερο ή ισούται με
`>` |Μεγαλύτερο
`>=`|Μεγαλύτερο ή ισούται με
`<>`|Δεν ισούται με
`!=`|Δεν ισούται με 
`in`| Δεξιός τελεστέος είναι ένας πίνακας (δυναμικό) και αριστερός τελεστέος είναι ίσο με ένα από τα στοιχεία του.
`!in`| Δεξιός τελεστέος είναι ένας πίνακας (δυναμικό) και αριστερός τελεστέος δεν είναι ίσο με οποιοδήποτε από τα στοιχεία του.




### <a name="gettype"></a>gettype

**Επιστρέφει**

Μια συμβολοσειρά που αναπαριστά τον υποκείμενο τύπο αποθήκευσης του ορίσματός της μία. Αυτό είναι ιδιαίτερα χρήσιμο όταν έχετε τιμές είδος `dynamic`: σε αυτήν την περίπτωση `gettype()` θα αποκαλύψει πώς κωδικοποιείται μια τιμή.

**Παραδείγματα**

|||
---|---
`gettype("a")` |`"string" `
`gettype(111)` |`"long" `
`gettype(1==1)` |`"int8"`
`gettype(now())` |`"datetime" `
`gettype(1s)` |`"timespan" `
`gettype(parsejson('1'))` |`"int" `
`gettype(parsejson(' "abc" '))` |`"string" `
`gettype(parsejson(' {"abc":1} '))` |`"dictionary"` 
`gettype(parsejson(' [1, 2, 3] '))` |`"array"` 
`gettype(123.45)` |`"real" `
`gettype(guid(12e8b78d-55b4-46ae-b068-26d7a0080254))` |`"guid"` 
`gettype(parsejson(''))` |`"null"`
`gettype(1.2)==real` | `true`

### <a name="hash"></a>Κατακερματισμός

**Σύνταξη**

    hash(source [, mod])

**Ορίσματα**

* *προέλευση*: το αρχείο προέλευσης ανυσματική υπολογίζεται ο κατακερματισμός.
* *MOD*: τη λειτουργική μονάδα τιμή για να εφαρμοστεί το αποτέλεσμα κατακερματισμός.

**Επιστρέφει**

Η τιμή xxhash (πλήρης) από τη δεδομένη άνυσμα, λειτουργική μονάδα τη δεδομένη τιμή mod (Εάν καθοριστεί).

**Παραδείγματα**

```
hash("World")                   // 1846988464401551951
hash("World", 100)              // 51 (1846988464401551951 % 100)
hash(datetime("2015-01-01"))    // 1380966698541616202
```
### <a name="iff"></a>IFF

Το `iff()` συνάρτηση αξιολογεί το πρώτο όρισμα (το κατηγόρημα) και επιστρέφει είτε την τιμή του δεύτερου ή τρίτο ορισμάτων ανάλογα με το αν είναι το κατηγόρημα `true` ή `false`. Το δεύτερο και τρίτο όρισμα πρέπει να έχουν τον ίδιο τύπο.

**Σύνταξη**

    iff(predicate, ifTrue, ifFalse)


**Ορίσματα**

* *κατηγόρημα:* Μια παράσταση που αξιολογείται σε μια `boolean` τιμή.
* *ifTrue:* Μια παράσταση που λαμβάνει αξιολογηθεί και την τιμή που επιστρέφεται από τη συνάρτηση εάν *κατηγόρημα* αποτιμάται σε `true`.
* *ifFalse:* Μια παράσταση που λαμβάνει αξιολογηθεί και την τιμή που επιστρέφεται από τη συνάρτηση εάν *κατηγόρημα* αποτιμάται σε `false`.

**Επιστρέφει**

Αυτή η συνάρτηση επιστρέφει την τιμή του *ifTrue* εάν είναι *κατηγόρημα* `true`, ή την τιμή της *ifFalse* διαφορετικά.

**Παράδειγμα**

```
iff(floor(timestamp, 1d)==floor(now(), 1d), "today", "anotherday")
```

<a name="isnull"/></a>
<a name="isnotnull"/></a>
<a name="notnull"/></a>
### <a name="isnull-isnotnull-notnull"></a>IsNull, isnotnull, notnull

    isnull(parsejson("")) == true

Ένα όρισμα λαμβάνει και να σας ενημερώνει για το αν είναι null.

**Σύνταξη**


    isnull([value])


    isnotnull([value])


    notnull([value])  // alias for isnotnull

**Επιστρέφει**

TRUE ή false ανάλογα με το εάν η τιμή είναι null ή not null.


|x|IsNull(x)
|---|---
| "" | FALSE
|"x" | FALSE
|parsejson("")|TRUE
|parsejson("[]")|FALSE
|parsejson("{}")|FALSE

**Παράδειγμα**

    T | where isnotnull(PossiblyNull) | count

Παρατηρήστε ότι δεν υπάρχουν άλλοι τρόποι για την επίτευξη αυτό το εφέ:

    T | summarize count(PossiblyNull)

### <a name="toscalar"></a>toscalar

Αξιολογεί ένα ερώτημα ή μια παράσταση και επιστρέφει το αποτέλεσμα ως μία τιμή. Αυτή η συνάρτηση είναι χρήσιμες για την εκτέλεση υπολογισμών σταδιακή; Για παράδειγμα, τον υπολογισμό μιας συνολικό πλήθος συμβάντων και, στη συνέχεια, χρησιμοποιώντας το ως μια γραμμή βάσης.

**Σύνταξη**

    toscalar(query)
    toscalar(scalar)

**Επιστρέφει**

Το όρισμα αξιολογηθεί. Εάν το όρισμα είναι ένας πίνακας, επιστρέφει την πρώτη στήλη της πρώτης γραμμής. (Για να τακτοποιήσετε ότι το όρισμα έχει μόνο μία στήλη και γραμμή είναι καλή πρακτική.)

**Παράδειγμα**

```AIQL

    // Get the count of requests 5 days ago:
    let baseline = toscalar(requests  
        | where floor(timestamp, 1d) == floor(ago(5d),1d) | count);
    // List the counts relative to that baseline:
    requests | summarize daycount = count() by floor(timestamp, 1d)  
  	| extend relative = daycount - baseline
```




### <a name="boolean-literals"></a>Σταθερές Boolean

    true == 1
    false == 0
    gettype(true) == "int8"
    typeof(bool) == typeof(int8)

### <a name="boolean-operators"></a>Οι τελεστές Boolean

    and 
    or 

    

## <a name="numbers"></a>Αριθμοί

[abs](#abs) | [bin](#bin) | [exp](#exp) | [floor](#floor) | [gamma](#gamma) |[log](#log) | [rand](#rand) | [range](#range) | [sqrt](#sqrt) 
| [todouble](#todouble) | [toint](#toint) | [tolong](#tolong)

### <a name="numeric-literals"></a>Αριθμητικές σταθερές

|||
|---|---
|`42`|`long`
|`42.0`|`real`

### <a name="arithmetic-operators"></a>Αριθμητικοί τελεστές

|| |
|---|-------------|
| + | Προσθήκη         |
| - | Αφαίρεση    |
| * | Πολλαπλασιασμός    |
| / | Διαίρεση      |
| % | Λειτουργική μονάδα      |
||
|`<` |Λιγότερο
|`<=`|Μικρότερο ή ισούται με
|`>` |Μεγαλύτερο
|`>=`|Μεγαλύτερο ή ισούται με
|`<>`|Δεν ισούται με
|`!=`|Δεν ισούται με 


### <a name="abs"></a>ABS

**Σύνταξη**

    abs(x)

**Ορίσματα**

* x - ένας ακέραιος, πραγματικό ή χρονικού εύρους

**Επιστρέφει**

    iff(x>0, x, -x)

<a name="bin"></a><a name="floor"></a>
### <a name="bin-floor"></a>θέση αποθήκης, ορόφου

Στρογγυλοποιεί τιμές προς τα κάτω έναν ακέραιο πολλαπλάσιο του μεγέθους μιας δεδομένης Ανακύκλωσης. Χρησιμοποιείται συχνά σε το [`summarize by`](#summarize-operator) ερωτήματος. Εάν έχετε ένα διάσπαρτα σύνολο τιμών, θα είναι ομαδοποιημένα σε ένα μικρότερο σύνολο από συγκεκριμένες τιμές.

Ψευδώνυμο `floor`.

**Σύνταξη**

     bin(value, roundTo)
     floor(value, roundTo)

**Ορίσματα**

* *τιμή:* Έναν αριθμό, ημερομηνία ή χρονικό διάστημα. 
* *roundTo:* Το "μέγεθος Ανακύκλωσης". Αριθμός, ημερομηνία ή χρονικό διάστημα που *διαιρεί*. 

**Επιστρέφει**

Στο πλησιέστερο πολλαπλάσιο του *roundTo* κάτω από *την τιμή*.  
 
    (toint((value/roundTo)-0.5)) * roundTo

**Παραδείγματα**

Παράσταση | Αποτέλεσμα
---|---
`bin(4.5, 1)` | `4.0`
`bin(time(16d), 7d)` | `14d`
`bin(datetime(1953-04-15 22:25:07), 1d)`|  `datetime(1953-04-15)`


Η παρακάτω παράσταση υπολογίζει ένα ιστόγραμμα διάρκειες, με μέγεθος χρωματισμού 1 δευτερόλεπτο:

```AIQL

    T | summarize Hits=count() by bin(Duration, 1s)
```

### <a name="exp"></a>EXP

    exp(v)   // e raised to the power v
    exp2(v)  // 2 raised to the power v
    exp10(v) // 10 raised to the power v


### <a name="floor"></a>FLOOR

Ένα ψευδώνυμο για [`bin()`](#bin).

### <a name="gamma"></a>συνάρτηση Gamma

Η [συνάρτηση gamma](https://en.wikipedia.org/wiki/Gamma_function)

**Σύνταξη**

    gamma(x)

**Ορίσματα**

* *x:* Ένας πραγματικός αριθμός

Για θετικοί ακέραιοι, `gamma(x) == (x-1)!` για παράδειγμα, `gamma(5) == 4 * 3 * 2 * 1`.

Δείτε επίσης [loggamma](#loggamma).


### <a name="log"></a>αρχείο καταγραφής

    log(v)    // Natural logarithm of v
    log2(v)   // Logarithm base 2 of v
    log10(v)  // Logarithm base 10 of v


`v`πρέπει να είναι πραγματικός αριθμός > 0. Διαφορετικά, επιστρέφεται η τιμή null.

### <a name="loggamma"></a>loggamma


Το φυσικό λογάριθμο της [συνάρτησης γάμα για](#gamma)την απόλυτη τιμή.

**Σύνταξη**

    loggamma(x)

**Ορίσματα**

* *x:* Ένας πραγματικός αριθμός


### <a name="rand"></a>συνάρτηση rand

Μια δημιουργία τυχαίων αριθμών.

* `rand()`-ένας πραγματικός αριθμός μεταξύ 0,0 και 1,0
* `rand(n)`-Ένας ακέραιος αριθμός από 0 έως n-1




### <a name="sqrt"></a>η συνάρτηση SQRT

Η συνάρτηση τετραγωνική ρίζα.  

**Σύνταξη**

    sqrt(x)

**Ορίσματα**

* *x:* Ένας πραγματικός αριθμός > = 0.

**Επιστρέφει**

* Ένας θετικός αριθμός τέτοια ώστε`sqrt(x) * sqrt(x) == x`
* `null`Εάν το όρισμα είναι αρνητικός αριθμός ή δεν μπορεί να μετατραπεί σε ένα `real` τιμή. 




### <a name="toint"></a>toint

    toint(100)        // cast from long
    toint(20.7) == 21 // nearest int from double
    toint(20.4) == 20 // nearest int from double
    toint("  123  ")  // parse string
    toint(a[0])       // cast from dynamic
    toint(b.c)        // cast from dynamic

### <a name="tolong"></a>tolong

    tolong(20.7) == 21 // conversion from double
    tolong(20.4) == 20 // conversion from double
    tolong("  123  ")  // parse string
    tolong(a[0])       // cast from dynamic
    tolong(b.c)        // cast from dynamic


### <a name="todouble"></a>todouble

    todouble(20) == 20.0 // conversion from long or int
    todouble(" 12.34 ")  // parse string
    todouble(a[0])       // cast from dynamic
    todouble(b.c)        // cast from dynamic



## <a name="date-and-time"></a>Ημερομηνίας και ώρας


[πριν από](#ago) | [dayofmonth](#dayofmonth) | [dayofweek](#dayofweek) |  [dayofyear](#dayofyear) |[datepart](#datepart) | [endofday](#endofday) | [endofmonth](#endofmonth) | [endofweek](#endofweek) | [endofyear](#endofyear) | [getmonth](#getmonth)|  [getyear](#getyear) | [τώρα](#now) | [startofday](#startofday) | [startofmonth](#startofmonth) | [startofweek](#startofweek) | [startofyear](#startofyear) | [todatetime](#todatetime) | [totimespan](#totimespan) | [weekofyear](#weekofyear)

### <a name="date-and-time-literals"></a>Λεκτικές σταθερές ημερομηνίας και ώρας

|||
---|---
**ημερομηνίας και ώρας**|
`datetime("2015-12-31 23:59:59.9")`<br/>`datetime("2015-12-31")`|Φορές είναι πάντα στο UTC. Παράλειψη της ημερομηνίας δίνει την ώρα σήμερα.
`now()`|Η τρέχουσα ώρα.
`now(`-*χρονικό διάστημα*`)`|`now()-`*χρονικό διάστημα*
`ago(`*χρονικό διάστημα*`)`|`now()-`*χρονικό διάστημα*
**χρονικό διάστημα**|
`2d`|2 ημέρες
`1.5h`|1,5 ώρα 
`30m`|30 λεπτά
`10s`|10 δευτερόλεπτα
`0.1s`|0.1 δευτερόλεπτο
`100ms`| 100 χιλιοστά του δευτερολέπτου
`10microsecond`|
`1tick`|100ns
`time("15 seconds")`|
`time("2")`| 2 ημέρες
`time("0.12:34:56.7")`|`0d+12h+34m+56.7s`

### <a name="date-and-time-expressions"></a>Οι παραστάσεις ημερομηνίας και ώρας

Παράσταση |Αποτέλεσμα
---|---
`datetime("2015-01-02") - datetime("2015-01-01")`| `1d`
`datetime("2015-01-01") + 1d`| `datetime("2015-01-02")`
`datetime("2015-01-01") - 1d`| `datetime("2014-12-31")`
`2h * 24` | `2d`
`2d` / `2h` | `24`
`datetime("2015-04-15T22:33") % 1d` | `timespan("22:33")`
`bin(datetime("2015-04-15T22:33"), 1d)` | `datetime("2015-04-15T00:00")`
||
`<` |Λιγότερο
`<=`|Μικρότερο ή ισούται με
`>` |Μεγαλύτερο
`>=`|Μεγαλύτερο ή ισούται με
`<>`|Δεν ισούται με
`!=`|Δεν ισούται με 




### <a name="ago"></a>πριν από

Αφαιρεί το συγκεκριμένο χρονικό διάστημα από την τρέχουσα ώρα ρολογιού UTC. Όπως `now()`, αυτή η συνάρτηση μπορεί να χρησιμοποιηθεί πολλές φορές σε μια πρόταση και την ώρα ρολογιού UTC γίνεται αναφορά θα είναι το ίδιο για όλες τις παρουσίες.

**Σύνταξη**

    ago(a_timespan)

**Ορίσματα**

* *a_timespan*: χρονικό διάστημα για να αφαιρέσετε από την τρέχουσα ώρα ρολογιού UTC (`now()`).

**Επιστρέφει**

    now() - a_timespan

**Παράδειγμα**

Όλες οι γραμμές με μια χρονική σήμανση την τελευταία ώρα:

```AIQL

    T | where timestamp > ago(1h)
```

### <a name="datepart"></a>DatePart

    datepart("Day", datetime(2015-12-14)) == 14

Εξάγει ένα καθορισμένο τμήμα μιας ημερομηνίας μορφή ακέραιου αριθμού.

**Σύνταξη**

    datepart(part, datetime)

**Ορίσματα**

* `part:String`-{"Έτος", "Μήνας", "Ημέρα", "Ώρα", "Λεπτό", "Δεύτερο", "Χιλιοστά του δευτερολέπτου", "Microsecond", "Nanosecond"}
* `datetime`

**Επιστρέφει**

Μεγάλου μήκους που αντιπροσωπεύει το καθορισμένο τμήμα.


### <a name="dayofmonth"></a>dayofmonth

    dayofmonth(datetime("2016-05-15")) == 15 

Ο αριθμός σειράς της ημέρας του μήνα.

**Σύνταξη**

    dayofmonth(a_date)

**Ορίσματα**

* `a_date`: A `datetime`.


### <a name="dayofweek"></a>DayOfWeek

    dayofweek(datetime("2015-12-14")) == 1d  // Monday

Ο ακέραιος αριθμός ημερών από το προηγούμενο Κυριακή, ως μια `timespan`.

**Σύνταξη**

    dayofweek(a_date)

**Ορίσματα**

* `a_date`: A `datetime`.

**Επιστρέφει**

Το `timespan` επειδή τα μεσάνυχτα στην αρχή του προηγούμενου Κυριακή, στρογγυλοποιημένο προς τα κάτω έναν ακέραιο αριθμό των ημερών.

**Παραδείγματα**

```AIQL
dayofweek(1947-11-29 10:00:05)  // time(6.00:00:00), indicating Saturday
dayofweek(1970-05-11)           // time(1.00:00:00), indicating Monday
```

### <a name="dayofyear"></a>DAYOFYEAR

    dayofyear(datetime("2016-05-31")) == 152 
    dayofyear(datetime("2016-01-01")) == 1 

Ο αριθμός σειράς από την ημέρα του έτους.

**Σύνταξη**

    dayofyear(a_date)

**Ορίσματα**

* `a_date`: A `datetime`.

<a name="endofday"></a><a name="endofweek"></a><a name="endofmonth"></a><a name="endofyear"></a>
### <a name="endofday-endofweek-endofmonth-endofyear"></a>endofday, endofweek, endofmonth, endofyear

    dt = datetime("2016-05-23 12:34")

    endofday(dt) == 2016-05-23T23:59:59.999
    endofweek(dt) == 2016-05-28T23:59:59.999 // Saturday
    endofmonth(dt) == 2016-05-31T23:59:59.999 
    endofyear(dt) == 2016-12-31T23:59:59.999 


### <a name="getmonth"></a>getmonth

Λάβετε τον αριθμό του μήνα (1-12) από μια ημερομηνία/ώρα.

**Παράδειγμα**

    ... | extend month = getmonth(datetime(2015-10-12))

    --> month == 10

### <a name="getyear"></a>getyear

Λάβετε το έτος από μια ημερομηνία/ώρα.

**Παράδειγμα**

    ... | extend year = getyear(datetime(2015-10-12))

    --> year == 2015

### <a name="now"></a>τώρα

    now()
    now(-2d)

Την τρέχουσα ώρα ρολογιού UTC, μετατόπιση προαιρετικά από ένα συγκεκριμένο χρονικό διάστημα. Αυτή η συνάρτηση μπορεί να χρησιμοποιηθεί πολλές φορές σε μια πρόταση και την ώρα ρολογιού που αναφέρεται θα είναι το ίδιο για όλες τις εμφανίσεις.

**Σύνταξη**

    now([offset])

**Ορίσματα**

* *Μετατόπιση:* A `timespan`, προστέθηκε για την τρέχουσα ώρα ρολόι UTC. Προεπιλεγμένη: 0.

**Επιστρέφει**

Η τρέχουσα ώρα ρολογιού UTC ως μια `datetime`.

    now() + offset

**Παράδειγμα**

Καθορίζει το χρονικό διάστημα από το συμβάν που προσδιορίζεται από το κατηγόρημα:

```AIQL
T | where ... | extend Elapsed=now() - timestamp
```

<a name="startofday"></a><a name="startofweek"></a><a name="startofmonth"></a><a name="startofyear"></a>
### <a name="startofday-startofweek-startofmonth-startofyear"></a>startofday, startofweek, startofmonth, startofyear

    date=datetime("2016-05-23 12:34:56")

    startofday(date) == datetime("2016-05-23")
    startofweek(date) == datetime("2016-05-22") // Sunday
    startofmonth(date) == datetime("2016-05-01")
    startofyear(date) == datetime("2016-01-01")



### <a name="todatetime"></a>todatetime

Ψευδώνυμο `datetime()`.

     todatetime("2016-03-28")
     todatetime("03/28/2016")
     todatetime("2016-03-28 14:34:00")
     todatetime("03/28/2016 2:34pm")
     todatetime("2016-03-28T14:34.5Z")
     todatetime(a[0]) 
     todatetime(b.c) 

Ελέγξτε εάν μια συμβολοσειρά είναι έγκυρη ημερομηνία:

     iff(notnull(todatetime(customDimensions.myDate)),
         ..., ...)


### <a name="totimespan"></a>totimespan

Ψευδώνυμο `timespan()`.

    totimespan("21d")
    totimespan("21h")
    totimespan(request.duration)

### <a name="weekofyear"></a>weekofyear

    weekofyear(datetime("2016-05-14")) == 21
    weekofyear(datetime("2016-01-03")) == 1
    weekofyear(datetime("2016-12-31")) == 53

Το αποτέλεσμα ακέραιο αντιπροσωπεύει τον αριθμό εβδομάδας από την τυπική ISO 8601. Την πρώτη ημέρα της εβδομάδας είναι Κυριακή και την πρώτη εβδομάδα του έτους είναι η εβδομάδα που περιέχει την πρώτη Πέμπτη το έτος. (Τις τελευταίες ημέρες από ένα έτος, επομένως, μπορεί να περιέχει κάποιες από τις ημέρες της εβδομάδας 1 του επόμενου έτους, ή οι πρώτες ημέρες μπορούν να περιέχουν ορισμένων της εβδομάδας 52 ή 53 του προηγούμενου έτους.)


## <a name="string"></a>Συμβολοσειρά

[countof](#countof) | [εξαγάγετε](#extract) | [extractjson](#extractjson)  | [isempty](#isempty) | [isnotempty](#isnotempty) | [notempty](#notempty) | [parseurl](#parseurl) | [Αντικατάσταση](#replace) | [Διαίρεση](#split) | [strcat](#strcat) | [strlen](#strlen) | [δευτερεύουσα συμβολοσειρά](#substring) | [tolower](#tolower) | [tostring](#tostring) | [toupper](#toupper)


### <a name="string-literals"></a>Συμβολοσειρές κειμένου

Οι κανόνες είναι τα ίδια με αυτά JavaScript.

Συμβολοσειρές ενδέχεται να περικλείονται είτε σε μονά ή διπλά προσφοράς χαρακτήρες. 

Ανάστροφη κάθετο (`\`) χρησιμοποιείται για να βγείτε χαρακτήρες όπως `\t` (καρτέλα), `\n` (νέα γραμμή) και τις εμφανίσεις του ονόματος του περικλείει χαρακτήρας εισαγωγικών.

* `'this is a "string" literal in single \' quotes'`
* `"this is a 'string' literal in double \" quotes"`
* `@"C:\backslash\not\escaped\with @ prefix"`

### <a name="obfuscated-string-literals"></a>Θολού συμβολοσειρές κειμένου

Θολού συμβολοσειρές κειμένου είναι συμβολοσειρές που θα κρύβουν ανάλυσης κατά την εξαγωγή της συμβολοσειράς (για παράδειγμα, κατά την παρακολούθηση). Η διαδικασία ασάφειας αντικαθιστά όλες θολού χαρακτήρων από μια έναρξης (`*`) χαρακτήρων.

Για να δημιουργήσετε ένα θολού συμβολοσειρά κειμένου, ξεκινούν `h` ή "H". Για παράδειγμα:

```
h'hello'
h@'world' 
h"hello"
```

### <a name="string-comparisons"></a>Σύγκριση συμβολοσειρών

Τελεστής|Περιγραφή|Διάκριση πεζών-κεφαλαίων|Παράδειγμα TRUE
---|---|---|---
`==`|Ισούται με |Ναι| `"aBc" == "aBc"`
`<>` `!=`|Δεν ισούται με|Ναι| `"abc" <> "ABC"`
`=~`|Ισούται με |Όχι| `"abc" =~ "ABC"`
`!~`|Δεν ισούται με |Όχι| `"aBc" !~ "xyz"`
`has`|Δεξιά-τιμόνι πλευρά (RHS) είναι μια ολόκληρη όρος σε αριστερά-τιμόνι πλευρά (LHS)|Όχι| `"North America" has "america"`
`!has`|RHS δεν είναι πλήρης όρο σε LHS|Όχι|`"North America" !has "amer"` 
`hasprefix`|RHS είναι ένα πρόθεμα της όρο σε LHS|Όχι|`"North America" hasprefix "ame"`
`!hasprefix`|RHS δεν είναι ένα πρόθεμα του οποιαδήποτε όρου στο LHS|Όχι|`"North America" !hasprefix "mer"`
`hassuffix`|RHS είναι κατάληξη όρο σε LHS|Όχι|`"North America" hassuffix "rth"`
`!hassuffix`|RHS δεν είναι κατάληξη οποιαδήποτε όρο σε LHS|Όχι|`"North America" !hassuffix "mer"`
`contains` | RHS εκτελείται ως μια δευτερεύουσα LHS|Όχι| `"FabriKam" contains "BRik"`
`!contains`| RHS δεν εμφανίζεται στο LHS|Όχι| `"Fabrikam" !contains "xyz"`
`containscs` | RHS εκτελείται ως μια δευτερεύουσα LHS|Ναι| `"FabriKam" contains "Kam"`
`!containscs`| RHS δεν εμφανίζεται στο LHS|Ναι| `"Fabrikam" !contains "Kam"`
`startswith`|RHS είναι ένα αρχικό δευτερεύουσας LHS.|Όχι|`"Fabrikam" startswith "fab"`
`!startswith`|RHS δεν είναι ένα αρχικό δευτερεύουσα LHS.|Όχι|`"Fabrikam" !startswith "abr"`
`endswith`|RHS είναι μια δευτερεύουσα τερματικού LHS.|Όχι|`"Fabrikam" endswith "kam"`
`!endswith`|RHS δεν είναι μια δευτερεύουσα τερματικού LHS.|Όχι|`"Fabrikam" !endswith "ka"`
`matches regex`|LHS περιέχει μια αντιστοιχία για RHS|Ναι| `"Fabrikam" matches regex "b.*k"`
`in`|Ίσο με οποιοδήποτε από τα στοιχεία|Ναι|`"abc" in ("123", "345", "abc")`
`!in`|Δεν ισούται με οποιοδήποτε από τα στοιχεία|Ναι|`"bc" !in ("123", "345", "abc")`

Χρήση `has` ή `in` εάν δοκιμές για την παρουσία ενός όρου ολόκληρο λεκτική - δηλαδή, ένα σύμβολο ή έναν αλφαριθμητικό word που ορίζεται από μη αλφαριθμητικούς χαρακτήρες ή αρχή ή στο τέλος του πεδίου. `has`εκτελεί ταχύτερη από `contains`, `startswith` ή `endswith`. Το πρώτο από αυτά τα ερωτήματα εκτελείται πιο γρήγορα:

    EventLog | where continent has "North" | count;
    EventLog | where continent contains "nor" | count





### <a name="countof"></a>countof

    countof("The cat sat on the mat", "at") == 3
    countof("The cat sat on the mat", @"\b.at\b", "regex") == 3

Καταμετρά τις εμφανίσεις του μια δευτερεύουσα σε μια συμβολοσειρά. Απλό συμβολοσειρά συμφωνίες μπορεί να επικαλύπτονται; Μην κάνετε συμφωνίες Regex.

**Σύνταξη**

    countof(text, search [, kind])

**Ορίσματα**

* *κειμένου:* Μια συμβολοσειρά.
* *αναζήτησης:* Η απλή συμβολοσειρά ή κανονική έκφραση ώστε να ταιριάζει με μέσα σε *κείμενο*.
* *είδος:* `"normal"|"regex"` Προεπιλεγμένη `normal`. 

**Επιστρέφει**

Ο αριθμός των φορών που μπορούν να αντιστοιχούν στη συμβολοσειρά αναζήτησης στο κοντέινερ. Απλό συμβολοσειρά συμφωνίες μπορεί να επικαλύπτονται; Μην κάνετε συμφωνίες Regex.

**Παραδείγματα**

|||
|---|---
|`countof("aaa", "a")`| 3 
|`countof("aaaa", "aa")`| 3 (δεν 2!)
|`countof("ababa", "ab", "normal")`| 2
|`countof("ababa", "aba")`| 2
|`countof("ababa", "aba", "regex")`| 1
|`countof("abcabc", "a.c", "regex")`| 2
    



### <a name="extract"></a>Εξαγωγή

    extract("x=([0-9.]+)", 1, "hello x=45.6|wo") == "45.6"

Λάβετε μια αντιστοιχία για μια [κανονική έκφραση](#regular-expressions) από μια συμβολοσειρά κειμένου. Προαιρετικά, στη συνέχεια, μετατρέπει τη δευτερεύουσα συμβολοσειρά που έχουν εξαχθεί του καθορισμένου τύπου.

**Σύνταξη**

    extract(regex, captureGroup, text [, typeLiteral])

**Ορίσματα**

* *regex:* Μια [κανονική έκφραση](#regular-expressions).
* *captureGroup:* Ένα θετικό `int` σταθερά που υποδεικνύει ότι η ομάδα καταγραφής για να εξαγάγετε. 0 σημαίνει για την αντιστοίχιση ολόκληρου, 1 για την τιμή που έχει αντιστοιχιστεί από το πρώτο '(' παρένθεση')' στην κανονική παράσταση, 2 ή περισσότερα για τις επόμενες παρενθέσεις.
* *κειμένου:* A `string` για να πραγματοποιήσετε αναζήτηση.
* *typeLiteral:* Ένα προαιρετικό τύπος λεκτικής σταθεράς (π.χ., `typeof(long)`). Εάν παρέχεται, τη δευτερεύουσα συμβολοσειρά που έχει εξαχθεί μετατρέπεται σε αυτόν τον τύπο. 

**Επιστρέφει**

Εάν *regex* εντοπίζει μια αντιστοιχία στο *κείμενο*: τη δευτερεύουσα συμβολοσειρά αντιστοιχιστεί σε σχέση με την ομάδα καθορισμένου καταγραφής *captureGroup*, προαιρετικά μετατρέπονται σε *typeLiteral*.

Εάν υπάρχει συμφωνία ή η μετατροπή του τύπου αποτυγχάνει: `null`. 

**Παραδείγματα**

Η συμβολοσειρά παράδειγμα `Trace` αναζήτησης για τον ορισμό για `Duration`. Η αντιστοιχία μετατρέπεται σε `real`, στη συνέχεια, το πολλαπλασιασμένη επί μια σταθερά χρόνου (`1s`) ώστε να `Duration` είναι τύπου `timespan`. Σε αυτό το παράδειγμα, είναι ίση με 123.45 δευτερόλεπτα:

```AIQL
...
| extend Trace="A=1, B=2, Duration=123.45, ..."
| extend Duration = extract("Duration=([0-9.]+)", 1, Trace, typeof(real)) * time(1s) 
```

Αυτό το παράδειγμα είναι ισοδύναμο με `substring(Text, 2, 4)`:

```AIQL
extract("^.{2,2}(.{4,4})", 1, Text)
```

<a name="notempty"></a>
<a name="isnotempty"></a>
<a name="isempty"></a>
### <a name="isempty-isnotempty-notempty"></a>IsEmpty, isnotempty, notempty

    isempty("") == true

Επιστρέφει TRUE εάν το όρισμα είναι μια κενή συμβολοσειρά ή είναι null.
Δείτε επίσης [isnull](#isnull).


**Σύνταξη**

    isempty([value])


    isnotempty([value])


    notempty([value]) // alias of isnotempty

**Επιστρέφει**

Υποδηλώνει εάν το όρισμα είναι μια κενή συμβολοσειρά ή isnull.

|x|IsEmpty(x)
|---|---
| "" | TRUE
|"x" | FALSE
|parsejson("")|TRUE
|parsejson("[]")|FALSE
|parsejson("{}")|FALSE


**Παράδειγμα**


    T | where isempty(fieldName) | count


### <a name="parseurl"></a>parseurl

Διαίρεση μιας διεύθυνσης URL στα μέρη.

**Σύνταξη**

    parseurl(urlstring)

**Ορίσματα**

* *urlstring:* ΜΙΑ ΔΙΕΎΘΥΝΣΗ URL.

**Επιστρέφει**

Ένα αντικείμενο που περιέχει τα τμήματα ως συμβολοσειρές.

**Παράδειγμα**

    parseurl("http://user:pass@contoso.com/icecream/buy.aspx?a=1&b=2#tag")

    {
    "Scheme" : "http",
    "Host" : "contoso.com",
    "Port" : "80",
    "Path" : "/icecream/buy.aspx",
    "Username" : "user",
    "Password" : "pass",
    "Query Parameters" : {"a":"1","b":"2"},
    "Fragment" : "tag"
    }

### <a name="replace"></a>Αντικατάσταση

Αντικαταστήστε όλες τις συμφωνίες regex με μια άλλη συμβολοσειρά.

**Σύνταξη**

    replace(regex, rewrite, text)

**Ορίσματα**

* *regex:* Η [κανονική παράσταση](https://github.com/google/re2/wiki/Syntax) για να αναζητήσετε *κείμενο*. Μπορεί να περιέχει ομάδες καταγραφής στο '('παρενθέσεις')'. 
* *επανεγγραφή:* Το regex αντικατάστασης για οποιαδήποτε αντιστοιχία που έγιναν από *matchingRegex*. Χρήση `\0` αναφέρεται σε ολόκληρη την αντιστοίχιση, `\1` για την πρώτη ομάδα καταγραφής, `\2` και ούτω καθεξής για ομάδες οι επόμενες καταγραφής.
* *κειμένου:* Μια συμβολοσειρά.

**Επιστρέφει**

*κείμενο* μετά την αντικατάσταση όλων των *regex* με αξιολογήσεις των *επανεγγραφή*. Συμφωνίες δεν επικαλύπτονται.

**Παράδειγμα**

Αυτήν τη δήλωση:

```AIQL
range x from 1 to 5 step 1
| extend str=strcat('Number is ', tostring(x))
| extend replaced=replace(@'is (\d+)', @'was: \1', str)
```

Περιλαμβάνει τα παρακάτω αποτελέσματα:

| x    | Str | αντικατασταθεί|
|---|---|---|
| 1    | Ο αριθμός είναι 1.000000  | Αριθμός ήταν: 1.000000|
| 2    | Ο αριθμός είναι 2.000000  | Αριθμός ήταν: 2.000000|
| 3    | Ο αριθμός είναι 3.000000  | Αριθμός ήταν: 3.000000|
| 4    | Ο αριθμός είναι 4.000000  | Αριθμός ήταν: 4.000000|
| 5    | Ο αριθμός είναι 5.000000  | Αριθμός ήταν: 5.000000|
 



### <a name="split"></a>Διαίρεση

    split("aaa_bbb_ccc", "_") == ["aaa","bbb","ccc"]

Διαιρεί μια δεδομένη συμβολοσειρά σύμφωνα με δεδομένη οριοθέτη και επιστρέφει μια συμβολοσειρά πίνακα με των δευτερευουσών συμβολοσειρών conatined. Προαιρετικά, μπορεί να είναι μια συγκεκριμένη δευτερεύουσα επιστρέφεται εάν υπάρχει.

**Σύνταξη**

    split(source, delimiter [, requestedIndex])

**Ορίσματα**

* *προέλευση*: τη συμβολοσειρά προέλευσης που θα διαιρεθεί σύμφωνα με τη δεδομένη οριοθέτη.
* *οριοθέτη*: Ο οριοθέτης που θα χρησιμοποιηθεί για να διαιρέσετε συμβολοσειρά προέλευσης.
* *requestedIndex*: ένα προαιρετικό δείκτη `int`. Εάν παρέχεται, έναν πίνακα συμβολοσειρά που επιστρέφεται θα περιέχει τη δευτερεύουσα συμβολοσειρά ζητήθηκε, εάν υπάρχει. 

**Επιστρέφει**

Μια συμβολοσειρά πίνακα που περιέχει το συμβολοσειρές της συμβολοσειράς που δίνεται προέλευσης που είναι οριοθετημένο από τη δεδομένη οριοθέτη.

**Παραδείγματα**

```
split("aa_bb", "_")           // ["aa","bb"]
split("aaa_bbb_ccc", "_", 1)  // ["bbb"]
split("", "_")                // [""]
split("a__b")                 // ["a","","b"]
split("aabbcc", "bb")         // ["aa","cc"]
```




### <a name="strcat"></a>strcat

    strcat("hello", " ", "world")

Συνδέει μεταξύ 1 και 16 ορίσματα, τα οποία πρέπει να είναι συμβολοσειρές.

### <a name="strlen"></a>strlen

    strlen("hello") == 5

Το μήκος της συμβολοσειράς.

### <a name="substring"></a>δευτερεύουσα συμβολοσειρά

    substring("abcdefg", 1, 2) == "bc"

Εξαγάγετε μια δευτερεύουσα από μια συγκεκριμένη πηγή συμβολοσειρά, ξεκινώντας από μια δεδομένη ευρετήριο. Προαιρετικά, μπορείτε να καθορίσετε το μήκος της ζητήθηκε δευτερεύουσας συμβολοσειράς.

**Σύνταξη**

    substring(source, startingIndex [, length])

**Ορίσματα**

* *προέλευσης:* Η συμβολοσειρά προέλευσης που θα ληφθεί από τη δευτερεύουσα συμβολοσειρά.
* *startingIndex:* Ως βάση το μηδέν χαρακτήρα σημείου έναρξης της ζητήθηκε δευτερεύουσας συμβολοσειράς.
* *μήκος:* Μια προαιρετική παράμετρος που μπορούν να χρησιμοποιηθούν για να καθορίσετε τον απαιτούμενο αριθμό χαρακτήρων στο τη δευτερεύουσα συμβολοσειρά. 

**Επιστρέφει**

Μια δευτερεύουσα από τη δεδομένη συμβολοσειρά. Η δευτερεύουσα συμβολοσειρά ξεκινά από τη θέση του χαρακτήρα startingIndex (ως βάση το μηδέν) και συνεχίζει μέχρι το τέλος της τους χαρακτήρες ή το μήκος της συμβολοσειράς Εάν καθοριστεί.

**Παραδείγματα**

```
substring("123456", 1)        // 23456
substring("123456", 2, 2)     // 34
substring("ABCD", 0, 2)       // AB
```

### <a name="tolower"></a>tolower

    tolower("HELLO") == "hello"

Μετατρέπει μια συμβολοσειρά σε πεζά.

### <a name="toupper"></a>toupper

    toupper("hello") == "HELLO"

Μετατρέπει μια συμβολοσειρά σε κεφαλαία γράμματα.



### <a name="guids"></a>GUID

    guid(00000000-1111-2222-3333-055567f333de)


## <a name="arrays-objects-and-dynamic"></a>Πίνακες, αντικείμενα και δυναμικές

[λεκτικές σταθερές](#dynamic-literals) | [χύτευσης](#casting-dynamic-objects) | [τελεστές](#operators) | [σας επιτρέπουν να όρους](#dynamic-objects-in-let-clauses)
<br/>
[arraylength](#arraylength) | [extractjson](#extractjson) | [parsejson](#parsejson) | [περιοχή](#range) | [treepath](#treepath) | [todynamic](#todynamic) | [zip](#zip)


Αυτό είναι το αποτέλεσμα ενός ερωτήματος σε μια εξαίρεση εφαρμογής ιδέες. Η τιμή στο `details` είναι ένας πίνακας.

![](./media/app-insights-analytics-reference/310.png)

**Δημιουργίας ευρετηρίου:** Ευρετήριο πίνακες και αντικείμενα ακριβώς όπως JavaScript:

    exceptions | take 1
  	| extend 
        line = details[0].parsedStack[0].line,
        stackdepth = arraylength(details[0].parsedStack)

* Αλλά χρησιμοποιήσετε `arraylength` και άλλες συναρτήσεις ανάλυσης (όχι ".length"!)

**Οποίο προέρχεται** Σε ορισμένες περιπτώσεις είναι απαραίτητο να μετατροπή του περιεχομένου σε ένα στοιχείο που μπορείτε να εξαγάγετε από ένα αντικείμενο, επειδή ο τύπος μπορεί να διαφέρουν. Για παράδειγμα, `summarize...to` χρειάζεται ένα συγκεκριμένο τύπο:

    exceptions 
  	| summarize count() 
      by toint(details[0].parsedStack[0].line)

    exceptions 
  	| summarize count() 
      by tostring(details[0].parsedStack[0].assembly)

**Λεκτικές σταθερές** Για να δημιουργήσετε μια ρητή πίνακα ή ένα αντικείμενο ιδιότητα τσάντα, συντάξτε το ως συμβολοσειρά JSON και cast:

    todynamic('[{"x":"1", "y":"32"}, {"x":"6", "y":"44"}]')


**mvexpand:** Για να αποσπάσετε απομακρύνετε τις ιδιότητες ενός αντικειμένου σε ξεχωριστές γραμμές, χρησιμοποιήστε mvexpand:

    exceptions | take 1 
  	| mvexpand details[0].parsedStack[0]


![](./media/app-insights-analytics-reference/410.png)


**treepath:** Για να βρείτε όλες οι διαδρομές σε ένα αντικείμενο σύνθετες:

    exceptions | take 1 | project timestamp, details 
  	| extend path = treepath(details) 
  	| mvexpand path


![](./media/app-insights-analytics-reference/420.png)

**buildschema:** Για να βρείτε το ελάχιστο σχήμα που δέχεται όλες τις τιμές της παράστασης στον πίνακα:

    exceptions | summarize buildschema(details)

Αποτέλεσμα:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Σημειώστε ότι `indexer` χρησιμοποιείται για να επισημάνετε το σημείο όπου θα πρέπει να χρησιμοποιήσετε ένα αριθμητικό ευρετήριο. Για αυτό το σχήμα, ορισμένες έγκυρες διαδρομές θα (αν υποθέσουμε ότι αυτά τα ευρετήρια παράδειγμα βρίσκονται στην περιοχή):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)



### <a name="array-and-object-literals"></a>Λεκτικές σταθερές πίνακα και αντικειμένων

Για να δημιουργήσετε μια δυναμική καθορισμένη τιμή, χρησιμοποιήστε `parsejson` (ψευδώνυμο `todynamic`) με ένα JSON συμβολοσειράς όρισμα:

* `parsejson('[43, 21, 65]')`-έναν πίνακα αριθμών
* `parsejson('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')` 
* `parsejson('21')`-μια μεμονωμένη τιμή δυναμικής του τύπου που περιέχει έναν αριθμό
* `parsejson('"21"')`-μια μεμονωμένη τιμή δυναμικής του τύπου που περιέχει μια συμβολοσειρά

Σημειώστε ότι, σε αντίθεση με JavaScript, JSON υποδεικνύει τη χρήση του διπλά εισαγωγικά (`"`) γύρω από συμβολοσειρές. Επομένως, είναι γενικά ευκολότερο να προσφοράς μια JSON κωδικοποιημένη συμβολοσειρά λεκτικές σταθερές με χρήση ενός προσφορές (`'`).

Αυτό το παράδειγμα δημιουργεί μια δυναμική τιμή και, στη συνέχεια, να χρησιμοποιεί τα πεδία:

```

T
| extend person = parsejson('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')
| extend n = person.name, add = person.address.street
```


### <a name="dynamic-object-functions"></a>Συναρτήσεις δυναμικής αντικειμένου

|||
|---|---|
| *τιμή* `in` *πίνακα*| TRUE εάν υπάρχει ένα στοιχείο του *πίνακα* που == *τιμή*<br/>`where City in ('London', 'Paris', 'Rome')`
| *τιμή* `!in` *πίνακα*| Επιστρέφει TRUE, εάν δεν υπάρχει στοιχείο του *πίνακα* που == *τιμή*
|[`arraylength(`πίνακα`)`](#arraylength)| Τιμή null Εάν δεν είναι ένας πίνακας
|[`extractjson(`διαδρομή, αντικείμενο`)`](#extractjson)|Χρησιμοποιεί διαδρομή για να περιηγηθείτε στο αντικείμενο.
|[`parsejson(`αρχείο προέλευσης`)`](#parsejson)| Μετατρέπει μια συμβολοσειρά JSON σε μια δυναμική αντικειμένου.
|[`range(`από, για να, βήμα`)`](#range)| Έναν πίνακα τιμών
|[`mvexpand`listColumn](#mvexpand-operator) | Αναπαράγει μια γραμμή για κάθε τιμή σε μια λίστα σε ένα συγκεκριμένο κελί.
|[`summarize buildschema(`στήλη`)`](#buildschema) |Παράγει το σχήμα τύπου από το περιεχόμενο της στήλης
|[`summarize makelist(`στήλη`)`](#makelist)| Ισοπεδώνει ομάδες των γραμμών και τοποθετεί τις τιμές της στήλης σε έναν πίνακα.
|[`summarize makeset(`στήλη`)`](#makeset) | Ισοπεδώνει ομάδες των γραμμών και τοποθετεί τις τιμές της στήλης σε πίνακα, χωρίς αναπαραγωγή.

### <a name="dynamic-objects-in-let-clauses"></a>Δυναμική αντικείμενα σας επιτρέπουν να όρους


[Σας επιτρέπουν να όρους](#let-clause) store δυναμικής τιμές ως συμβολοσειρές, επομένως, αυτά τα δύο όρους ισοδύναμη και και τα δύο πρέπει το `parsejson` (ή `todynamic`) προτού χρησιμοποιηθεί:

    let list1 = '{"a" : "somevalue"}';
    let list2 = parsejson('{"a" : "somevalue"}');

    T | project parsejson(list1).a, parsejson(list2).a




### <a name="arraylength"></a>arraylength

Ο αριθμός των στοιχείων σε ένα δυναμικό πίνακα.

**Σύνταξη**

    arraylength(array)

**Ορίσματα**

* *πίνακα:* A `dynamic` τιμή.

**Επιστρέφει**

Ο αριθμός των στοιχείων στον *πίνακα*, ή `null` εάν ο *Πίνακας* δεν είναι ένας πίνακας.

**Παραδείγματα**

```
arraylength(parsejson('[1, 2, 3, "four"]')) == 4
arraylength(parsejson('[8]')) == 1
arraylength(parsejson('[{}]')) == 1
arraylength(parsejson('[]')) == 0
arraylength(parsejson('{}')) == null
arraylength(parsejson('21')) == null
```



### <a name="extractjson"></a>extractjson

    extractjson("$.hosts[1].AvailableMB", EventText, typeof(int))

Λάβετε ένα καθορισμένο στοιχείο Έξοδος από το ένα κείμενο JSON χρησιμοποιώντας μια παράσταση διαδρομής. Μετατροπή προαιρετικά τη συμβολοσειρά που έχει εξαχθεί σε ένα συγκεκριμένο τύπο.


**Σύνταξη**

```

    string extractjson(jsonPath, dataSource) 
    resulttype extractjson(jsonPath, dataSource, typeof(resulttype))
```


**Επιστρέφει**

Αυτή η συνάρτηση εκτελεί ένα ερώτημα JsonPath στο αρχείο προέλευσης δεδομένων που περιέχει μια έγκυρη συμβολοσειρά JSON, προαιρετικά τη μετατροπή αυτήν την τιμή σε έναν άλλο τύπο ανάλογα με το τρίτο όρισμα.



**Παράδειγμα**

Η σημειογραφία [αγκύλη] και σημειογραφία είναι ισοδύναμες:

    ... | extend AvailableMB = extractjson("$.hosts[1].AvailableMB", EventText, typeof(int)) | ...

    ... | extend AvailableMD = extractjson("$['hosts'][1]['AvailableMB']", EventText, typeof(int)) | ...



**Συμβουλές επιδόσεων**

* Εφαρμογή πού όρους πριν από τη χρήση`extractjson()`
* Μπορείτε να χρησιμοποιήσετε μια κανονική έκφραση αντιστοιχία με [Εξαγωγή](#extract) αντί για αυτό. Αυτό μπορεί να εκτελεστεί πολύ πολύ πιο γρήγορα και τίθεται σε ισχύ, εάν η JSON παράγεται από ένα πρότυπο.
* Χρήση `parsejson()` εάν θέλετε να εξαγάγετε περισσότερες από μία τιμές από την JSON.
* Εξετάστε το ενδεχόμενο να αντιμετωπίζετε τα JSON αναλυθούν στο κατάποσης από δηλώνεται ο τύπος της στήλης για να είναι δυναμική.

### <a name="json-path-expressions"></a>Διαδρομή JSON παραστάσεις

|||
|---|---|
|`$`|Αντικείμενο ρίζας|
|`@`|Τρέχον αντικείμενο|
|`[0]`|Ο δείκτης πίνακα|
|`.`ή`[0]` | Θυγατρικό|

*(Θα σας δεν αυτήν τη στιγμή υλοποιήστε χαρακτήρες μπαλαντέρ, επανάληψη, Ένωσης ή φέτες.)*




### <a name="parsejson"></a>parsejson

Ερμηνεύει μια `string` ως [JSON τιμή](http://json.org/)) και επιστρέφει την τιμή ως `dynamic`. Είναι ανώτερη με τη χρήση του `extractjson()` όταν θέλετε να εξαγάγετε περισσότερα από ένα στοιχεία ενός αντικειμένου σύνθετης JSON.

**Σύνταξη**

    parsejson(json)

**Ορίσματα**

* *json:* Ένα έγγραφο JSON.

**Επιστρέφει**

Ένα αντικείμενο του τύπου `dynamic` που καθορίζεται από *json*.

**Παράδειγμα**

Στο παρακάτω παράδειγμα, όταν `context_custom_metrics` είναι μια `string` που μοιάζει κάπως έτσι: 

```
{"duration":{"value":118.0,"count":5.0,"min":100.0,"max":150.0,"stdDev":0.0,"sampledValue":118.0,"sum":118.0}}
```

στη συνέχεια, το παρακάτω τμήμα ανακτά την τιμή της το `duration` υποδιαίρεση στο αντικείμενο και, από το να ανακτά δύο υποδοχές, `duration.value` και  `duration.min` (`118.0` και `110.0`, αντίστοιχα).

```AIQL
T
| ...
| extend d=parsejson(context_custom_metrics) 
| extend duration_value=d.duration.value, duration_min=d["duration"]["min"]
```



### <a name="range"></a>περιοχή

Το `range()` συνάρτηση (δεν πρέπει να συγχέονται με το `range` τελεστή) δημιουργεί έναν δυναμικό πίνακα κρατώντας πατημένο το μια σειρά τιμών εξίσου-απόσταση μεταξύ τους.

**Σύνταξη**

    range(start, stop, step)

**Ορίσματα**

* *Έναρξη:* Η τιμή του πρώτου στοιχείου σε έναν πίνακα που προκύπτει. 
* *Διακοπή:* Την τιμή του τελευταίου στοιχείου σε έναν πίνακα που προκύπτει ή την ελάχιστη τιμή που είναι μεγαλύτερη από το τελευταίο στοιχείο του πίνακα που προκύπτει και μέσα σε έναν ακέραιο πολλαπλάσιο του *βήμα* από την *Έναρξη*.
* *βήμα:* Η διαφορά μεταξύ των δύο διαδοχικές στοιχεία του πίνακα.

**Παραδείγματα**

Το παρακάτω παράδειγμα επιστρέφει `[1, 4, 7]`:

```AIQL
range(1, 8, 3)
```

Το παρακάτω παράδειγμα επιστρέφει έναν πίνακα που κρατάει όλες τις ημέρες κατά το έτος 2015:

```AIQL

    range(datetime(2015-01-01), datetime(2015-12-31), 1d)
```

### <a name="todynamic"></a>todynamic

    todynamic('{"a":"a1", "b":["b1", "b2"]}')

Μετατρέπει μια συμβολοσειρά σε μια δυναμική τιμή.

### <a name="treepath"></a>treepath

    treepath(dynamic_object)

Απαριθμεί όλες τις παραστάσεις διαδρομή που προσδιορίζουν φύλλα σε ένα αντικείμενο δυναμικές. 

**Επιστρέφει**

Ένας πίνακας διαδρομή παραστάσεων.

**Παραδείγματα**

    treepath(parsejson('{"a":"b", "c":123}')) 
    =>       ["['a']","['c']"]
    treepath(parsejson('{"prop1":[1,2,3,4], "prop2":"value2"}'))
    =>       ["['prop1']","['prop1'][0]","['prop2']"]
    treepath(parsejson('{"listProperty":[100,200,300,"abcde",{"x":"y"}]}'))
    =>       ["['listProperty']","['listProperty'][0]","['listProperty'][0]['x']"]

Σημείωση που "[0]" υποδηλώνει την παρουσία ενός πίνακα, αλλά δεν καθορίζει το ευρετήριο που χρησιμοποιείται από μια συγκεκριμένη διαδρομή.

### <a name="zip"></a>zip

    zip(list1, list2, ...)

Συνδυάζει ένα σύνολο λιστών σε μία λίστα πλειάδων.

* `list1...`: Μια λίστα τιμών

**Παραδείγματα**

    zip(parsejson('[1,3,5]'), parsejson('[2,4,6]'))
    => [ [1,2], [3,4], [5,6] ]

    
    zip(parsejson('[1,3,5]'), parsejson('[2,4]'))
    => [ [1,2], [3,4], [5,null] ]


### <a name="names"></a>Ονόματα

Ονόματα μπορεί να είναι έως και 1024 χαρακτήρες. Μπορούν διάκριση πεζών-κεφαλαίων και μπορεί να περιέχει γράμματα, ψηφία και χαρακτήρες υπογράμμισης (`_`). 

Προσφορά ένα όνομα χρησιμοποιώντας ['... '] or [" ... "] για να συμπεριλάβετε άλλους χαρακτήρες ή να χρησιμοποιήσετε μια λέξη-κλειδί ως όνομα. Για παράδειγμα:

```AIQL

    requests | 
    summarize  ["distinct urls"] = dcount(name) // non-alphanumerics
    by  ['where'] = client_City, // using a keyword as a name
        ['outcome!'] = success // non-alphanumerics
```


|||
|---|---|
|[' διαδρομή\\file\n\'x\''] | Χρήση \ για να βγείτε χαρακτήρων|
|["d-e.=/f#\n"] | |
|[@'path\file'] | Δεν υπάρχει μεταβαίνει απευθείας - \ είναι ακριβές|
|[@"\now&, στη συνέχεια,\"] | |
|[όπου] | Χρησιμοποιώντας μια λέξη-κλειδί γλώσσα ως όνομα|

[AZURE.INCLUDE [app-insights-analytics-footer](../../includes/app-insights-analytics-footer.md)]


