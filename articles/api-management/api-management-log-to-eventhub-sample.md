<properties
    pageTitle="Παρακολούθηση σας APIs με Azure API διαχείρισης, το συμβάν διανομείς και Runscope"
    description="Δείγμα εφαρμογής που καταδεικνύουν την πολιτική καταγραφής-eventhub συνδετικές Azure API διαχείρισης, Azure συμβάν διανομείς και Runscope για HTTP καταγραφή και παρακολούθηση"
    services="api-management"
    documentationCenter=""
    authors="darrelmiller"
    manager="erikre"
    editor=""/>

<tags
    ms.service="api-management"
    ms.workload="mobile"
    ms.tgt_pltfrm="na"
    ms.devlang="dotnet"
    ms.topic="article"
    ms.date="10/25/2016"
    ms.author="darrmi"/>

# <a name="monitor-your-apis-with-azure-api-management-event-hubs-and-runscope"></a>Παρακολούθηση σας APIs με Azure API διαχείρισης, το συμβάν διανομείς και Runscope

Η [υπηρεσία API διαχείρισης](api-management-key-concepts.md) παρέχει πολλές δυνατότητες για να βελτιώσετε την επεξεργασία των αιτήσεων HTTP αποστέλλονται για το API HTTP. Ωστόσο, την ύπαρξη το προσκλήσεων και απαντήσεων είναι μεταβατικές. Πραγματοποιείται η αίτηση και να ρέει μέσω της υπηρεσίας διαχείρισης API για το API παρασκηνίου. Το API επεξεργάζεται την αίτηση και απόκριση ρέει προς τα πίσω σε στον καταναλωτή API. Η υπηρεσία διαχείρισης API διατηρεί ορισμένες σημαντικές στατιστικά στοιχεία σχετικά με τα API για εμφάνιση στο τον Publisher πύλης πίνακα εργαλείων, αλλά μετά από ότι, δεν εμφανίζονται οι λεπτομέρειες.

Με τη χρήση της [καταγραφής-eventhub](https://msdn.microsoft.com/library/azure/dn894085.aspx#log-to-eventhub) [πολιτικής](api-management-howto-policies.md) στην υπηρεσία API διαχείρισης μπορείτε να στείλετε όλες τις λεπτομέρειες από την αίτηση και την απόκριση με ένα [Διανομέα συμβάν Azure](../event-hubs/event-hubs-what-is-event-hubs.md). Υπάρχουν διάφορες αιτίες γιατί μπορεί να θέλετε να δημιουργήσετε συμβάντα από HTTP μηνύματα που αποστέλλονται προς το API. Ορισμένα παραδείγματα περιλαμβάνουν ίχνους ελέγχου ενημερώσεις, αναλυτικών στοιχείων χρήσης, ειδοποίησης εξαίρεσης και ενοποιήσεις τρίτου κατασκευαστή.   

Σε αυτό το άρθρο παρουσιάζει τον τρόπο για να καταγράψετε ολόκληρου HTTP αίτησης και απόκρισης του μηνύματος, στείλτε το με ένα διανομέα συμβάν και, στη συνέχεια, αναμετάδοσης αυτό το μήνυμα σε τρίτους υπηρεσία που παρέχει HTTP καταγραφή και παρακολούθηση των υπηρεσιών.

## <a name="why-send-from-api-management-service"></a>Γιατί να στείλω από την υπηρεσία διαχείρισης API;
Είναι δυνατό να συντάξετε το ενδιάμεσο HTTP που μπορεί να συνδέσετε σε πλαίσια HTTP API για να καταγράψετε HTTP προσκλήσεων και απαντήσεων και τροφοδοσίας τους σε καταγραφή και παρακολούθηση συστήματα. Το μειονέκτημα αυτής της προσέγγισης είναι το ενδιάμεσο HTTP πρέπει να είναι ενσωματωμένο στο υπόβαθρο API και πρέπει να συμφωνεί με την πλατφόρμα του API. Εάν υπάρχουν πολλά APIs κάθε μία πρέπει να αναπτύξετε το ενδιάμεσο. Συχνά υπάρχουν λόγοι για ποιο λόγο δεν μπορεί να ενημερωθεί παρασκηνίου APIs.

Με την υπηρεσία διαχείρισης API Azure ενσωμάτωση σε υποδομή καταγραφής παρέχει μια κεντρική και ανεξάρτητες πλατφόρμας λύση. Επίσης, είναι μεταβλητού μεγέθους, σε ένα τμήμα λόγω τις δυνατότητες [παν αναπαραγωγής](api-management-howto-deploy-multi-region.md) του Azure API διαχείρισης.

## <a name="why-send-to-an-azure-event-hub"></a>Γιατί να στείλω με ένα διανομέα συμβάν Azure;
Πρόκειται για ένα λογικό να υποβάλετε, γιατί να δημιουργήσετε μια πολιτική ειδικά για διανομείς συμβάν Azure; Υπάρχουν πολλές θέσεις όπου μπορεί να θέλω να συνδεθείτε προσκλήσεις μου. Γιατί δεν απλώς στείλτε τις αιτήσεις απευθείας με τον τελικό προορισμό;  Που είναι μια επιλογή. Ωστόσο, όταν πραγματοποιεί αιτήσεις καταγραφής από μια υπηρεσία διαχείρισης API, είναι απαραίτητο να εξετάσετε τον τρόπο καταγραφής μηνυμάτων θα επηρεάσουν την απόδοση του API. Σταδιακή αυξήσεων φόρτωσης αντιμετώπισης, αυξάνοντας διαθέσιμες παρουσίες στοιχείων του συστήματος ή να εκμεταλλευτείτε παν αναπαραγωγής. Ωστόσο, σύντομο αιχμές σε κίνηση μπορούν να προκαλέσουν αιτήσεις πρέπει να καθυστερήσει σημαντικά εάν αιτήσεις στην υποδομή καταγραφής αρχίσει να καθυστερεί φόρτος.

Οι διανομείς συμβάν Azure έχει σχεδιαστεί για εισόδου τεράστιες όγκους δεδομένων, με χωρητικότητα για χειρισμός άκρο υψηλότερο αριθμό συμβάντων από τον αριθμό των HTTP αιτήσεις περισσότερες APIs διαδικασία. Ο διανομέας συμβάν λειτουργεί ως ένα είδος εξελιγμένο buffer μεταξύ της υπηρεσίας διαχείρισης API και την υποδομή που θα αποθηκευτούν και επεξεργασία των μηνυμάτων. Αυτό εξασφαλίζει ότι οι επιδόσεις του API σας δεν θα υφίσταται λόγω της υποδομής καταγραφής.  

Όταν τα δεδομένα έχουν περάσει σε ένα συμβάν διανομέα, έχει διατηρηθεί και θα περιμένετε για καταναλωτές συμβάντων διανομέα επεξεργασίας του εγγράφου. Ο διανομέας συμβάν δεν ενδιαφέρεται πώς θα γίνεται επεξεργασία, το ενδιαφέρεται απλώς για να βεβαιωθείτε ότι το μήνυμα θα παραδοθεί με επιτυχία.     

Διανομείς συμβάν έχουν τη δυνατότητα να συμβάντα ροής σε πολλές ομάδες καταναλωτή. Αυτό σας επιτρέπει συμβάντα προς επεξεργασία, με εντελώς διαφορετική συστήματα. Αυτή η δυνατότητα επιτρέπει υποστήριξης πολλά σενάρια ενοποίησης, χωρίς να τοποθετείτε πρόσθεση καθυστερήσεις στην επεξεργασία της αίτησης API εντός της υπηρεσίας διαχείρισης API όπως μόνο ένα συμβάν πρέπει να δημιουργηθούν.

## <a name="a-policy-to-send-applicationhttp-messages"></a>Μια πολιτική για την αποστολή μηνυμάτων εφαρμογής/http
Ένα συμβάν διανομέα αποδέχεται δεδομένα συμβάντων ως απλό συμβολοσειρά. Τα περιεχόμενα αυτής της συμβολοσειράς εντελώς εξαρτώνται από εσάς. Για να μπορέσετε να συσκευάσετε προς τα επάνω μια αίτηση HTTP και στείλτε την με διανομείς συμβάν πρέπει να μορφοποιήσετε τη συμβολοσειρά με τις πληροφορίες αίτησης ή απόκρισης. Στις περιπτώσεις όπως αυτή, εάν υπάρχει μια υπάρχουσα μορφοποίηση θα σας να τη χρησιμοποιήσετε ξανά, στη συνέχεια, θα σας μπορεί να μην έχετε για να γράψετε τα δικά ανάλυση κώδικα μας. Αρχικά να θεωρούνται χρησιμοποιώντας το [HAR](http://www.softwareishard.com/blog/har-12-spec/) για την αποστολή HTTP προσκλήσεων και απαντήσεων. Ωστόσο, αυτή η μορφή είναι βελτιστοποιημένη για την αποθήκευση μιας ακολουθίας αιτήσεων HTTP σε μορφή JSON με βάση. Περιείχε έναν αριθμό υποχρεωτικό στοιχείων που προσθέσατε δεν είναι απαραίτητες πολυπλοκότητα για το σενάριο διέλευση του μηνύματος HTTP σε δίκτυο.  

Έχει μια εναλλακτική επιλογή για να χρησιμοποιήσετε το `application/http` τύπος μέσων, όπως περιγράφεται στην προδιαγραφή HTTP [RFC 7230](http://tools.ietf.org/html/rfc7230). Αυτόν τον τύπο μέσου χρησιμοποιεί την ακριβή ίδια μορφή που χρησιμοποιείται για να μπορέσουν να στείλετε μηνύματα HTTP μέσω σύρματος, αλλά ολόκληρο το μήνυμα μπορεί να τοποθετήσετε στο σώμα του άλλου αίτηση HTTP. Στην περίπτωσή μας θα σας μόλις πρόκειται να χρησιμοποιήσετε στο κυρίως σώμα ως μας μηνύματος για να στείλετε σε συμβάν διανομείς. Εύκολη, υπάρχει μια μονάδα ανάλυσης που υπάρχει στο [Microsoft ASP.NET API 2.2 προγράμματος-πελάτη Web](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) βιβλιοθήκες που μπορούν να ανάλυση αυτήν τη μορφή και μετατρέψτε τη σε τα εγγενή `HttpRequestMessage` και `HttpResponseMessage` αντικείμενα.

Για να μπορέσετε να δημιουργήσετε αυτό το μήνυμα πρέπει να εκμεταλλευτείτε C# βάσει [πολιτικής παραστάσεις](https://msdn.microsoft.com/library/azure/dn910913.aspx) Azure API διαχείρισης. Παρακάτω θα δείτε την πολιτική η οποία στέλνει ένα μήνυμα αίτηση HTTP σε διανομείς συμβάν Azure.

       <log-to-eventhub logger-id="conferencelogger" partition-id="0">
       @{
           var requestLine = string.Format("{0} {1} HTTP/1.1\r\n",
                                                       context.Request.Method,
                                                       context.Request.Url.Path + context.Request.Url.QueryString);

           var body = context.Request.Body?.As<string>(true);
           if (body != null && body.Length > 1024)
           {
               body = body.Substring(0, 1024);
           }

           var headers = context.Request.Headers
                                  .Where(h => h.Key != "Authorization" && h.Key != "Ocp-Apim-Subscription-Key")
                                  .Select(h => string.Format("{0}: {1}", h.Key, String.Join(", ", h.Value)))
                                  .ToArray<string>();

           var headerString = (headers.Any()) ? string.Join("\r\n", headers) + "\r\n" : string.Empty;

           return "request:"   + context.Variables["message-id"] + "\n"
                               + requestLine + headerString + "\r\n" + body;
       }
       </log-to-eventhub>

### <a name="policy-declaration"></a>Δήλωσης πολιτικής
Υπάρχουν μερικά πράγματα συγκεκριμένο αξίζει η αναφορά σχετικά με αυτήν την έκφραση πολιτικής. Η πολιτική καταγραφής-eventhub έχει ένα χαρακτηριστικό που ονομάζεται καταγραφής αναγνωριστικού που αναφέρεται στο όνομα του προγράμματος καταγραφής που έχει δημιουργηθεί εντός της υπηρεσίας διαχείρισης API. Μπορείτε να βρείτε τις λεπτομέρειες σχετικά με τον τρόπο ρύθμισης ενός καταγραφής συμβάντων διανομέας στην υπηρεσία API διαχείρισης στο έγγραφο [τον τρόπο για την καταγραφή συμβάντων με διανομείς συμβάν Azure Azure API διαχείρισης](api-management-howto-log-event-hubs.md). Το δεύτερο χαρακτηριστικό είναι μια προαιρετική παράμετρος που καθοδηγεί διανομείς συμβάντων που διαμερισμάτων για την αποθήκευση του μηνύματος σε. Συμβάν διανομείς Χρησιμοποιήστε τα διαμερίσματα για να ενεργοποιήσετε scalabilty και απαιτούν τουλάχιστον δύο. Η ταξινομημένη παράδοσης των μηνυμάτων είναι εγγυημένη μόνο μέσα σε ένα διαμερίσματα. Εάν δεν θα σας καθοδηγήσει διανομέα συμβάντος σε ποια διαμερίσματα για να τοποθετήσετε το μήνυμα, θα χρησιμοποιήσει έναν αλγόριθμο round robin για τη διανομή η φόρτωση. Ωστόσο, που μπορεί να προκαλέσει ορισμένα από τα μηνύματα για επεξεργασία εκτός σειράς.  

### <a name="partitions"></a>Τα διαμερίσματα
Για να βεβαιωθείτε ότι τα μηνύματα παραδίδονται στους καταναλωτές με τη σειρά και να επωφεληθείτε από τη δυνατότητα διανομής φόρτωσης των διαμερισμάτων, να επιλέξετε για να στείλετε μηνύματα αίτηση HTTP σε ένα διαμερίσματα και HTTP μηνύματα απάντησης σε μια δεύτερη διαμερίσματα. Αυτό θα εξασφαλίσει μια κατανομή ακόμα και φόρτωση και θα σας μπορεί να εξασφαλίσετε ότι όλες οι αιτήσεις θα καταναλωθεί στη σειρά και θα καταναλωθεί όλων των αποκρίσεων με τη σειρά. Είναι δυνατή η απόκριση να καταναλωθεί πριν από την αντίστοιχη αίτηση, αλλά ως που δεν είναι ένα πρόβλημα όπως έχουμε ζητά από ένα διαφορετικό μηχανισμό αντιστοιχίας απαντήσεων και γνωρίζουμε ότι αιτήσεις πάντοτε να προέρχονται πριν από τις απαντήσεις.

### <a name="http-payloads"></a>HTTP ωφέλιμα φορτία
Μετά τη δημιουργία του `requestLine` γίνεται έλεγχος για να δείτε εάν πρέπει να έχουν περικοπεί σώμα της αίτησης. Σώμα της αίτησης περικόπτεται, ώστε να μόνο 1024. Αυτό θα μπορούσε να αυξάνεται, ωστόσο μεμονωμένα μηνύματα συμβάντος διανομέα περιορίζονται σε 256KB, ώστε να είναι πιθανό ότι κάποιο μήνυμα HTTP οργανισμών θα δεν χωρά σε ένα μήνυμα. Όταν κάνετε καταγραφή και τις αναλύσεις σημαντική πληροφορίες μπορεί να προέρχεται από τα γραμμή αίτησης HTTP και κεφαλίδες. Επίσης, πολλές αιτήσεις API επιστρέφει μόνο μικρές οργανισμών και επομένως την απώλεια της τιμής πληροφορίες με περικοπή μεγάλων οργανισμών είναι αρκετά ελάχιστη σε σύγκριση με τη μείωση στο μεταφοράς, επεξεργασίας και αποθήκευσης κόστους για να διατηρήσετε όλα τα περιεχόμενα σώμα. Ένα ολοκληρωμένο σημείωση σχετικά με την επεξεργασία στο κυρίως σώμα είναι που πρέπει να περάσει `true` σε το As<string>μέθοδο () επειδή διαβάζετε τα περιεχόμενα σώμα, αλλά έχει επίσης θέλετε υπόβαθρο API για να μπορέσετε να διαβάσετε το σώμα. Περνώντας την τιμή TRUE σε αυτήν τη μέθοδο θα σας έχει ως αποτέλεσμα το σώμα να εγγραφούν σε buffer, έτσι ώστε να μπορεί να διαβαστεί δεύτερη φορά. Αυτό είναι σημαντικό να γνωρίζετε εάν έχετε ένα API που κάνει αποστολή των πολύ μεγάλα αρχεία ή χρησιμοποιεί πολύ ψηφοφορίας. Σε αυτές τις περιπτώσεις θα είναι καλύτερα να αποφύγετε την ανάγνωση σώμα σε όλα.   

### <a name="http-headers"></a>Κεφαλίδες HTTP
Κεφαλίδες HTTP μπορεί να μεταφερθεί απλώς μέσω σε της μορφής μηνύματος σε μορφή απλού κλειδιού/τιμής ζεύγος. Θα σας έχει επιλέξει να απαλλαγείτε από ορισμένα πεδία διάκριση πεζών-κεφαλαίων ασφαλείας, για να αποφύγετε άσκοπα διαρροή πληροφορίες διαπιστευτηρίων. Είναι πιθανό ότι κλειδιά API και άλλα διαπιστευτήρια θα χρησιμοποιηθεί για σκοπούς ανάλυσης. Εάν θα σας θέλετε να κάνετε ανάλυση για το χρήστη και το συγκεκριμένο προϊόν που χρησιμοποιούν, στη συνέχεια, θα μπορούσατε να αποκτήσω που από το `context` αντικείμενο και να προσθέσετε που το μήνυμα.     
### <a name="message-metadata"></a>Μήνυμα μετα-δεδομένων
Όταν δημιουργείτε το πλήρες μήνυμα για να στείλετε στο συμβάν διανομέα, στην πρώτη γραμμή δεν είναι στην πραγματικότητα μέρος του το `application/http` μήνυμα. Η πρώτη γραμμή είναι πρόσθετα μετα-δεδομένα που αποτελείται από εάν το μήνυμα είναι μια αίτηση ή μήνυμα απόκρισης και ένα αναγνωριστικό μήνυμα το οποίο χρησιμοποιείται για τη συσχέτιση των αιτήσεων σε απαντήσεις. Το αναγνωριστικό μηνύματος δημιουργείται χρησιμοποιώντας μια άλλη πολιτική, η οποία μοιάζει κάπως έτσι:

    <set-variable name="message-id" value="@(Guid.NewGuid())" />

Ενημερώνουμε μπορεί να έχετε δημιουργήσει το μήνυμα αίτησης, που αποθηκεύονται σε μεταβλητή μέχρι την απάντηση ήταν επιστρέφονται και, στη συνέχεια, απλώς σταλεί το αίτησης και απόκρισης ως ένα μήνυμα. Ωστόσο, αποστολή της αίτησης και της απόκρισης ανεξάρτητη και χρησιμοποιώντας ένα αναγνωριστικό μηνύματος για να συσχετίσετε δύο, λαμβάνουμε περισσότερη ευελιξία στη το μέγεθος του μηνύματος, η δυνατότητα για να επωφεληθείτε από περισσότερα από ένα διαμερίσματα ενώ τη διατήρηση σειρά μηνύματος και την αίτηση θα εμφανίζεται στο μας πίνακα εργαλείων καταγραφής αργά. Επίσης μπορεί να υπάρχουν ορισμένα σενάρια όπου μια έγκυρη απόκριση αποστέλλεται ποτέ την ενότητα συμβάντων, είναι δυνατόν να οφείλεται σε ένα σφάλμα ανεπανόρθωτης αίτηση στην υπηρεσία API διαχείρισης, αλλά εξακολουθείτε να έχουμε μια εγγραφή της αίτησης.

Την πολιτική για να στείλετε το μήνυμα απάντησης HTTP μοιάζει πολύ με την πρόσκληση σε και επομένως, η ρύθμιση παραμέτρων ολοκλήρωσης πολιτικής μοιάζει κάπως έτσι:

      <policies>
        <inbound>
            <set-variable name="message-id" value="@(Guid.NewGuid())" />
            <log-to-eventhub logger-id="conferencelogger" partition-id="0">
              @{
                  var requestLine = string.Format("{0} {1} HTTP/1.1\r\n",
                                                              context.Request.Method,
                                                              context.Request.Url.Path + context.Request.Url.QueryString);

                  var body = context.Request.Body?.As<string>(true);
                  if (body != null && body.Length > 1024)
                  {
                      body = body.Substring(0, 1024);
                  }

                  var headers = context.Request.Headers
                                       .Where(h => h.Key != "Authorization" && h.Key != "Ocp-Apim-Subscription-Key")
                                       .Select(h => string.Format("{0}: {1}", h.Key, String.Join(", ", h.Value)))
                                       .ToArray<string>();

                  var headerString = (headers.Any()) ? string.Join("\r\n", headers) + "\r\n" : string.Empty;

                  return "request:"   + context.Variables["message-id"] + "\n"
                                      + requestLine + headerString + "\r\n" + body;
              }
          </log-to-eventhub>
        </inbound>
        <backend>
            <forward-request follow-redirects="true" />
        </backend>
        <outbound>
            <log-to-eventhub logger-id="conferencelogger" partition-id="1">
              @{
                  var statusLine = string.Format("HTTP/1.1 {0} {1}\r\n",
                                                      context.Response.StatusCode,
                                                      context.Response.StatusReason);

                  var body = context.Response.Body?.As<string>(true);
                  if (body != null && body.Length > 1024)
                  {
                      body = body.Substring(0, 1024);
                  }

                  var headers = context.Response.Headers
                                                  .Select(h => string.Format("{0}: {1}", h.Key, String.Join(", ", h.Value)))
                                                  .ToArray<string>();

                  var headerString = (headers.Any()) ? string.Join("\r\n", headers) + "\r\n" : string.Empty;

                  return "response:"  + context.Variables["message-id"] + "\n"
                                      + statusLine + headerString + "\r\n" + body;
             }
          </log-to-eventhub>
        </outbound>
      </policies>

Το `set-variable` πολιτικής δημιουργεί μια τιμή που είναι προσβάσιμη από και τα δύο το `log-to-eventhub` πολιτικής στην το `<inbound>` ενότητας και το `<outbound>` ενότητας.  

## <a name="receiving-events-from-event-hubs"></a>Λαμβάνετε συμβάντα από διανομείς συμβάντος
Συμβάντα από διανομέα συμβάν Azure λαμβάνονται χρησιμοποιεί το [πρωτόκολλο AMQP](http://www.amqp.org/). Η ομάδα Bus υπηρεσίας Microsoft έχετε κάνει προγράμματος-πελάτη βιβλιοθήκες που είναι διαθέσιμες για να διευκολύνετε την καταναλώνει συμβάντα. Υπάρχουν δύο διαφορετικές μεθόδους που υποστηρίζονται, ένα γίνεται *Άμεση καταναλωτή* και το άλλο χρησιμοποιεί το `EventProcessorHost` τάξης. Παραδείγματα από αυτές τις δύο μεθόδους μπορείτε να βρείτε στον [Οδηγό προγραμματισμού συμβάντων διανομείς](../event-hubs/event-hubs-programming-guide.md). Η σύντομη έκδοση των διαφορών είναι, `Direct Consumer` έχετε πλήρη έλεγχο και την `EventProcessorHost` κάνει κάποιες από τις εργασίες υδραυλικών για να κάνει αλλά ορισμένες υποθέσεις σχετικά με τον τρόπο που θα επεξεργαστεί αυτά τα συμβάντα.  

### <a name="eventprocessorhost"></a>EventProcessorHost
Σε αυτό το δείγμα, θα χρησιμοποιήσουμε το `EventProcessorHost` για λόγους ευκολίας, ωστόσο το ενδέχεται να μην η καλύτερη επιλογή για αυτό το συγκεκριμένο σενάριο. `EventProcessorHost`κάνει τη σκληρή δουλειά του και βεβαιωθείτε ότι δεν χρειάζεται να ανησυχείτε σχετικά με θέματα μέσα σε ένα συγκεκριμένο συμβάν κλάσης επεξεργαστή τεχνολογία. Ωστόσο, σε μας το σενάριο, θα σας απλώς τη μετατροπή του μηνύματος σε άλλη μορφή και διοχέτευση κατά μήκος σε άλλη υπηρεσία χρησιμοποιώντας μια ασύγχρονη μέθοδο. Δεν χρειάζεται για την ενημέρωση κατάστασης κοινής χρήσης και, επομένως, δεν υπάρχει κίνδυνος νήματος θέματα. Για περισσότερα σενάρια, `EventProcessorHost` πιθανότατα είναι η καλύτερη επιλογή και σίγουρα είναι πιο εύκολη η επιλογή.     

### <a name="ieventprocessor"></a>IEventProcessor
Η κεντρική ιδέα κατά τη χρήση `EventProcessorHost` είναι να δημιουργήσετε μια μια εφαρμογή της το `IEventProcessor` περιβάλλοντος εργασίας που περιέχει τη μέθοδο `ProcessEventAsync`. Βασικά στοιχεία της αυτή τη μέθοδο, εμφανίζεται εδώ:

  ασύγχρονη {IEventProcessor.ProcessEventsAsync(PartitionContext context, IEnumerable<EventData> messages) εργασίας

           foreach (EventData eventData in messages)
           {
               _Logger.LogInfo(string.Format("Event received from partition: {0} - {1}", context.Lease.PartitionId,eventData.PartitionKey));

               try
               {
                   var httpMessage = HttpMessage.Parse(eventData.GetBodyStream());
                   await _MessageContentProcessor.ProcessHttpMessage(httpMessage);
               }
               catch (Exception ex)
               {
                   _Logger.LogError(ex.Message);
               }
           }
            ... checkpointing code snipped ...
        }

Μια λίστα των αντικειμένων EventData μεταβιβάζονται σε τη μέθοδο και θα σας διαδοχικές προσεγγίσεις μέσω αυτήν τη λίστα. Τα byte κάθε μεθόδου αναλύονται σε ένα αντικείμενο HttpMessage και αυτό το αντικείμενο που του μεταβιβάστηκε μια παρουσία του IHttpMessageProcessor.

### <a name="httpmessage"></a>HttpMessage
Το `HttpMessage` παρουσία περιέχει τρία τμήματα δεδομένων:

      public class HttpMessage
       {
           public Guid MessageId { get; set; }
           public bool IsRequest { get; set; }
           public HttpRequestMessage HttpRequestMessage { get; set; }
           public HttpResponseMessage HttpResponseMessage { get; set; }

        ... parsing code snipped ...

      }

Το `HttpMessage` παρουσία περιέχει ένα `MessageId` GUID που σας επιτρέπει να συνδεθείτε μια αίτηση HTTP με την αντίστοιχη απόκριση HTTP και μια τιμή boolean που προσδιορίζει αν το αντικείμενο περιέχει μια παρουσία μιας HttpRequestMessage και HttpResponseMessage. Με τη χρήση στο ενσωματωμένο σε κατηγορίες HTTP από `System.Net.Http`, να έχει δυνατότητα για να επωφεληθείτε από την `application/http` ανάλυση κώδικα που περιλαμβάνεται στο `System.Net.Http.Formatting`.  

### <a name="ihttpmessageprocessor"></a>IHttpMessageProcessor
Το `HttpMessage` παρουσία προωθείται, στη συνέχεια, στην εφαρμογή της `IHttpMessageProcessor` που είναι ένα περιβάλλον εργασίας να δημιουργήσει για να ξεχωρίζουμε η λήψη και ερμηνεία του συμβάντος από διανομέα συμβάν Azure και την πραγματική επεξεργασία του.


## <a name="forwarding-the-http-message"></a>Προώθηση του μηνύματος HTTP
Για αυτό το δείγμα, να αποφασίσει να μπορεί να είναι ενδιαφέρον για να προωθήσετε την αίτηση HTTP επάνω σε [Runscope](http://www.runscope.com). Runscope είναι μια υπηρεσία που βασίζεται στο cloud που εξειδικεύεται σε HTTP εντοπισμού, καταγραφή και παρακολούθηση. Έχουν μια δωρεάν σειρά, ώστε να είναι εύκολο να δοκιμάσετε και να επιτρέπει μας για να δείτε τις αιτήσεις HTTP στο σε πραγματικό χρόνο ροή μέσω της υπηρεσίας διαχείρισης API μας.

Το `IHttpMessageProcessor` υλοποίηση μοιάζει κάπως έτσι,

      public class RunscopeHttpMessageProcessor : IHttpMessageProcessor
       {
           private HttpClient _HttpClient;
           private ILogger _Logger;
           private string _BucketKey;
           public RunscopeHttpMessageProcessor(HttpClient httpClient, ILogger logger)
           {
               _HttpClient = httpClient;
               var key = Environment.GetEnvironmentVariable("APIMEVENTS-RUNSCOPE-KEY", EnvironmentVariableTarget.User);
               _HttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("bearer", key);
               _HttpClient.BaseAddress = new Uri("https://api.runscope.com");
               _BucketKey = Environment.GetEnvironmentVariable("APIMEVENTS-RUNSCOPE-BUCKET", EnvironmentVariableTarget.User);
               _Logger = logger;
           }

           public async Task ProcessHttpMessage(HttpMessage message)
           {
               var runscopeMessage = new RunscopeMessage()
               {
                   UniqueIdentifier = message.MessageId
               };

               if (message.IsRequest)
               {
                   _Logger.LogInfo("Sending HTTP request " + message.MessageId.ToString());
                   runscopeMessage.Request = await RunscopeRequest.CreateFromAsync(message.HttpRequestMessage);
               }
               else
               {
                   _Logger.LogInfo("Sending HTTP response " + message.MessageId.ToString());
                   runscopeMessage.Response = await RunscopeResponse.CreateFromAsync(message.HttpResponseMessage);
               }

               var messagesLink = new MessagesLink() { Method = HttpMethod.Post };
               messagesLink.BucketKey = _BucketKey;
               messagesLink.RunscopeMessage = runscopeMessage;
               var runscopeResponse = await _HttpClient.SendAsync(messagesLink.CreateRequest());
               _Logger.LogDebug("Request sent to Runscope");
           }
       }

Να έχει δυνατότητα για να επωφεληθείτε από μια [υπάρχουσα βιβλιοθήκη προγράμματος-πελάτη για Runscope](http://www.nuget.org/packages/Runscope.net.hapikit/0.9.0-alpha) που διευκολύνει την push `HttpRequestMessage` και `HttpResponseMessage` παρουσίες του στην υπηρεσία τους. Για να αποκτήσετε πρόσβαση το API Runscope θα χρειαστείτε έναν λογαριασμό και ένας αριθμός-κλειδί API. Οδηγίες για τη λήψη ενός αριθμού-κλειδιού API μπορείτε να βρείτε στο το σενάριο [Τη δημιουργία εφαρμογών Access Runscope API](http://blog.runscope.com/posts/creating-applications-to-access-the-runscope-api) .

## <a name="complete-sample"></a>Ολοκληρωμένο δείγμα
Το [πηγαίου κώδικα](https://github.com/darrelmiller/ApimEventProcessor) και δοκιμές για το δείγμα είναι σε Github. Θα χρειαστείτε μια [Υπηρεσία διαχείρισης API](api-management-get-started.md), [Ένα συνδεδεμένο διανομέα συμβάντος](api-management-howto-log-event-hubs.md), και ένα [Λογαριασμό χώρου αποθήκευσης](../storage/storage-create-storage-account.md) για να εκτελέσετε το δείγμα για τον εαυτό σας.   

Το δείγμα είναι απλώς μια απλή εφαρμογή κονσόλας που παρακολουθεί για συμβάντα που προέρχονται από το συμβάν διανομέα, μετατρέπει τους σε ένα `HttpRequestMessage` και `HttpResponseMessage` αντικείμενα και, στη συνέχεια, προωθεί τους με το API Runscope.

Στην παρακάτω εικόνα με κίνηση, μπορείτε να δείτε μια αίτηση που γίνονται σε ένα API στην πύλη του προγραμματιστή, η εφαρμογή κονσόλας που εμφανίζει το μήνυμα που λάβατε, υποβάλλονται σε επεξεργασία και προώθηση και, στη συνέχεια, το αίτησης και απόκρισης εμφανίζονται στις την επιθεώρηση Runscope κίνηση.

![Επίδειξη της αίτησης να προωθούνται σε Runscope](./media/api-management-log-to-eventhub-sample/apim-eventhub-runscope.gif)

## <a name="summary"></a>Σύνοψη
Azure υπηρεσίας API διαχείρισης παρέχει μια ιδανική θέση για να καταγράψετε την κυκλοφορία HTTP ταξιδεύουν από και προς την APIs. Azure διανομείς συμβάν είναι μια λύση ιδιαίτερα μεταβλητού μεγέθους, χαμηλό κόστος για την καταγραφή η κυκλοφορία και τροφοδοσία το στον δευτερεύοντα επεξεργασίας συστήματα για την καταγραφή, παρακολούθηση και άλλων απλούστερες ανάλυσης. Σύνδεση στο 3η πάρτι κίνηση συστημάτων όπως Runscope είναι μια απλή ως μερικά δωδεκάδα γραμμές κώδικα παρακολούθησης.

## <a name="next-steps"></a>Επόμενα βήματα
-   Μάθετε περισσότερα σχετικά με διανομείς συμβάν Azure
    -   [Γρήγορα αποτελέσματα με το Azure διανομείς συμβάντος](../event-hubs/event-hubs-csharp-ephcs-getstarted.md)
    -   [Λήψη μηνυμάτων με EventProcessorHost](../event-hubs/event-hubs-csharp-ephcs-getstarted.md#receive-messages-with-eventprocessorhost)
    -   [Οδηγός προγραμματισμού διανομείς συμβάντος](../event-hubs/event-hubs-programming-guide.md)
-   Μάθετε περισσότερα σχετικά με την ενοποίηση του API διαχείρισης και διανομείς συμβάντος
    -   [Πώς μπορείτε να συνδεθείτε συμβάντα διανομείς συμβάν Azure Azure API διαχείρισης](api-management-howto-log-event-hubs.md)
    -   [Αναφορά οντότητας καταγραφής](https://msdn.microsoft.com/library/azure/mt592020.aspx)
    -   [αναφορά αρχείου καταγραφής-eventhub πολιτικής](https://msdn.microsoft.com/library/azure/dn894085.aspx#log-to-eventhub)
    