<properties 
    pageTitle="Οδηγός για τη καθαρής # νευρικών δίκτυα προδιαγραφή γλώσσα | Microsoft Azure" 
    description="Σύνταξη για τη καθαρής # νευρικών δίκτυα προδιαγραφή γλώσσα, μαζί με παραδείγματα για τον τρόπο για να δημιουργήσετε ένα μοντέλο προσαρμοσμένο νευρικών δικτύου στο Microsoft Azure ML χρησιμοποιώντας καθαρής#" 
    services="machine-learning" 
    documentationCenter="" 
    authors="jeannt" 
    manager="jhubbard" 
    editor="cgronlun"/>

<tags 
    ms.service="machine-learning" 
    ms.workload="data-services" 
    ms.tgt_pltfrm="na" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.date="09/12/2016" 
    ms.author="jeannt"/>



# <a name="guide-to-net-neural-network-specification-language-for-azure-machine-learning"></a>Οδηγός για καθαρής # νευρικών δικτύου προδιαγραφή γλώσσας για Azure μηχανικής εκμάθησης

## <a name="overview"></a>Επισκόπηση
Καθαρής # είναι μια γλώσσα που αναπτύχθηκε από τη Microsoft και χρησιμοποιείται για να ορίσετε αρχιτεκτονικές νευρικών δικτύου για λειτουργικές μονάδες νευρικών δικτύου στο Microsoft Azure μηχανικής εκμάθησης. Σε αυτό το άρθρο, θα μάθετε:  

-   Βασικές έννοιες που σχετίζονται με νευρικών δίκτυα
-   Απαιτήσεις νευρικών δικτύου και πώς μπορείτε να ορίσετε τα βασικά στοιχεία
-   Η σύνταξη και λέξεις-κλειδιά της γλώσσας προδιαγραφή καθαρής #
-   Παραδείγματα προσαρμοσμένων νευρικών δίκτυα που δημιουργούνται με χρήση καθαρής# 
    
[AZURE.INCLUDE [machine-learning-free-trial](../../includes/machine-learning-free-trial.md)]  

## <a name="neural-network-basics"></a>Βασικά στοιχεία νευρικών δικτύου
Μια δομή νευρικών δικτύου αποτελείται από ***τους κόμβους*** που είναι οργανωμένα σε ***επίπεδα***, και σταθμισμένου ***συνδέσεις*** (ή ***ακμές***) μεταξύ τους κόμβους. Οι συνδέσεις βρίσκονται Οδικός και κάθε σύνδεση έχει έναν κόμβο ***προέλευσης*** και έναν κόμβο ***προορισμού*** .  

Κάθε ***trainable επιπέδου*** (ένα κρυφό ή ένα επίπεδο εξόδου) έχει ένα ή περισσότερα ***πακέτα σύνδεσης***. Μια δέσμη σύνδεσης αποτελείται από ένα επίπεδο προέλευσης και λεπτομέρειες σχετικά με τις συνδέσεις από αυτό το επίπεδο προέλευσης. Όλες τις συνδέσεις σε μια δεδομένη δέσμη κοινή χρήση του ίδιου ***επιπέδου προέλευσης*** και του ίδιου ***επιπέδου προορισμού***. Καθαρής #, μια δέσμη σύνδεσης θεωρείται ως που ανήκουν σε επίπεδο προορισμού της δέσμης.  
 
Καθαρής # υποστηρίζει διάφορα είδη σύνδεσης πακέτα, η οποία σας επιτρέπει να προσαρμόσετε το εισόδων τρόπο με τον οποίο έχουν αντιστοιχιστεί κρυφά επίπεδα και αντιστοιχιστεί εξόδους του.   

Η προεπιλεγμένη ή η τυπική δέσμη είναι ένα **πλήρες πακέτο**, όπου κάθε κόμβο στο επίπεδο προέλευσης είναι συνδεδεμένο σε κάθε κόμβο του επιπέδου προορισμού.  

Επιπλέον, καθαρής # υποστηρίζει τα παρακάτω είδη τέσσερις πακέτα σύνδεσης για προχωρημένους:  

-   **Πακέτα φιλτραρισμένη**. Ο χρήστης να καθορίσετε ένα κατηγόρημα, χρησιμοποιώντας τις θέσεις του κόμβου επιπέδου προέλευσης και ο κόμβος επιπέδου προορισμού. Οι κόμβοι συνδέονται κάθε φορά που το κατηγόρημα είναι True.
-   **Convolutional πακέτα**. Ο χρήστης να ορίσετε μικρές γειτονιές τους κόμβους στο επίπεδο προέλευσης. Κάθε κόμβο του επιπέδου προορισμού είναι συνδεδεμένο σε μία περιοχή της κόμβους στο επίπεδο προέλευσης.
-   **Συγκέντρωση πακέτα** και **πακέτα κανονικοποίηση απόκρισης**. Αυτά είναι παρόμοια με convolutional πακέτα σε που ο χρήστης ορίζει μικρές γειτονιές τους κόμβους στο επίπεδο προέλευσης. Η διαφορά είναι ότι τα βάρη των ακμών σε αυτά τα πακέτα δεν είναι trainable. Αντί για αυτό, μια προκαθορισμένη συνάρτηση εφαρμόζεται στις τιμές κόμβο προέλευσης για να καθορίσετε την τιμή κόμβο προορισμού.  

Χρήση καθαρής # για να ορίσετε τη δομή ενός δικτύου νευρικών δίνει τη δυνατότητα να ορίσετε σύνθετες δομές όπως βαθύ νευρικών δίκτυα ή convolutions αυθαίρετο διαστάσεων, η οποία είναι γνωστά για τη βελτίωση της εκμάθησης στα δεδομένα όπως εικόνας, ήχου ή βίντεο.  

## <a name="supported-customizations"></a>Υποστηριζόμενες προσαρμογές
Η αρχιτεκτονική της μοντέλα νευρικών δικτύου που δημιουργείτε στο Azure μηχανικής εκμάθησης μπορεί να προσαρμοστεί σε μεγάλο βαθμό με τη χρήση καθαρής #. Μπορείς:  

-   Δημιουργία κρυφά επίπεδα και να ελέγξετε τον αριθμό των κόμβους σε κάθε επίπεδο.
-   Καθορίστε πώς τα επίπεδα είναι να συνδεθούν μεταξύ τους.
-   Ορισμός ειδική συνδεσιμότητας δομές, όπως convolutions και πάχος κοινής χρήσης πακέτα.
-   Καθορίστε συναρτήσεων διαφορετικές ενεργοποίησης.  

Για λεπτομέρειες σχετικά με τη σύνταξη προδιαγραφή γλώσσας, ανατρέξτε στο θέμα [Προδιαγραφές δομή](#Structure-specifications).  
 
Για να δείτε παραδείγματα ορισμού νευρικών δίκτυα για ορισμένες κοινές μηχανικής εκμάθησης εργασίες, από μία όψη για σύνθετη, δείτε [παραδείγματα](#Examples-of-Net#-usage).  

## <a name="general-requirements"></a>Γενικές απαιτήσεις
-   Πρέπει να υπάρχει ακριβώς ένα αποτέλεσμα επιπέδου, τουλάχιστον μία εισαγωγής επιπέδου και κανέναν ή περισσότερους κρυφά επίπεδα. 
-   Κάθε επίπεδο έχει έναν σταθερό αριθμό κόμβους, εννοιολογικά τακτοποιημένα σε έναν πίνακα με ορθογώνια αυθαίρετο διαστάσεις. 
-   Επίπεδα εισαγωγής έχουν εκπαιδευθεί παραμέτρους που δεν σχετίζονται και αντιπροσωπεύει το σημείο όπου δεδομένα παρουσίας εισέρχεται στο δίκτυο. 
-   Trainable επίπεδα (τα επίπεδα κρυφό και εξόδου) έχουν συσχετιστεί εκπαιδευμένο παραμέτρους, γνωστό ως βάρη και βαθμονομήσεις. 
-   Οι κόμβοι προέλευσης και προορισμού πρέπει να είναι σε διαφορετικά επίπεδα. 
-   Συνδέσεις πρέπει να είναι μη κυκλικό; με άλλα λόγια, δεν είναι δυνατό να υπάρχει μια αλυσίδα των συνδέσεων αποτέλεσμα τον κόμβο αρχική προέλευση.
-   Το επίπεδο εξόδου δεν μπορεί να είναι ένα επίπεδο προέλευσης από μια δέσμη σύνδεσης.  

## <a name="structure-specifications"></a>Προδιαγραφές δομή
Προδιαγραφή δομή νευρικών δικτύου αποτελείται από τρεις ενότητες: η **δήλωση σταθεράς**, η **δήλωση επιπέδου**, η **δήλωση σύνδεσης**. Υπάρχει επίσης μια **κοινή χρήση δήλωσης** προαιρετική ενότητα. Οι ενότητες μπορούν να καθοριστούν με οποιαδήποτε σειρά.  

## <a name="constant-declaration"></a>Δήλωση σταθεράς 
Μια δήλωση σταθεράς είναι προαιρετικό. Παρέχει τη δυνατότητα να καθορίσετε τιμές που χρησιμοποιούνται σε κάποιο άλλο σημείο στον ορισμό νευρικών δικτύου. Η πρόταση δήλωσης αποτελείται από ένα αναγνωριστικό ακολουθούμενο από το σύμβολο της ισότητας και μια παράσταση τιμή.   

Για παράδειγμα, η ακόλουθη πρόταση καθορίζει μια σταθερά **x**:  


    Const X = 28;  

Για να ορίσετε ταυτόχρονα δύο ή περισσότερες σταθερές, περικλείετε τα ονόματα αναγνωριστικών και τις τιμές σε αγκύλες και διαχωρίστε τις με ερωτηματικά. Για παράδειγμα:  

    Const { X = 28; Y = 4; }  

Δεξιά πλευρά της κάθε ανάθεσης παράσταση μπορεί να είναι ένας ακέραιος, ένας πραγματικός αριθμός, μια δυαδική τιμή (True ή False) ή μια μαθηματική παράσταση. Για παράδειγμα:  

    Const { X = 17 * 2; Y = true; }  

## <a name="layer-declaration"></a>Δήλωση επιπέδου
Απαιτείται η δήλωση επιπέδου. Καθορίζει το μέγεθος και την προέλευση του επιπέδου, συμπεριλαμβανομένης της σύνδεσης πακέτα και χαρακτηριστικά. Η πρόταση δήλωσης ξεκινά με το όνομα του επιπέδου (εισόδου, κρυφά, ή εξόδου), ακολουθούμενο από τις διαστάσεις του επιπέδου (μιας πλειάδας θετικοί ακέραιοι). Για παράδειγμα:  

    input Data auto;
    hidden Hidden[5,20] from Data all;
    output Result[2] from Hidden all;  

-   Το γινόμενο των διαστάσεων είναι ο αριθμός των κόμβους στο επίπεδο. Σε αυτό το παράδειγμα, υπάρχουν δύο διαστάσεις [5,20], γεγονός που σημαίνει ότι υπάρχουν 100 κόμβους στο επίπεδο.
-   Τα επίπεδα μπορούν να δηλώνονται με οποιαδήποτε σειρά, με μία εξαίρεση: Εάν έχει οριστεί περισσότερα από ένα επίπεδα εισαγωγής, η σειρά με την οποία έχουν δηλωθεί ότι πρέπει να συμφωνεί με τη σειρά των δυνατοτήτων των εισαγόμενων δεδομένων.  


Για να καθορίσετε ότι ο αριθμός των κόμβους σε ένα επίπεδο καθορίζεται αυτόματα, χρησιμοποιήστε τη λέξη-κλειδί **αυτόματης** . Η λέξη-κλειδί **αυτόματης** περιλαμβάνει διάφορα εφέ, ανάλογα με το επίπεδο:  

-   Σε μια δήλωση εισαγωγής επιπέδου, τον αριθμό των κόμβοι είναι ο αριθμός των δυνατοτήτων των εισαγόμενων δεδομένων.
-   Σε μια δήλωση κρυφό επίπεδο, τον αριθμό των κόμβοι είναι ο αριθμός που καθορίζεται από την τιμή της παραμέτρου για τον **αριθμό των κρυφών κόμβους**. 
-   Σε μια δήλωση επιπέδου εξόδου, τον αριθμό των κόμβοι είναι 2 για ταξινόμηση δύο κατηγορίας, 1 για παλινδρόμησης και ίσο με τον αριθμό των κόμβους εξόδου για multiclass ταξινόμηση.   

Για παράδειγμα, το ακόλουθο ορισμό δικτύου επιτρέπει το μέγεθος του όλα τα επίπεδα που καθορίζεται αυτόματα:  

    input Data auto;
    hidden Hidden auto from Data all;
    output Result auto from Hidden all;  


Δήλωση επιπέδου για ένα επίπεδο trainable (τα επίπεδα κρυφών ή εξόδου) προαιρετικά μπορούν να περιλαμβάνουν το αποτέλεσμα συνάρτηση (ονομάζεται επίσης μια συνάρτηση ενεργοποίησης), η οποία από προεπιλογή **sigmoid** για μοντέλα κατάταξης και **γραμμικής** παλινδρόμησης μοντέλα. (Ακόμα και αν χρησιμοποιείτε την προεπιλεγμένη, που μπορούν να δηλώνουν ρητά τη συνάρτηση ενεργοποίησης, εάν θέλετε για σαφήνεια.)

Υποστηρίζονται οι παρακάτω συναρτήσεις εξόδου:  

-   sigmoid
-   Γραμμική
-   softmax
-   rlinear
-   τετράγωνο
-   η συνάρτηση SQRT
-   srlinear
-   ABS
-   TANH 
-   brlinear  

Για παράδειγμα, η ακόλουθη δήλωση χρησιμοποιεί τη συνάρτηση **softmax** :  

    output Result [100] softmax from Hidden all;  

## <a name="connection-declaration"></a>Δήλωση σύνδεσης
Αμέσως μετά τον ορισμό του trainable επιπέδου, πρέπει να δηλώσετε συνδέσεις μεταξύ των επιπέδων που έχετε ορίσει. Η δήλωση πακέτου σύνδεσης ξεκινά με τη λέξη-κλειδί **από**, ακολουθούμενο από το όνομα του επιπέδου προέλευσης τη δέσμη και το είδος του πακέτου σύνδεσης για να δημιουργήσετε.   

Προς το παρόν, υποστηρίζονται πέντε είδη πακέτα σύνδεσης:  

-   **Πλήρη** πακέτα, που υποδεικνύεται από τη λέξη-κλειδί **όλων**
-   Πακέτα **φιλτραρισμένη** , που υποδεικνύεται από τη λέξη-κλειδί **όπου**, ακολουθούμενο από μια παράσταση κατηγορήματος
-   Πακέτα **Convolutional** , που υποδεικνύεται από τη λέξη-κλειδί **convolve**, ακολουθούμενο από τα χαρακτηριστικά συνέλιξη
-   **Η ομαδοποίηση** πακέτα, που υποδεικνύεται από τις λέξεις-κλειδιά **μέγιστο** ή **σημαίνουν χώρου συγκέντρωσης**
-   Πακέτα **κανονικοποίηση απόκρισης** , που δηλώνεται με **απόκριση Σχεδιασμός** λέξεων-κλειδιών      

## <a name="full-bundles"></a>Πλήρη πακέτα  

Μια δέσμη πλήρη σύνδεση περιλαμβάνει μια σύνδεση από κάθε κόμβο στο επίπεδο προέλευσης σε κάθε κόμβο του επιπέδου προορισμού. Αυτό είναι ο προεπιλεγμένος τύπος σύνδεσης δικτύου.  

## <a name="filtered-bundles"></a>Φιλτραρισμένες πακέτα
Προδιαγραφή πακέτου φιλτραρισμένη σύνδεσης περιλαμβάνει ένα πολύ κατηγορήματος, εκφράζεται σύνταξη, όπως μια παράσταση λάμδα C#. Το παρακάτω παράδειγμα καθορίζει δύο φιλτραρισμένη πακέτα:  

    input Pixels [10, 20];
    hidden ByRow[10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol[5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;  

-   Στο κατηγόρημα για _ByRow_, **s** είναι μια παράμετρος που αντιπροσωπεύει ένα ευρετήριο σε έναν πίνακα ορθογώνια τους κόμβους του επιπέδου εισαγωγής, _Pixels_, και **d** είναι μια παράμετρο που αντιπροσωπεύει ένα ευρετήριο σε έναν πίνακα από κόμβους του κρυφού επιπέδου, _ByRow_. Ο τύπος της **s** και **d** είναι μιας πλειάδας ακεραίων μήκους δύο. Εννοιολογικά, **s** περιοχές επάνω από όλα τα ζεύγη ακέραιους αριθμούς με _0 < = s [0] < 10_ και _0 < =[1] s < 20_, και **d** περιοχές επάνω από όλα τα ζεύγη ακέραιους αριθμούς, με _0 < = d [0] < 10_ και _0 < = d[1] < 12_. 
-   Στη δεξιά πλευρά της παράστασης κατηγορήματος, υπάρχει μια συνθήκη. Σε αυτό το παράδειγμα, για κάθε τιμή της **s** και **d** τέτοια ώστε η συνθήκη είναι αληθής, υπάρχει μια κορνίζα από τον κόμβο επιπέδου προέλευσης στον κόμβο επιπέδου προορισμού. Επομένως, αυτή η παράσταση φίλτρου υποδεικνύει ότι το πακέτο περιλαμβάνει μια σύνδεση από τον κόμβο που ορίζονται από **s** για να τον κόμβο που ορίζονται από **d** σε όλες τις περιπτώσεις όπου s [0] είναι ίσο με d [0].  

Προαιρετικά, μπορείτε να καθορίσετε ένα σύνολο βάρους για μια φιλτραρισμένη δέσμη. Η τιμή για το χαρακτηριστικό **βάρους** πρέπει να είναι μιας πλειάδας από τιμές κινητής υποδιαστολής με μήκος που αντιστοιχεί στον αριθμό των συνδέσεων που ορίζονται από το πακέτο. Από προεπιλογή, δημιουργούνται τυχαία βάρους.  

Βάρος τιμές είναι ομαδοποιημένα κατά το ευρετήριο κόμβο προορισμού. Αυτό σημαίνει ότι, εάν ο πρώτος κόμβος προορισμού είναι συνδεδεμένη με κόμβους προέλευσης K, την πρώτη _K_ στοιχεία της πλειάδας **βάρους** είναι τα βάρη για τον πρώτο κόμβο προορισμού, με τη σειρά ευρετήριο προέλευσης. Το ίδιο ισχύει για τους υπόλοιπους κόμβους προορισμού.  

Είναι δυνατό να καθορίσετε βάρους απευθείας ως σταθερές τιμές. Για παράδειγμα, εάν μάθατε τα βάρη προηγουμένως, μπορείτε να τα καθορίσετε ως σταθερές χρησιμοποιώντας την παρακάτω σύνταξη:

    const Weights_1 = [0.0188045055, 0.130500451, ...]


## <a name="convolutional-bundles"></a>Convolutional πακέτα
Όταν τα δεδομένα εκπαίδευση έχει ομοιογενούς δομή, χρησιμοποιούνται συχνά convolutional συνδέσεις για να μάθετε δυνατότητες υψηλού επιπέδου των δεδομένων. Για παράδειγμα, στην εικόνα, ήχο ή βίντεο δεδομένα, χώρου ή χρονικό διαστατικότητα μπορεί να είναι αρκετά ενιαίο.  

Convolutional πακέτα χρησιμοποιούν ορθογώνια **πυρήνων** που τοποθετούνται στο μέσω των διαστάσεων. Ουσιαστικά, κάθε πυρήνα ορίζει ένα σύνολο βάρους εφαρμόζονται σε τοπική γειτονιές, γνωστή ως **πυρήνα εφαρμογές**. Κάθε εφαρμογή πυρήνα αντιστοιχεί σε έναν κόμβο στην το επίπεδο προέλευσης, το οποίο αναφέρεται ως τον **κεντρικό κόμβο**. Τα βάρη των πυρήνα είναι κοινόχρηστα για πολλές συνδέσεις. Σε μια δέσμη convolutional, κάθε πυρήνα είναι ορθογώνια και όλες τις εφαρμογές πυρήνα έχουν το ίδιο μέγεθος.  

Convolutional πακέτα υποστηρίζει τα παρακάτω χαρακτηριστικά:

**InputShape** Καθορίζει το διαστατικότητα του επιπέδου προέλευσης για τους σκοπούς της αυτό convolutional πακέτου. Η τιμή πρέπει να είναι μιας πλειάδας θετικό ακέραιους αριθμούς. Το γινόμενο των τους ακέραιους πρέπει να ισούται με τον αριθμό των κόμβους στο επίπεδο προέλευσης, αλλά σε διαφορετική περίπτωση, δεν χρειάζεται να ταιριάζει με το διαστατικότητα έχουν δηλωθεί για το επίπεδο προέλευσης. Το μήκος της πλειάδας αυτό γίνεται η τιμή **ορισμάτων** για το πακέτο convolutional. (Συνήθως ορισμάτων αναφέρεται στον αριθμό των ορισμάτων ή τελεστέων που μπορεί να διαρκέσει μια συνάρτηση.)  

Για να ορίσετε το σχήμα και τις θέσεις των το πυρήνων, χρησιμοποιήστε τα χαρακτηριστικά **KernelShape** **βήματος**, **Αναπλήρωση**, **LowerPad**και **UpperPad**:   

-   **KernelShape**: (απαιτείται) καθορίζει το διαστατικότητα κάθε πυρήνα για το πακέτο convolutional. Η τιμή πρέπει να είναι μιας πλειάδας θετικό ακεραίων με μήκος που ισούται με το πλήθος των ορισμάτων της της δέσμης. Κάθε στοιχείο πλειάδας αυτό πρέπει να είναι μεγαλύτερη από το αντίστοιχο στοιχείο του **InputShape**. 
-   **Βήματος**: (προαιρετικό) ορίζει τις διαστάσεις του κυλιόμενο βήμα της συνέλιξη (μέγεθος ένα βήμα για κάθε διάσταση), που είναι η απόσταση μεταξύ τους κόμβους κεντρική. Η τιμή πρέπει να είναι μιας πλειάδας θετικό ακεραίων με μήκος που είναι το πλήθος των ορισμάτων της της δέσμης. Κάθε στοιχείο πλειάδας αυτό πρέπει να είναι μεγαλύτερη από το αντίστοιχο στοιχείο του **KernelShape**. Η προεπιλεγμένη τιμή είναι μιας πλειάδας με όλα τα στοιχεία που είναι ίση με μία. 
-   **Κοινή χρήση**: (προαιρετικό) ορίζει το πάχος κοινής χρήσης για κάθε διάσταση από τα συνέλιξη. Η τιμή μπορεί να είναι μια μεμονωμένη τιμή Boolean ή μιας πλειάδας δυαδικών τιμών με μήκος που είναι το πλήθος των ορισμάτων της της δέσμης. Μια μεμονωμένη τιμή Boolean έχει επεκταθεί για να μιας πλειάδας το σωστό μήκος με όλα τα στοιχεία που είναι ίση με την καθορισμένη τιμή. Η προεπιλεγμένη τιμή είναι μιας πλειάδας που αποτελείται από όλες τις τιμές True. 
-   **MapCount**: (προαιρετικό) καθορίζει τον αριθμό της δυνατότητας χάρτες για το πακέτο convolutional. Η τιμή μπορεί να είναι ένα μεμονωμένο θετικό ακέραιο αριθμό ή μιας πλειάδας θετικό ακεραίων με μήκος που είναι το πλήθος των ορισμάτων της της δέσμης. Ένα μεμονωμένο ακέραια τιμή έχει επεκταθεί για να μιας πλειάδας το σωστό μήκος με τα στοιχεία του πρώτου ισούται με την καθορισμένη τιμή και όλα τα υπόλοιπα στοιχεία ισούται με μία. Η προεπιλεγμένη τιμή είναι ένα. Ο συνολικός αριθμός των δυνατοτήτων χάρτες είναι το προϊόν τα στοιχεία της πλειάδας. Το μορφής αυτόν τον συνολικό αριθμό κατά μήκος των στοιχείων καθορίζει τον τρόπο ομαδοποίησης των τιμών χάρτη δυνατότητα στον κόμβο προορισμού. 
-   **Βάρος**: (προαιρετικό) ορίζει το αρχικό βάρους για το πακέτο. Η τιμή πρέπει να είναι μιας πλειάδας κινητά σημείο τιμές με μήκος που είναι ο αριθμός των φορών που πυρήνων τον αριθμό των βάρους ανά πυρήνα, όπως ορίζεται παρακάτω σε αυτό το άρθρο. Η προεπιλεγμένη βάρους δημιουργούνται τυχαία.  

Υπάρχουν δύο σύνολα ιδιοτήτων που ελέγχουν αναπλήρωσης, οι ιδιότητες που αμοιβαία αποκλειόμενα:

-   **Αναπλήρωση**: (προαιρετικό) καθορίζει αν θα πρέπει να είναι επιπλέον την είσοδο χρησιμοποιώντας μια **προεπιλεγμένη αναπλήρωση συνδυασμού**. Η τιμή μπορεί να είναι μια μεμονωμένη τιμή Boolean ή μπορεί να είναι μιας πλειάδας δυαδικών τιμών με μήκος που είναι το πλήθος των ορισμάτων της της δέσμης. Μια μεμονωμένη τιμή Boolean έχει επεκταθεί για να μιας πλειάδας το σωστό μήκος με όλα τα στοιχεία που είναι ίση με την καθορισμένη τιμή. Εάν η τιμή για μια διάσταση είναι True, το αρχείο προέλευσης είναι επιπλέον λογικά σε αυτή τη διάσταση με με μηδέν τιμών κελιών για την υποστήριξη εφαρμογών επιπλέον πυρήνα, τέτοια ώστε η κεντρική από το πρώτο και το τελευταίο πυρήνων σε αυτή τη διάσταση είναι το πρώτο και το τελευταίο κόμβοι σε αυτή τη διάσταση στο επίπεδο προέλευσης. Επομένως, τον αριθμό των "εικονική" κόμβοι σε κάθε διάσταση καθορίζεται αυτόματα, ώστε να χωρά ακριβώς _(InputShape [d] - 1) / βήματος [d] + 1_ πυρήνων σε επίπεδο θήκη προέλευσης. Εάν η τιμή για μια διάσταση είναι False, η πυρήνων ορίζονται ώστε ο αριθμός των κόμβους σε κάθε πλευρά που παραμένουν ανάληψη είναι η ίδια (έως και διαφορά 1). Η προεπιλεγμένη τιμή αυτού του χαρακτηριστικού είναι μιας πλειάδας με όλα τα στοιχεία που είναι ίση με την τιμή False.
-   **UpperPad** και **LowerPad**: (προαιρετικό) παροχή μεγαλύτερο έλεγχο το ποσό της αναπλήρωσης για να χρησιμοποιήσετε. **Σημαντικό:** Αυτά τα χαρακτηριστικά μπορεί να οριστεί μόνο εάν είναι η ιδιότητα **Αναπλήρωση** παραπάνω ***δεν*** έχει οριστεί. Οι τιμές πρέπει να είναι πλειάδων ακεραίων με μήκη που είναι το πλήθος των ορισμάτων της της δέσμης. Όταν αυτά τα χαρακτηριστικά καθορίζονται, "εικονική" κόμβοι προστίθεται τα άκρα άνω και κάτω από κάθε διάσταση του επιπέδου εισαγωγής. Ο αριθμός των κόμβους προστεθεί τα άκρα άνω και κάτω από κάθε διάσταση προσδιορίζεται από **LowerPad**[i] και **UpperPad**[i] αντίστοιχα. Για να εξασφαλίσετε ότι πυρήνων αντιστοιχούν μόνο σε "Πραγματικό" κόμβους και να μην κόμβοι "εικονική", πρέπει να πληρούνται οι ακόλουθες συνθήκες:
    -   Κάθε στοιχείο του **LowerPad** πρέπει να είναι απολύτως λιγότερο από KernelShape [d] / 2. 
    -   Κάθε στοιχείο του **UpperPad** πρέπει να είναι μεγαλύτερη από το KernelShape [d] / 2. 
    -   Η προεπιλεγμένη τιμή από αυτά τα χαρακτηριστικά είναι μιας πλειάδας με όλα τα στοιχεία που είναι ίσο με 0. 

Η ρύθμιση **Αναπλήρωση** = true επιτρέπει όσο αναπλήρωση χρειάζεται για να διατηρήσετε το "Κέντρο" του πυρήνα μέσα "Πραγματικό" εισαγωγής. Αυτό αλλάζει τις μαθηματικές πράξεις λίγο για τον υπολογισμό του μεγέθους εξόδου. Γενικά, το μέγεθος του εξόδου _D_ υπολογίζεται ως _D = (I - K) / S + 1_, όπου _να_ είναι το μέγεθος εισόδου, _K_ είναι το μέγεθος του πυρήνα, _S_ είναι η μετατόπιση, και _/_ είναι ακέραιος διαίρεσης (στρογγυλοποίηση προς το μηδέν). Εάν ορίσετε UpperPad = [1, 1], το μέγεθος εισόδου _που_ είναι ουσιαστικά 29, και, επομένως, _D = (29-5) / 2 + 1 = 13_. Ωστόσο, όταν **Αναπλήρωση** = true, ουσιαστικά _να_ λαμβάνει χτυπηθεί προς τα επάνω κατά _K - 1_; ως εκ τούτου _D = ((28 + 4) - 5) / 2 + 1 = 27 / 2 + 1 = 13 + 1 = 14_. Κατά τον καθορισμό τιμών για **UpperPad** και **LowerPad** λαμβάνετε πολύ μεγαλύτερο έλεγχο της αναπλήρωσης από το εάν απλώς ορίστε **Αναπλήρωση** = true.

Για περισσότερες πληροφορίες σχετικά με τα δίκτυα convolutional και τις εφαρμογές, ανατρέξτε στα εξής άρθρα:  

-   [http://deeplearning.NET/Tutorial/lenet.HTML](http://deeplearning.net/tutorial/lenet.html )
-   [http://Research.Microsoft.com/Pubs/68920/icdar03.PDF](http://research.microsoft.com/pubs/68920/icdar03.pdf) 
-   [http://People.csail.MIT.edu/jvb/papers/cnn_tutorial.PDF](http://people.csail.mit.edu/jvb/papers/cnn_tutorial.pdf)  

## <a name="pooling-bundles"></a>Συγκέντρωση πακέτα
Μια **συγκέντρωση πακέτου** ισχύει γεωμετρική παρόμοια με convolutional συνδεσιμότητας, αλλά χρησιμοποιεί συναρτήσεις προκαθορισμένες τιμές κόμβο προέλευσης για τη δημιουργία της τιμής κόμβο προορισμού. Επομένως, ομαδοποίησης πακέτα έχουν χωρίς trainable κατάσταση (βάρους ή βαθμονομήσεις). Πακέτα ομαδοποίησης υποστηρίζει όλα τα χαρακτηριστικά convolutional εκτός από την **κοινή χρήση**, **MapCount**και **διαφορετικό πάχος**.  

Συνήθως, η πυρήνων συνοψίζονται οι μονάδες γειτονικά ομαδοποίησης δεν επικαλύπτονται. Εάν μετατόπιση [d] είναι ίση με KernelShape [d] από κάθε διάσταση, το επίπεδο που λαμβάνονται είναι η παραδοσιακή τοπική ομαδοποίησης επίπεδο, το οποίο χρησιμοποιείται συνήθως σε convolutional νευρικών δίκτυα. Κάθε κόμβο προορισμού τύπος υπολογίζει τη μέγιστη ή τον μέσο όρο των δραστηριοτήτων της το πυρήνα στο επίπεδο προέλευσης.  

Το ακόλουθο παράδειγμα δείχνει μια δέσμη ομαδοποίησης: 

    hidden P1 [5, 12, 12]
      from C1 max pool {
        InputShape  = [ 5, 24, 24];
        KernelShape = [ 1,  2,  2];
        Stride      = [ 1,  2,  2];
      }  

-   Το πλήθος των ορισμάτων της τη δέσμη είναι 3 (το μήκος του πλειάδων **InputShape** **KernelShape**και **βήματος**). 
-   Ο αριθμός των κόμβους στο επίπεδο προέλευσης είναι _5 *24* 24 = 2880_. 
-   Αυτό οφείλεται σε παραδοσιακά τοπικό επίπεδο ομαδοποίησης **KernelShape** και **βήματος** είναι ίσες. 
-   Ο αριθμός των κόμβους του επιπέδου προορισμού είναι _5 *12* 12 = 1440_.  
    
Για περισσότερες πληροφορίες σχετικά με τα επίπεδα ομαδοποίησης, ανατρέξτε στα εξής άρθρα:  

-   [http://www.CS.toronto.edu/~hinton/absps/imagenet.PDF](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf) (Ενότητα 3.4)
-   [http://CS.Nyu.edu/~koray/publis/lecun-iscas-10.PDF](http://cs.nyu.edu/~koray/publis/lecun-iscas-10.pdf) 
-   [http://CS.Nyu.edu/~koray/publis/jarrett-iccv-09.PDF](http://cs.nyu.edu/~koray/publis/jarrett-iccv-09.pdf)
    
## <a name="response-normalization-bundles"></a>Πακέτα κανονικοποίηση απόκρισης
**Κανονικοποίηση απόκρισης** είναι ένας συνδυασμός τοπικό κανονικοποίηση που παρουσιάστηκε για πρώτη φορά, Geoffrey Hinton, και συν στο χαρτί [ImageNet Classiﬁcation με πολλά επίπεδα Convolutional νευρικών δίκτυα](http://www.cs.toronto.edu/~hinton/absps/imagenet.pdf). Κανονικοποίηση απόκρισης χρησιμοποιείται για βοήθεια γενίκευσης στο νευρικών δίκτυα. Όταν ένα neuron ενεργοποιείται σε επίπεδο πολύ υψηλή ενεργοποίησης, ενός επιπέδου τοπικού απόκριση κανονικοποίηση αποκρύπτει το επίπεδο ενεργοποίησης του περιβάλλοντος neurons. Αυτό γίνεται με τη χρήση τρεις παράμετροι (***α***, ***β***και ***k***) και ένα convolutional δομή (ή περιοχή σχήμα). Κάθε neuron του επιπέδου προορισμού ***y*** αντιστοιχεί σε ένα neuron ***x*** στο επίπεδο προέλευσης. Το επίπεδο ενεργοποίησης του ***y*** δίνεται από τον παρακάτω τύπο, όπου ***f*** είναι το επίπεδο ενεργοποίησης μιας neuron και ***Nx*** είναι πυρήνα (ή το σύνολο που περιέχει το neurons στην περιοχή του ***x***), όπως ορίζεται από την ακόλουθη δομή convolutional:  

![][1]  

Απόκριση κανονικοποίηση πακέτα υποστηρίζει όλα τα χαρακτηριστικά convolutional εκτός από την **κοινή χρήση**, **MapCount**και **διαφορετικό πάχος**.  
 
-   Εάν το πυρήνα περιέχει neurons στο ίδιο χάρτη ως ***x***, το συνδυασμό κανονικοποίηση αναφέρεται ως **ίδια κανονικοποίηση χάρτη**. Για να ορίσετε την ίδια κανονικοποίηση χάρτη, το πρώτο συντεταγμένων στο **InputShape** πρέπει να έχει την τιμή 1.
-   Εάν το πυρήνα περιέχει neurons στην ίδια θέση χώρου ως ***x***, αλλά το neurons βρίσκονται σε άλλες αντιστοιχίσεις, το συνδυασμό κανονικοποίηση ονομάζεται **σε χάρτες κανονικοποίηση**. Αυτός ο τύπος απόκρισης κανονικοποίηση υλοποιεί μια μορφή πλευρική αναστολή έχοντας από τον τύπο που βρέθηκε στο πραγματικό neurons, τη δημιουργία ανταγωνισμό για μεγάλο ενεργοποίησης επίπεδα μεταξύ neuron εξόδους υπολογιστεί σε διαφορετική χάρτες. Για να ορίσετε σε χάρτες κανονικοποίηση, την πρώτη συντεταγμένων πρέπει να είναι ένας ακέραιος μεγαλύτερη από μία και δεν είναι μεγαλύτερο από τον αριθμό των χαρτών και τα υπόλοιπα τις συντεταγμένες πρέπει να έχει την τιμή 1.  

Επειδή η απόκριση κανονικοποίηση πακέτα εφαρμογή μιας προκαθορισμένης συνάρτησης σε τιμές κόμβο προέλευσης για να καθορίσετε την τιμή κόμβου προορισμού, έχουν χωρίς trainable κατάσταση (βάρους ή βαθμονομήσεις).   

**Ειδοποίηση**: τους κόμβους στο επίπεδο προορισμό αντιστοιχούν σε neurons που είναι το κεντρικό κόμβους το πυρήνων. Για παράδειγμα, εάν KernelShape [d] είναι περιττός, στη συνέχεια, _KernelShape [d] / 2_ αντιστοιχεί στον κόμβο κεντρικής πυρήνα. Εάν _KernelShape [d]_ είναι ακόμα, το κεντρικό κόμβο βρίσκεται στο _KernelShape [d] / 2-1_. Επομένως, εάν **Αναπλήρωση**[d] είναι False, το πρώτο και το τελευταίο _KernelShape [d] / 2_ κόμβους δεν έχουν αντίστοιχη κόμβους του επιπέδου προορισμού. Για να αποφύγετε κάτι τέτοιο, να ορίσετε **Αναπλήρωση** ως [τιμή true, true,..., την τιμή true].  

Εκτός από τα τέσσερα χαρακτηριστικά που περιγράφεται παραπάνω, πακέτα κανονικοποίηση απόκριση υποστηρίζουν επίσης τα εξής χαρακτηριστικά:  

-   **Άλφα**: (απαιτείται) καθορίζει μια τιμή κινητής υποδιαστολής που αντιστοιχεί στο ***α*** στο τον προηγούμενο τύπο. 
-   **Βήτα**: (απαιτείται) καθορίζει μια τιμή κινητής υποδιαστολής που αντιστοιχεί στον προηγούμενο τύπο ***β*** . 
-   **Μετατόπιση**: Καθορίζει (προαιρετικό) μια τιμή κινητής υποδιαστολής που αντιστοιχεί στον προηγούμενο τύπο ***k*** . Από προεπιλογή σε 1.  

Το παρακάτω παράδειγμα καθορίζει μια δέσμη κανονικοποίηση απόκρισης χρησιμοποιώντας τα εξής χαρακτηριστικά:  

    hidden RN1 [5, 10, 10]
      from P1 response norm {
        InputShape  = [ 5, 12, 12];
        KernelShape = [ 1,  3,  3];
        Alpha = 0.001;
        Beta = 0.75;
      }  

-   Το επίπεδο προέλευσης περιλαμβάνει πέντε χάρτες, κάθε μία με διάσταση aof 12 x 12, άθροισμα στον κόμβο 1440. 
-   Η τιμή **KernelShape** δηλώνει ότι αυτό είναι ένα ίδιο επίπεδο κανονικοποίηση χάρτη, όπου η περιοχή είναι ένα ορθογώνιο 3 x 3. 
-   **Αναπλήρωση** η προεπιλεγμένη τιμή είναι False, επομένως το επίπεδο προορισμού έχει μόνο 10 κόμβους σε κάθε διάσταση. Για να συμπεριλάβετε έναν κόμβο του επιπέδου προορισμού που αντιστοιχεί σε κάθε κόμβο στο επίπεδο προέλευσης, προσθέστε αναπλήρωση = [true; true, true]; και αλλάξτε το μέγεθος του RN1 [5, 12; 12].  

## <a name="share-declaration"></a>Κοινή χρήση δήλωσης 
Καθαρής # προαιρετικά υποστηρίζει τον ορισμό πολλών πακέτα με κοινόχρηστη βάρους. Τα βάρη των οποιαδήποτε δύο πακέτα μπορεί να είναι κοινόχρηστο, εάν τους δομές είναι ίδιες. Την ακόλουθη σύνταξη ορίζει πακέτα με κοινόχρηστη βάρους:  

    share-declaration:
        share    {    layer-list    }
        share    {    bundle-list    }
       share    {    bias-list    }
    
    layer-list:
        layer-name    ,    layer-name
        layer-list    ,    layer-name
    
    bundle-list:
       bundle-spec    ,    bundle-spec
        bundle-list    ,    bundle-spec
    
    bundle-spec:
       layer-name    =>     layer-name
    
    bias-list:
        bias-spec    ,    bias-spec
        bias-list    ,    bias-spec
    
    bias-spec:
        1    =>    layer-name
    
    layer-name:
        identifier  

Για παράδειγμα, η ακόλουθη δήλωση κοινή χρήση καθορίζει τα ονόματα των επιπέδων, που υποδεικνύει ότι πρέπει να είναι κοινόχρηστη βάρους και βαθμονομήσεις:  

    Const {
      InputSize = 37;
      HiddenSize = 50;
    }
    input {
      Data1 [InputSize];
      Data2 [InputSize];
    }
    hidden {
      H1 [HiddenSize] from Data1 all;
      H2 [HiddenSize] from Data2 all;
    }
    output Result [2] {
      from H1 all;
      from H2 all;
    }
    share { H1, H2 } // share both weights and biases  

-   Οι δυνατότητες εισαγωγής δημιουργούνται διαμερίσματα σε δύο ίσες επίπεδα ισομεγέθεις εισαγωγής. 
-   Τα κρυφά επίπεδα πρέπει να υπολογίσετε ανώτερο επίπεδο δυνατότητες στα δύο επίπεδα εισόδου. 
-   Η κοινή χρήση δήλωση Καθορίζει ότι πρέπει να υπολογιστεί το _Η1_ και _H2_ με τον ίδιο τρόπο από τους αντίστοιχους εισροές.  
 
Εναλλακτικά, αυτό θα μπορούσε να έχει καθοριστεί με δύο ξεχωριστές δηλώσεις κοινή χρήση ως εξής:  

    share { Data1 => H1, Data2 => H2 } // share weights  

<!-- -->

    share { 1 => H1, 1 => H2 } // share biases  

Μπορείτε να χρησιμοποιήσετε τη σύντομη μορφή μόνο όταν τα επίπεδα που περιέχει μια μεμονωμένη δέσμη. Σε γενικές γραμμές, η κοινή χρήση είναι δυνατή μόνο όταν το σχετικό δομή είναι πανομοιότυπες, γεγονός που σημαίνει ότι έχουν το ίδιο μέγεθος, ίδιο convolutional γεωμετρική και ούτω καθεξής.  

## <a name="examples-of-net-usage"></a>Παραδείγματα χρήσης καθαρής #
Αυτή η ενότητα παρέχει ορισμένα παραδείγματα πώς μπορείτε να χρησιμοποιήσετε καθαρής # για να προσθέσετε κρυφά επίπεδα, να ορίσετε τον τρόπο που κρυφά επίπεδα αλληλεπίδραση με άλλα επίπεδα και να δομήσετε convolutional δίκτυα.   

### <a name="define-a-simple-custom-neural-network-hello-world-example"></a>Ορισμός ένα απλό δίκτυο προσαρμοσμένο νευρικών: παράδειγμα "Γεια"
Αυτό το απλό παράδειγμα δείχνει πώς μπορείτε να δημιουργήσετε ένα μοντέλο νευρικών δικτύου που έχει ένα μεμονωμένο κρυφό επίπεδο.  

    input Data auto;
    hidden H [200] from Data all;
    output Out [10] sigmoid from H all;  

Το παράδειγμα παρουσιάζει ορισμένες βασικές εντολές ως εξής:  

-   Η πρώτη γραμμή καθορίζει το επίπεδο εισόδου (ονομάζονται _δεδομένων_). Όταν χρησιμοποιείτε τη λέξη-κλειδί **αυτόματης** , το δίκτυο νευρικών περιλαμβάνει αυτόματα όλες τις στήλες δυνατότητα στα παραδείγματα εισαγωγής. 
-   Η δεύτερη γραμμή δημιουργεί το κρυφό επίπεδο. Το όνομα _H_ αντιστοιχίζεται το κρυφό επίπεδο, το οποίο έχει 200 κόμβους. Αυτό το επίπεδο πλήρως είναι συνδεδεμένο με το επίπεδο εισόδου.
-   Η τρίτη γραμμή καθορίζει το αποτέλεσμα επίπεδο (ονομάζονται _O_), το οποίο περιέχει 10 κόμβους εξόδου. Εάν το δίκτυο νευρικών χρησιμοποιείται για την ταξινόμηση, υπάρχει έναν κόμβο εξόδου ανά τάξης. Η λέξη-κλειδί **sigmoid** υποδεικνύει ότι η συνάρτηση εξόδου εφαρμόζεται στο επίπεδο εξόδου.   

### <a name="define-multiple-hidden-layers-computer-vision-example"></a>Ορισμός πολλών κρυφά επίπεδα: παράδειγμα όραση υπολογιστή
Το παρακάτω παράδειγμα παρουσιάζει τον τρόπο για να ορίσετε μια ελαφρώς πιο σύνθετες νευρικών δίκτυο, με πολλές προσαρμοσμένες κρυφά επίπεδα.  

    // Define the input layers 
    input Pixels [10, 20];
    input MetaData [7];
    
    // Define the first two hidden layers, using data only from the Pixels input
    hidden ByRow [10, 12] from Pixels where (s,d) => s[0] == d[0];
    hidden ByCol [5, 20] from Pixels where (s,d) => abs(s[1] - d[1]) <= 1;
    
    // Define the third hidden layer, which uses as source the hidden layers ByRow and ByCol
    hidden Gather [100] 
    {
      from ByRow all;
      from ByCol all;
    }
    
    // Define the output layer and its sources
    output Result [10]  
    {
      from Gather all;
      from MetaData all;
    }  

Αυτό το παράδειγμα παρουσιάζει διάφορες δυνατότητες της γλώσσας προδιαγραφή νευρικών δίκτυα:  

-   Η δομή έχει δύο επίπεδα εισαγωγής, _pixel_ και _μετα-δεδομένων_.
-   Το επίπεδο _Pixels_ είναι ένα επίπεδο προέλευσης για δύο πακέτα σύνδεσης, με τα επίπεδα προορισμού, _ByRow_ και _ByCol_.
-   Τα επίπεδα _συγκέντρωση_ και το _αποτέλεσμα_ είναι επίπεδα προορισμού σε πολλά πακέτα σύνδεσης.
-   Το επίπεδο εξόδου, _αποτέλεσμα_, είναι ένα επίπεδο προορισμού σε δύο πακέτα σύνδεσης; μία με το δεύτερο επιπέδου κρυφών (Συγκεντρώστε) ως επίπεδο προορισμού, και το άλλο με το επίπεδο εισόδου (μετα-δεδομένα) ως επίπεδο προορισμού.
-   Τα κρυφά επίπεδα, _ByRow_ και _ByCol_, καθορίστε φιλτραρισμένη συνδεσιμότητας με τη χρήση κατηγορήματος παραστάσεις. Μεγαλύτερη ακρίβεια, ο κόμβος στο _ByRow_ στο [x, y] είναι συνδεδεμένη με τους κόμβους σε _pixel_ που έχουν την πρώτη συντεταγμένων ευρετηρίου ισούται με τον κόμβο πρώτη συντεταγμένων, x. Ομοίως, ο κόμβος στο _ByCol στο [x, y] είναι συνδεδεμένη με τους κόμβους σε _pixel_ που έχει το δεύτερο ευρετήριο συντονισμό μέσα σε ένα από τον κόμβο δεύτερο συντεταγμένων, y.  

### <a name="define-a-convolutional-network-for-multiclass-classification-digit-recognition-example"></a>Ορισμός δίκτυο convolutional για multiclass κατάταξη: παράδειγμα αναγνώριση ψηφίο
Τον ορισμό του παρακάτω δικτύου έχει σχεδιαστεί για να αναγνωρίζουν αριθμούς και παρουσιάζει ορισμένες προηγμένες τεχνικές για την προσαρμογή ενός νευρικών δικτύου.  

    input Image [29, 29];
    hidden Conv1 [5, 13, 13] from Image convolve 
    {
       InputShape  = [29, 29];
       KernelShape = [ 5,  5];
       Stride      = [ 2,  2];
       MapCount    = 5;
    }
    hidden Conv2 [50, 5, 5]
    from Conv1 convolve 
    {
       InputShape  = [ 5, 13, 13];
       KernelShape = [ 1,  5,  5];
       Stride      = [ 1,  2,  2];
       Sharing     = [false, true, true];
       MapCount    = 10;
    }
    hidden Hid3 [100] from Conv2 all;
    output Digit [10] from Hid3 all;  


-   Η δομή έχει ένα μόνο επίπεδο εισαγωγής _εικόνας_.
-   Η λέξη-κλειδί **convolve** υποδεικνύει ότι τα επίπεδα που ονομάζεται _Conv1_ και _Conv2_ convolutional επίπεδα. Κάθε μία από αυτές τις δηλώσεις επιπέδου ακολουθείται από μια λίστα με τα χαρακτηριστικά συνέλιξη.
-   Η καθαρή έχει έναν τρίτο κρυφά επιπέδου, _Hid3_, που είναι πλήρως συνδεδεμένη με το δεύτερο κρυφό επίπεδο, _Conv2_.
-   Το επίπεδο εξόδου, _ψηφίο_, είναι συνδεδεμένος μόνο για το τρίτο επίπεδο κρυφά, _Hid3_. Η λέξη-κλειδί **όλα** υποδεικνύει ότι το επίπεδο εξόδου είναι συνδεδεμένος πλήρως _Hid3_.
-   Το πλήθος των ορισμάτων της τα συνέλιξη είναι τρία (το μήκος του πλειάδων **InputShape**, **KernelShape**, **βήματος**και **κοινή χρήση**). 
-   Ο αριθμός των βάρους ανά πυρήνα είναι _1 + **KernelShape**\[0] * * *KernelShape**\[1]* **KernelShape**\[2] = 1 + 1 *5* 5 = 26. Ή 26 * 50 = 1300_.
-   Μπορείτε να υπολογίσετε τους κόμβους κάθε κρυφό επίπεδο ως εξής:
    -   **NodeCount**\[0] = (5 - 1) / 1 + 1 = 5.
    -   **NodeCount**\[1] = (13-5) / 2 + 1 = 5. 
    -   **NodeCount**\[2] = (13-5) / 2 + 1 = 5. 
-   Ο συνολικός αριθμός των κόμβοι μπορεί να υπολογιστεί, χρησιμοποιώντας τη δήλωση διαστατικότητα του επιπέδου, [50, 5, 5], ως εξής: _ **MapCount** * * *NodeCount**\[0]* **NodeCount**\[1] * * *NodeCount**\[2] = 10* 5 *5* 5_
-   Επειδή η **κοινή χρήση**[d] είναι False μόνο για _d == 0_, είναι ο αριθμός των πυρήνων _ **MapCount** * * *NodeCount**\[0] = 10* 5 = 50_. 


## <a name="acknowledgements"></a>Επιβεβαίωση

Η γλώσσα καθαρής # για την προσαρμογή της η αρχιτεκτονική της νευρικών δίκτυα αναπτύχθηκε στο Microsoft Shon Katzenberger (Αρχιτέκτονας, μηχανικής εκμάθησης) και Alexey Kamenev (μηχανικό λογισμικού, Microsoft Research). Χρησιμοποιείται εσωτερικά για μηχανικής εκμάθησης έργα και τις εφαρμογές μεταξύ του εντοπισμού εικόνα κειμένου ανάλυσης. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [Νευρικών δίκτυα σε ML Azure - εισαγωγή στα καθαρής #](http://blogs.technet.com/b/machinelearning/archive/2015/02/16/neural-nets-in-azure-ml-introduction-to-net.aspx)


[1]:./media/machine-learning-azure-ml-netsharp-reference-guide/formula_large.gif
 
