<properties
    pageTitle="Λίστα πόρων Azure αποθήκευσης με τη βιβλιοθήκη προγράμματος-πελάτη του Microsoft Azure χώρου αποθήκευσης για C++ | Microsoft Azure"
    description="Μάθετε πώς μπορείτε να χρησιμοποιήσετε την καταχώρηση APIs στη βιβλιοθήκη προγράμματος-πελάτη του Microsoft Azure χώρου αποθήκευσης για C++ απαρίθμηση κοντέινερ, αντικείμενα blob, ουρές, πίνακες και οντοτήτων."
    documentationCenter=".net"
    services="storage"
    authors="dineshmurthy"
    manager="jahogg"
    editor="tysonn"/>
<tags
    ms.service="storage"
    ms.workload="storage"
    ms.tgt_pltfrm="na"
    ms.devlang="na"
    ms.topic="article"
    ms.date="10/18/2016"
    ms.author="dineshm"/>

# <a name="list-azure-storage-resources-in-c"></a>Λίστα πόρων Azure αποθήκευσης σε C++

Καταχώρηση λειτουργίες είναι σε πολλά σενάρια ανάπτυξη με το χώρο αποθήκευσης Azure αριθμού-κλειδιού. Σε αυτό το άρθρο περιγράφει τον τρόπο πιο αποτελεσματικά απαρίθμηση αντικειμένων στο χώρο αποθήκευσης Azure χρησιμοποιώντας την καταχώρηση APIs που παρέχονται στη βιβλιοθήκη προγράμματος-πελάτη του Microsoft Azure χώρου αποθήκευσης για C++.

>[AZURE.NOTE] Αυτός ο οδηγός έχει ως προορισμό τη βιβλιοθήκη Azure χώρου αποθήκευσης του προγράμματος-πελάτη για C++ έκδοση 2.x, το οποίο είναι διαθέσιμο μέσω [NuGet](http://www.nuget.org/packages/wastorage) ή [GitHub](https://github.com/Azure/azure-storage-cpp).

Η βιβλιοθήκη προγράμματος-πελάτη του χώρου αποθήκευσης παρέχει διάφορες μεθόδους για λίστα ή το ερώτημα αντικείμενα στο χώρο αποθήκευσης Azure. Σε αυτό το άρθρο αντιμετωπίζει τα ακόλουθα σενάρια:

-   Λίστα κοντέινερ σε ένα λογαριασμό
-   Αντικείμενα BLOB λίστα σε ένα κοντέινερ ή εικονικού blob καταλόγου
-   Λίστα ουρές σε ένα λογαριασμό
-   Λίστα πίνακες σε ένα λογαριασμό
-   Ερώτημα οντοτήτων σε έναν πίνακα

Κάθε μία από τις παρακάτω μεθόδους εμφανίζεται με τη χρήση διαφορετικοί τύποι για διαφορετικά σενάρια.

## <a name="asynchronous-versus-synchronous"></a>Ασύγχρονη έναντι σύγχρονη

Επειδή η βιβλιοθήκη προγράμματος-πελάτη χώρου αποθήκευσης για C++ είναι ενσωματωμένο επάνω από τη [βιβλιοθήκη C++ ΥΠΌΛΟΙΠΑ](https://github.com/Microsoft/cpprestsdk), υποστηρίζουμε εγγενώς ασύγχρονων λειτουργιών με τη χρήση [pplx::task](http://microsoft.github.io/cpprestsdk/classpplx_1_1task.html). Για παράδειγμα:

    pplx::task<list_blob_item_segment> list_blobs_segmented_async(continuation_token& token) const;

Σύγχρονη λειτουργίες αναδίπλωση τις αντίστοιχες ασύγχρονης λειτουργίες:

    list_blob_item_segment list_blobs_segmented(const continuation_token& token) const
    {
        return list_blobs_segmented_async(token).get();
    }

Εάν εργάζεστε με πολλά πολυνηματική επεξεργασία εφαρμογές ή υπηρεσίες, συνιστάται να χρησιμοποιήσετε το ασύγχρονης APIs απευθείας αντί να δημιουργήσετε ένα νήμα για να καλέσετε τον συγχρονισμό API, η οποία σημαντικά επηρεάζει την απόδοση της.

## <a name="segmented-listing"></a>Τμηματική καταχώρηση

Η κλίμακα του χώρο αποθήκευσης στο cloud απαιτεί τμηματική καταχώρηση. Για παράδειγμα, μπορείτε να έχετε πάνω από ένα εκατομμύριο αντικείμενα BLOB σε ένα κοντέινερ αντικειμένων blob του Azure ή πάνω από ένα δισεκατομμύριο οντοτήτων σε έναν πίνακα του Azure. Δεν υπάρχουν θεωρητική αριθμούς, αλλά υποθέσεις χρήση πραγματικό πελατών.

Επομένως, δεν είναι πρακτικό για μια λίστα όλων των αντικειμένων σε μια μεμονωμένη απάντηση. Αντί για αυτό, μπορείτε να παραθέσετε τα αντικείμενα που χρησιμοποιούν σελιδοποίησης. Κάθε καταχώρηση APIs έχει μια *φέρουν κατά διαστήματα* υπερφόρτωσης.

Η απόκριση για μια λειτουργία τμηματική καταχώρηση περιλαμβάνει τα εξής:

-   <i>_segment</i>, που περιέχει το σύνολο των αποτελεσμάτων που επιστρέφονται για κλήση μόνο για το API καταχώρηση.
-   *continuation_token*, που μεταβιβάζεται στην επόμενη κλήση για να λάβετε την επόμενη σελίδα αποτελεσμάτων. Όταν υπάρχουν περισσότερα αποτελέσματα για να επιστρέψετε, το διακριτικό συνέχισης είναι null.

Για παράδειγμα, μια τυπική κλήση για μια λίστα όλων των BLOB σε ένα κοντέινερ μπορεί να μοιάζει με το παρακάτω τμήμα κώδικα. Ο κώδικας είναι διαθέσιμες στο μας [δείγματα](https://github.com/Azure/azure-storage-cpp/blob/master/Microsoft.WindowsAzure.Storage/samples/BlobsGettingStarted/Application.cpp):

    // List blobs in the blob container
    azure::storage::continuation_token token;
    do
    {
        azure::storage::list_blob_item_segment segment = container.list_blobs_segmented(token);
        for (auto it = segment.results().cbegin(); it != segment.results().cend(); ++it)
    {
        if (it->is_blob())
        {
            process_blob(it->as_blob());
        }
        else
        {
            process_diretory(it->as_directory());
        }
    }

        token = segment.continuation_token();
    }
    while (!token.empty());

Σημειώστε ότι ο αριθμός των αποτελεσμάτων που επιστρέφονται σε μια σελίδα μπορεί να ελέγχεται από την παράμετρο *max_results* στο το υπερφόρτωσης του κάθε API, για παράδειγμα:

    list_blob_item_segment list_blobs_segmented(const utility::string_t& prefix, bool use_flat_blob_listing,
        blob_listing_details::values includes, int max_results, const continuation_token& token,
        const blob_request_options& options, operation_context context)

Εάν δεν καθορίσετε την παράμετρο *max_results* , επιστρέφεται η προεπιλεγμένη μέγιστη τιμή έως 5000 αποτελεσμάτων σε μία σελίδα.

Επίσης, σημειώστε ότι ένα ερώτημα σε σχέση με το χώρο αποθήκευσης πινάκων του Azure ενδέχεται να επιστρέψει χωρίς εγγραφές, ή λιγότερους από την τιμή της παραμέτρου *max_results* που καθορίσατε, ακόμα και αν το διακριτικό συνέχισης δεν είναι κενό. Ένας λόγος μπορεί να είναι ότι το ερώτημα δεν ήταν δυνατή η ολοκλήρωση σε πέντε δευτερόλεπτα. Με την προϋπόθεση ότι το διακριτικό συνέχισης δεν είναι κενό, το ερώτημα θα πρέπει να συνεχίσετε και τον κωδικό δεν πρέπει να θεωρήσετε το μέγεθος των αποτελεσμάτων του τμήματος.

Τα προτεινόμενα coding μοτίβο για τα περισσότερα σενάρια είναι φέρουν κατά διαστήματα καταχώρηση, που παρέχει ρητά την πρόοδο καταχώρηση ή υποβολή ερωτημάτων και πώς η υπηρεσία αποκρίνεται σε κάθε αίτηση. Ιδιαίτερα για εφαρμογές C++ ή υπηρεσίες, έλεγχος κάτω επίπεδο της προόδου καταχώρηση μπορεί να σας βοηθήσουν μνήμης ελέγχου και τις επιδόσεις.

## <a name="greedy-listing"></a>Καταχώρηση κροταλίας

Παλαιότερες εκδόσεις της βιβλιοθήκης του προγράμματος-πελάτη χώρου αποθήκευσης για C++ (εκδόσεις 0.5.0 προεπισκόπηση και παλαιότερες εκδόσεις) περιλαμβάνονται μη φέρουν κατά διαστήματα καταχώρηση APIs για πίνακες και ουρές, όπως στο ακόλουθο παράδειγμα:

    std::vector<cloud_table> list_tables(const utility::string_t& prefix) const;
    std::vector<table_entity> execute_query(const table_query& query) const;
    std::vector<cloud_queue> list_queues() const;

Αυτές οι μέθοδοι έχουν υλοποιηθεί ως προγράμματα εξομοίωσης των τμηματική API. Για κάθε απάντηση τμηματική της λίστας, τον κωδικό προσαρτημένο τα αποτελέσματα σε ένα άνυσμα και επιστρέφεται όλα τα αποτελέσματα μετά την πλήρη κοντέινερ έγινε η σάρωση.

Αυτή η προσέγγιση ενδέχεται να λειτουργούν όταν το λογαριασμό χώρου αποθήκευσης ή πίνακας περιέχει ένα μικρό αριθμό των αντικειμένων. Ωστόσο, με αύξηση του αριθμού των αντικειμένων, την μνήμη που απαιτείται θα μπορούσε να αυξήσετε χωρίς περιορισμό, επειδή παρέμεινε όλα τα αποτελέσματα στη μνήμη. Μία καταχώρηση λειτουργία μπορεί να χρειαστεί πολύ χρόνο, κατά την οποία ο καλών δεν περιέχουν πληροφορίες σχετικά με την πρόοδο του έργου.

Αυτές οι κροταλίας καταχώρηση APIs στο SDK δεν υπάρχουν στο C#, Java ή το περιβάλλον JavaScript Node.js. Για να αποφύγετε τα πιθανά προβλήματα της χρήσης αυτά τα API κροταλίας, κατάργηση τους στην έκδοση 0.6.0 Preview.

Εάν ο κώδικας είναι αυτά κλήση κροταλίας API:

    std::vector<azure::storage::table_entity> entities = table.execute_query(query);
    for (auto it = entities.cbegin(); it != entities.cend(); ++it)
    {
        process_entity(*it);
    }

Στη συνέχεια, θα πρέπει να τροποποιήσετε τον κωδικό για να χρησιμοποιήσετε την καταχώρηση τμηματική APIs:

    azure::storage::continuation_token token;
    do
    {
        azure::storage::table_query_segment segment = table.execute_query_segmented(query, token);
        for (auto it = segment.results().cbegin(); it != segment.results().cend(); ++it)
        {
            process_entity(*it);
        }

        token = segment.continuation_token();
    } while (!token.empty());

Καθορίζοντας την παράμετρο *max_results* του τμήματος, μπορείτε να εξισορροπήσετε μεταξύ τους αριθμούς των αιτήσεων και η χρήση μνήμης ώστε να ανταποκρίνεται ζητήματα επιδόσεων για την εφαρμογή σας.

Επιπλέον, εάν χρησιμοποιείτε τμηματική καταχώρηση APIs, αλλά αποθήκευση των δεδομένων σε μια τοπική συλλογή με "κροταλίας" στυλ, επίσης συνιστάται να που refactor τον κωδικό για το χειρισμό την αποθήκευση των δεδομένων σε μια τοπική συλλογή προσεκτικά σε κλίμακα.

## <a name="lazy-listing"></a>Καταχώρηση τεμπέλη

Παρόλο που κροταλίας καταχώρηση υψωμένο πιθανά ζητήματα, είναι εύκολη αν δεν υπάρχουν πάρα πολλά αντικείμενα στο κοντέινερ.

Εάν χρησιμοποιείτε επίσης C# ή Oracle Java SDK, θα πρέπει να εξοικειωθείτε με το αριθμήσιμο μοντέλο προγραμματισμού, το οποίο προσφέρει ένα τεμπέλη στυλ καταχώρηση, όπου τα δεδομένα σε ένα συγκεκριμένο μετατόπιση λαμβάνεται μόνο εάν είναι απαραίτητο. Σε C++, το πρότυπο βάσει επαναλήπτη παρέχει επίσης μια παρόμοια προσέγγιση.

Μια τυπική λίστα τεμπέλη API, χρησιμοποιώντας **list_blobs** ως παράδειγμα, μοιάζει κάπως έτσι:

    list_blob_item_iterator list_blobs() const;

Ένα τυπικό τμήμα κώδικα που χρησιμοποιεί το μοτίβο τεμπέλη καταχώρηση μπορεί να μοιάζει κάπως έτσι:

    // List blobs in the blob container
    azure::storage::list_blob_item_iterator end_of_results;
    for (auto it = container.list_blobs(); it != end_of_results; ++it)
    {
        if (it->is_blob())
        {
            process_blob(it->as_blob());
        }
        else
        {
            process_directory(it->as_directory());
        }
    }

Σημειώστε ότι τεμπέλη καταχώρηση είναι διαθέσιμη μόνο σε σύγχρονη λειτουργία.

Σε σύγκριση με κροταλίας τη λίστα, η καταχώρηση τεμπέλη λαμβάνει δεδομένα μόνο όταν είναι απαραίτητο. Στην περιοχή στο παρασκήνιο, το λαμβάνει δεδομένα από το χώρο αποθήκευσης Azure μόνο όταν το επόμενο επαναλήπτη πραγματοποιεί μετακίνηση στο επόμενο τμήμα. Επομένως, χρήση μνήμης ελέγχεται με συνδεδεμένες μέγεθος και τη λειτουργία είναι γρήγορη.

Καταχώρηση τεμπέλη APIs περιλαμβάνονται στη βιβλιοθήκη προγράμματος-πελάτη του χώρου αποθήκευσης για C++ στην έκδοση 2.2.0.

## <a name="conclusion"></a>Ολοκλήρωση

Σε αυτό το άρθρο είπαμε διαφορετικοί τύποι για καταχώρηση APIs για διάφορα αντικείμενα στη βιβλιοθήκη προγράμματος-πελάτη του χώρου αποθήκευσης για C++. Για να συνοψίσουμε:

-   Ασύγχρονη APIs συνιστώνται ιδιαίτερα στην περιοχή πολλών πολυνηματική επεξεργασία σενάρια.
-   Τμηματική καταχώρηση συνιστάται για τα περισσότερα σενάρια.
-   Καταχώρηση τεμπέλη παρέχεται στη βιβλιοθήκη ως μια εύκολη περιτυλίγματος σε σύγχρονη σενάρια.
-   Καταχώρηση κροταλίας δεν συνιστάται και έχει καταργηθεί από τη βιβλιοθήκη.

##<a name="next-steps"></a>Επόμενα βήματα

Για περισσότερες πληροφορίες σχετικά με το χώρο αποθήκευσης Azure και βιβλιοθήκη προγράμματος-πελάτη για C++, ανατρέξτε στους ακόλουθους πόρους.

-   [Πώς να χρησιμοποιείτε το χώρο αποθήκευσης αντικειμένων Blob από C++](storage-c-plus-plus-how-to-use-blobs.md)
-   [Πώς να χρησιμοποιείτε το χώρο αποθήκευσης πινάκων από C++](storage-c-plus-plus-how-to-use-tables.md)
-   [Πώς να χρησιμοποιείτε το χώρο αποθήκευσης ουρά από C++](storage-c-plus-plus-how-to-use-queues.md)
-   [Βιβλιοθήκη προγράμματος-πελάτη Azure χώρου αποθήκευσης για την τεκμηρίωση C++ API.](http://azure.github.io/azure-storage-cpp/)
-   [Ιστολόγιο ομάδας Azure χώρου αποθήκευσης](http://blogs.msdn.com/b/windowsazurestorage/)
-   [Τεκμηρίωση Azure χώρου αποθήκευσης](https://azure.microsoft.com/documentation/services/storage/)
