<properties
    pageTitle="Κρυπτογράφηση πλευρά του προγράμματος-πελάτη με Python για χώρο αποθήκευσης Azure | Microsoft Azure"
    description="Η βιβλιοθήκη Azure αποθήκευσης προγράμματος-πελάτη για Python υποστηρίζει κρυπτογράφηση πλευρά του προγράμματος-πελάτη για μέγιστη ασφάλεια για τις εφαρμογές σας χώρο αποθήκευσης Azure."
    services="storage"
    documentationCenter="python"
    authors="dineshmurthy"
    manager="jahogg"
    editor="tysonn"/>

<tags
    ms.service="storage"
    ms.workload="storage"
    ms.tgt_pltfrm="na"
    ms.devlang="python"
    ms.topic="article"
    ms.date="10/18/2016"
    ms.author="dineshm"/>


# <a name="client-side-encryption-with-python-for-microsoft-azure-storage"></a>Κρυπτογράφηση πλευρά του προγράμματος-πελάτη με Python για χώρο αποθήκευσης Azure

[AZURE.INCLUDE [storage-selector-client-side-encryption-include](../../includes/storage-selector-client-side-encryption-include.md)]

## <a name="overview"></a>Επισκόπηση

Η [Βιβλιοθήκη προγράμματος-πελάτη του Azure χώρου αποθήκευσης για Python](https://pypi.python.org/pypi/azure-storage) υποστηρίζει κρυπτογράφηση δεδομένων μέσα σε εφαρμογές προγράμματος-πελάτη πριν από την αποστολή στο χώρο αποθήκευσης Azure και αποκρυπτογράφηση δεδομένων κατά τη λήψη του στον υπολογιστή-πελάτη.

>[AZURE.NOTE] Η βιβλιοθήκη Azure Python χώρου αποθήκευσης είναι σε προεπισκόπηση.

## <a name="encryption-and-decryption-via-the-envelope-technique"></a>Κρυπτογράφηση και αποκρυπτογράφηση μέσω την τεχνική φακέλου
Οι διεργασίες κρυπτογράφηση και αποκρυπτογράφηση ακολουθήστε την τεχνική φακέλου.

### <a name="encryption-via-the-envelope-technique"></a>Κρυπτογράφηση μέσω την τεχνική φακέλου
Η κρυπτογράφηση μέσω την τεχνική φακέλου λειτουργεί με τον εξής τρόπο:

1.  Στη βιβλιοθήκη του προγράμματος-πελάτη Azure αποθήκευσης δημιουργεί ένα κλειδί περιεχομένου κρυπτογράφησης (CEK), το οποίο είναι ένα πλήκτρο συμμετρική μία φορά χρήση.

2.  Τα δεδομένα των χρηστών είναι κρυπτογραφημένη χρησιμοποιώντας αυτό CEK.

3.  Το CEK, στη συνέχεια, αναδιπλώνεται (κρυπτογραφημένα) χρησιμοποιώντας το κλειδί κλειδιού κρυπτογράφησης (KEK). Το KEK προσδιορίζεται από ένα πλήκτρο αναγνωριστικό και μπορεί να είναι ένα ζεύγος κλειδιών ασύμμετρη ή μια συμμετρική κλειδί, το οποίο γίνεται τοπικά.
Ολόκληρη η βιβλιοθήκη προγράμματος-πελάτη αποθήκευσης ποτέ αποκτά πρόσβαση KEK. Η βιβλιοθήκη καλεί ο αλγόριθμος αναδίπλωσης κλειδιού που παρέχεται από το KEK. Οι χρήστες μπορούν να χρησιμοποιήσετε προσαρμοσμένες υπηρεσίες παροχής για κλειδιού αναδίπλωσης/κατάργηση αναδίπλωσης, εάν θέλετε.

4.  Το κρυπτογραφημένων δεδομένων είναι στη συνέχεια, που έχουν αποσταλεί με την υπηρεσία αποθήκευσης Azure. Το κλειδί αναδιπλωμένο μαζί με ορισμένα μετα-δεδομένα επιπλέον κρυπτογράφησης αποθηκεύονται ως μετα-δεδομένα (σε ένα αντικείμενο blob) ή παρεμβολή με τα κρυπτογραφημένα δεδομένα (ουρά μηνυμάτων και οντοτήτων πίνακα).

### <a name="decryption-via-the-envelope-technique"></a>Αποκρυπτογράφηση μέσω την τεχνική φακέλου
Αποκρυπτογράφηση μέσω του φακέλου τεχνική λειτουργεί με τον εξής τρόπο:

1.  Στη βιβλιοθήκη του προγράμματος-πελάτη προϋποθέτει ότι ο χρήστης έχει τη διαχείριση του κλειδιού κλειδιού κρυπτογράφησης (KEK) τοπικά. Ο χρήστης δεν χρειάζεται να γνωρίζετε το συγκεκριμένο αριθμό-κλειδί που χρησιμοποιήθηκε για την κρυπτογράφηση. Αντί για αυτό, ενός κλειδιού επίλυσης, που είναι διαφορετικές κλειδιού αναγνωριστικά πλήκτρα, μπορεί να ρυθμίσετε και να χρησιμοποιηθεί.

2.  Στη βιβλιοθήκη του προγράμματος-πελάτη κάνει λήψη του κρυπτογραφημένων δεδομένων μαζί με οποιοδήποτε υλικό κρυπτογράφησης που είναι αποθηκευμένα στην υπηρεσία.

3.  Το κλειδί αναδιπλωμένο περιεχομένου κρυπτογράφησης (CEK) είναι αποδεσμευτεί (αποκρυπτογράφηση) με χρήση του κλειδιού κρυπτογράφησης βασικές (KEK). Δείτε ξανά, τη βιβλιοθήκη προγράμματος-πελάτη δεν έχουν πρόσβαση στο KEK. Το καλεί απλώς αλγόριθμο unwrapping την προσαρμοσμένη υπηρεσία παροχής.

4.  Του κλειδιού κρυπτογράφησης περιεχομένου (CEK) χρησιμοποιείται για να αποκρυπτογραφήσετε τα δεδομένα κρυπτογραφημένο χρήστη.

## <a name="encryption-mechanism"></a>Μηχανισμός κρυπτογράφησης  
Η βιβλιοθήκη προγράμματος-πελάτη του χώρου αποθήκευσης χρησιμοποιεί [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) προκειμένου να κρυπτογραφήσετε τα δεδομένα των χρηστών. Συγκεκριμένα, [Κρυπτογράφηση μπλοκ αλυσιδωτή (CBC)](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29) λειτουργία με AES. Κάθε υπηρεσία λειτουργεί κάπως διαφορετικά, έτσι θα αναλύονται κάθε έναν από τους εδώ.

### <a name="blobs"></a>Αντικείμενα BLOB
Στη βιβλιοθήκη του προγράμματος-πελάτη υποστηρίζει επί του παρόντος κρυπτογράφησης από ολόκληρο αντικείμενα blob. Συγκεκριμένα, κρυπτογράφηση υποστηρίζεται όταν οι χρήστες χρησιμοποιούν το **δημιουργήσετε*** μεθόδους. Για στοιχεία λήψης, και τα δύο ολοκλήρωσης και στοιχεία λήψης περιοχή υποστηρίζονται και parallelization της αποστολής και λήψης είναι διαθέσιμη.

Κατά τη διάρκεια της κρυπτογράφησης, τη βιβλιοθήκη προγράμματος-πελάτη θα δημιουργήσετε μια τυχαία ανύσματος προετοιμασίας (IV) 16 byte, μαζί με ένα κλειδί τυχαία περιεχομένου κρυπτογράφησης (CEK) 32 byte, και να εκτελέσει φακέλου κρυπτογράφηση των δεδομένων blob χρησιμοποιώντας αυτές τις πληροφορίες. Το αναδιπλωμένο CEK και ορισμένα μετα-δεδομένα επιπλέον κρυπτογράφησης αποθηκεύονται, στη συνέχεια, όπως αντικειμένων blob μετα-δεδομένων μαζί με το κρυπτογραφημένο blob στην υπηρεσία.

>[AZURE.WARNING] Εάν επεξεργάζεστε ή αποστολή τη δική σας μετα-δεδομένων για το αντικείμενο blob, πρέπει να βεβαιωθείτε ότι διατηρούνται αυτό μετα-δεδομένων. Εάν κάνετε αποστολή νέου μετα-δεδομένων χωρίς αυτό μετα-δεδομένων, το αναδιπλωμένο CEK, IV και άλλα μετα-δεδομένα θα χαθούν και το περιεχόμενο blob ποτέ θα ανακτήσιμη ξανά.

Λήψη ένα κρυπτογραφημένο αντικείμενο blob περιλαμβάνει την ανάκτηση του περιεχομένου από το ολόκληρο blob χρησιμοποιώντας τη **λήψη*** ευκολία μεθόδους. Το αναδιπλωμένο CEK είναι περισσοτέρων και να χρησιμοποιηθεί μαζί με το IV (έχουν αποθηκευτεί ως blob μετα-δεδομένων σε αυτήν την περίπτωση) για να επιστρέψει την αποκρυπτογράφηση δεδομένων στους χρήστες.

Λήψη μιας περιοχής αυθαίρετο (**λήψη*** μεθόδων με παραμέτρους περιοχής διαβιβάζεται στο) στο κρυπτογραφημένο αντικείμενο blob περιλαμβάνει την προσαρμογή της περιοχής που παρέχεται από τους χρήστες για να λάβετε μια μικρή ποσότητα πρόσθετα δεδομένα που μπορούν να χρησιμοποιηθούν για να αποκρυπτογραφήσετε με επιτυχία η περιοχή που ζητήθηκε.

Αντικείμενα BLOB μπλοκ και αντικείμενα BLOB σελίδας μπορεί να είναι μόνο Κρυπτογράφηση/αποκρυπτογράφηση χρησιμοποιώντας αυτό το σχήμα. Δεν υπάρχει αυτήν τη στιγμή δεν υπάρχει υποστήριξη για την κρυπτογράφηση Προσάρτηση αντικείμενα blob.

### <a name="queues"></a>Ουρές
Εφόσον ουρά μηνυμάτων μπορεί να είναι από οποιαδήποτε μορφή, τη βιβλιοθήκη προγράμματος-πελάτη καθορίζει μια προσαρμοσμένη μορφή που περιλαμβάνει το ανύσματος προετοιμασίας (IV) και το πλήκτρο κρυπτογραφημένο περιεχομένου κρυπτογράφησης (CEK) στο κείμενο του μηνύματος.

Κατά τη διάρκεια της κρυπτογράφησης, η βιβλιοθήκη προγράμματος-πελάτη δημιουργεί έναν τυχαίο IV του 16 byte μαζί με μια τυχαία CEK byte 32 και εκτελεί κρυπτογράφησης φακέλου από το κείμενο του μηνύματος ουρά χρησιμοποιώντας αυτές τις πληροφορίες. Το αναδιπλωμένο CEK και ορισμένα μετα-δεδομένα επιπλέον κρυπτογράφησης, στη συνέχεια, προστίθενται στο ουρά κρυπτογραφημένο μήνυμα. Αυτό το μήνυμα έχουν τροποποιηθεί (απεικονίζεται παρακάτω) είναι αποθηκευμένη στην υπηρεσία.

    <MessageText>{"EncryptedMessageContents":"6kOu8Rq1C3+M1QO4alKLmWthWXSmHV3mEfxBAgP9QGTU++MKn2uPq3t2UjF1DO6w","EncryptionData":{…}}</MessageText>

Κατά τη διάρκεια αποκρυπτογράφηση, τον αριθμό-κλειδί αναδιπλωμένο είναι που έχουν εξαχθεί από το μήνυμα ουρά και να περισσοτέρων. Το IV είναι επίσης να που έχουν εξαχθεί από το μήνυμα ουρά και να χρησιμοποιηθεί μαζί με τον αριθμό-κλειδί αποδεσμευτεί να αποκρυπτογραφήσετε τα δεδομένα μήνυμα ουρά. Σημειώστε ότι τα μετα-δεδομένα κρυπτογράφησης είναι μικρές (στην περιοχή 500 byte), ώστε να ενώ το μετρήσετε προς το όριο των 64KB για ένα μήνυμα ουρά, την επίδραση πρέπει να διαχειρίσιμα.

### <a name="tables"></a>Πίνακες
Η βιβλιοθήκη προγράμματος-πελάτη υποστηρίζει κρυπτογράφηση οντότητα ιδιοτήτων για εισαγωγή και αντικατάσταση λειτουργίες.

>[AZURE.NOTE] Συγχώνευση δεν υποστηρίζεται αυτήν τη στιγμή. Επειδή ένα υποσύνολο των ιδιοτήτων ενδέχεται να έχουν τεθεί κρυπτογραφημένα προηγουμένως, χρησιμοποιώντας έναν διαφορετικό αριθμό-κλειδί, απλώς τη συγχώνευση οι νέες ιδιότητες και την ενημέρωση των μετα-δεδομένων θα έχει ως αποτέλεσμα απώλεια δεδομένων. Συγχώνευση είτε απαιτεί να πραγματοποιήσετε κλήσεις επιπλέον υπηρεσίας για να διαβάσετε την προ-υπαρχόντων οντότητα από την υπηρεσία ή χρησιμοποιώντας έναν νέο αριθμό-κλειδί ανά ιδιότητα, οι οποίες δεν είναι κατάλληλη για λόγους απόδοσης.

Κρυπτογράφηση δεδομένων πίνακα λειτουργεί ως εξής:

1.  Οι χρήστες καθορίζουν τις ιδιότητες για να είναι κρυπτογραφημένα.

2.  Στη βιβλιοθήκη του προγράμματος-πελάτη δημιουργεί μια τυχαία ανύσματος προετοιμασίας (IV) 16 byte μαζί με ένα κλειδί κρυπτογράφησης τυχαία περιεχομένου (CEK) byte 32 για κάθε οντότητα, και εκτελεί κρυπτογράφησης φακέλου σε τις μεμονωμένες ιδιότητες για να είναι κρυπτογραφημένα με που προκύπτει ένα νέο IV ανά ιδιότητα. Η ιδιότητα κρυπτογραφημένο αποθηκεύονται ως δυαδικά δεδομένα.

3.  Το αναδιπλωμένο CEK και ορισμένα μετα-δεδομένα επιπλέον κρυπτογράφησης, στη συνέχεια, αποθηκεύονται ως δύο πρόσθετες ιδιότητες δεσμευμένη. Το πρώτο δεσμευμένες ιδιότητα (\_ClientEncryptionMetadata1) είναι μια ιδιότητα συμβολοσειρά που περιέχει τις πληροφορίες σχετικά με το IV, την έκδοση και αναδιπλωμένο κλειδί. Η δεύτερη δεσμευμένες ιδιότητα (\_ClientEncryptionMetadata2) είναι μια δυαδική ιδιότητα που περιέχει τις πληροφορίες σχετικά με τις ιδιότητες που είναι κρυπτογραφημένα. Οι πληροφορίες σε αυτήν την ιδιότητα δεύτερο (\_ClientEncryptionMetadata2) είναι η ίδια κρυπτογραφημένα.

4.  Λόγω αυτές τις πρόσθετες δεσμευμένες ιδιότητες που απαιτούνται για την κρυπτογράφηση, οι χρήστες τώρα μπορεί να έχει μόνο 250 προσαρμοσμένες ιδιότητες αντί για 252. Το συνολικό μέγεθος της οντότητας πρέπει να είναι λιγότερο από 1MB.

    Σημειώστε ότι μόνο οι ιδιότητες συμβολοσειρών μπορούν να είναι κρυπτογραφημένα. Εάν οι άλλοι τύποι ιδιοτήτων είναι κρυπτογράφησης, πρέπει να μετατρέπονται σε συμβολοσειρές. Το κρυπτογραφημένο συμβολοσειρές που είναι αποθηκευμένα στην υπηρεσία ως δυαδικό ιδιότητες και μετατρέπονται σε συμβολοσειρές (ανεπεξέργαστα συμβολοσειρές, δεν EntityProperties με τον τύπο EdmType.STRING) μετά την αποκρυπτογράφηση.

    Για πίνακες, εκτός από την πολιτική κρυπτογράφησης, οι χρήστες πρέπει να καθορίσετε τις ιδιότητες για να είναι κρυπτογραφημένο. Αυτό μπορεί να γίνει αποθηκεύοντας από αυτές τις ιδιότητες σε αντικείμενα TableEntity με το σύνολο τύπος να EdmType.STRING και κρυπτογράφηση οριστεί στην τιμή true ή τη ρύθμιση του encryption_resolver_function στο αντικείμενο tableservice. Μια μέθοδος κρυπτογράφησης επίλυσης είναι μια συνάρτηση που λαμβάνει ένα πλήκτρο διαμερίσματα, γραμμή κλειδί και όνομα ιδιότητας και επιστρέφει μια τιμή boolean που υποδεικνύει εάν θα πρέπει να κρυπτογραφούνται αυτήν την ιδιότητα. Κατά τη διάρκεια της κρυπτογράφησης, η βιβλιοθήκη προγράμματος-πελάτη θα χρησιμοποιήσει αυτές τις πληροφορίες για να αποφασίσετε εάν θα πρέπει να κρυπτογραφούνται μια ιδιότητα κατά την εγγραφή σύρματος. Ο πληρεξούσιος παρέχει επίσης τη δυνατότητα της λογικής γύρω από τον τρόπο που είναι κρυπτογραφημένα ιδιότητες. (Για παράδειγμα, εάν X, στη συνέχεια κρυπτογράφηση ιδιότητα A; διαφορετικά κρυπτογράφηση ιδιότητες Α και β.) Σημειώστε ότι δεν είναι απαραίτητο να δώσετε αυτές τις πληροφορίες κατά την ανάγνωση ή την υποβολή ερωτημάτων οντοτήτων.

### <a name="batch-operations"></a>Λειτουργίες δέσμης
Μία πολιτική κρυπτογράφησης εφαρμόζεται σε όλες τις γραμμές στη δέσμη. Στη βιβλιοθήκη του προγράμματος-πελάτη θα εσωτερικά να δημιουργήσει μια νέα τυχαία IV και τυχαίες CEK ανά γραμμή στη δέσμη. Οι χρήστες μπορούν επίσης να κρυπτογραφήσετε διαφορετικές ιδιότητες για κάθε λειτουργία στη δέσμη ορίζοντας αυτήν τη συμπεριφορά στα η επίλυση κρυπτογράφησης.
Εάν μια δέσμη δημιουργείται ως διαχειριστής περιβάλλοντος μέσω της μεθόδου batch() tableservice, το tableservice κρυπτογράφησης πολιτικής θα εφαρμοστεί αυτόματα με τη δέσμη. Εάν μια δέσμη δημιουργείται ρητά καλώντας την κατασκευή, πρέπει να που εισήχθησαν ως παράμετρο της πολιτικής κρυπτογράφησης και αριστερά χωρίς τροποποίηση για τη διάρκεια ζωής της δέσμης.
Σημειώστε ότι είναι κρυπτογραφημένα οντοτήτων όπως είναι αυτές που έχουν εισαχθεί σε τη δέσμη χρησιμοποιώντας τη δέσμη πολιτική κρυπτογράφησης (οντοτήτων δεν είναι κρυπτογραφημένα κατά τη διάρκεια του την οριστικοποίηση των τη δέσμη χρησιμοποιώντας την πολιτική κρυπτογράφησης το tableservice).

### <a name="queries"></a>Ερωτήματα
Για να εκτελέσετε λειτουργίες ερωτήματος, πρέπει να καθορίσετε ένα πλήκτρο επίλυσης που είναι σε θέση να επιλύσετε όλα τα πλήκτρα στο σύνολο αποτελεσμάτων. Εάν μια οντότητα που περιέχονται στο αποτέλεσμα του ερωτήματος δεν μπορεί να επιλυθεί σε μια υπηρεσία παροχής, τη βιβλιοθήκη προγράμματος-πελάτη θα εμφανίσουν ένα σφάλμα. Για οποιοδήποτε ερώτημα που εκτελεί προβλέψεις πλευρά του διακομιστή, τη βιβλιοθήκη προγράμματος-πελάτη θα προσθέσει των ιδιοτήτων μετα-δεδομένων ειδική κρυπτογράφησης (\_ClientEncryptionMetadata1 και \_ClientEncryptionMetadata2) από προεπιλογή για τις επιλεγμένες στήλες.

>[AZURE.IMPORTANT] Λάβετε υπόψη τα παρακάτω σημαντικά σημεία κατά τη χρήση της κρυπτογράφησης πλευρά του προγράμματος-πελάτη:
>
>- Κατά την ανάγνωση ή την εγγραφή σε ένα κρυπτογραφημένο αντικείμενο blob, χρησιμοποιήστε ολόκληρη blob αποστολής και εντολές λήψη blob περιοχή/ακέραιος. Αποφύγετε την εγγραφή σε ένα κρυπτογραφημένο αντικείμενο blob χρήση λειτουργιών πρωτόκολλο όπως τοποθέτηση μπλοκ, τοποθέτηση λίστα μπλοκ, γράψτε σελίδες ή απαλοιφή σελίδες. Διαφορετικά που μπορεί να καταστρέψει το κρυπτογραφημένο blob και να είναι δυνατή η ανάγνωση.
>
>- Για πίνακες, υπάρχει μια παρόμοια περιορισμού. Να είστε προσεκτικοί για να ενημερώσετε δεν κρυπτογραφημένο ιδιότητες χωρίς να ενημερώσετε τα μετα-δεδομένα κρυπτογράφησης.
>
>- Εάν ορίσετε μετα-δεδομένων σε το κρυπτογραφημένο blob, ενδέχεται να μπορείτε να αντικαταστήσετε το που σχετίζονται με την κρυπτογράφηση μετα-δεδομένων απαιτείται για την αποκρυπτογράφηση, επειδή ο ορισμός μετα-δεδομένων δεν είναι προσθετικά. Αυτό ισχύει επίσης για στιγμιότυπα; αποφύγετε καθορίζοντας μετα-δεδομένων κατά τη δημιουργία ένα στιγμιότυπο του ένα κρυπτογραφημένο αντικείμενο blob. Εάν πρέπει να οριστούν μετα-δεδομένων, βεβαιωθείτε ότι η κλήση της μεθόδου **get_blob_metadata** πρώτα, για να λάβετε την τρέχουσα μετα-δεδομένα κρυπτογράφησης, και να αποφύγετε ταυτόχρονες εγγραφές ενώ ορίζεται μετα-δεδομένων.
>
>- Ενεργοποίηση της σημαίας **require_encryption** του αντικειμένου υπηρεσίας για τους χρήστες που θα πρέπει να λειτουργούν μόνο με κρυπτογραφημένων δεδομένων. Δείτε παρακάτω για περισσότερες πληροφορίες.

Στη βιβλιοθήκη του προγράμματος-πελάτη αποθήκευσης αναμένει η παρεχόμενη KEK και κλειδιού επίλυσης για την υλοποίηση της παρακάτω περιβάλλον εργασίας του. [Azure κλειδί θάλαμο](https://azure.microsoft.com/services/key-vault/) υποστήριξη για τη Διαχείριση Python KEK είναι σε εκκρεμότητα και εμβέλειας σε αυτήν τη βιβλιοθήκη όταν ολοκληρωθεί.


## <a name="client-api--interface"></a>API του προγράμματος-πελάτη / περιβάλλοντος εργασίας
Μετά τη δημιουργία ενός αντικειμένου υπηρεσίας αποθήκευσης (δηλαδή blockblobservice), ο χρήστης μπορεί να εκχωρήσει τιμές στα πεδία που αποτελούν μια πολιτική κρυπτογράφησης: key_encryption_key, key_resolver_function, και require_encryption. Οι χρήστες μπορούν να παρέχουν μόνο KEK, μόνο μια επίλυση ή και τα δύο. key_encryption_key είναι ο τύπος του βασικού κλειδιού που προσδιορίζεται χρησιμοποιώντας ένα πλήκτρο αναγνωριστικό και που παρέχει τη λογική για αναδίπλωση/κατάργηση αναδίπλωσης. key_resolver_function χρησιμοποιείται για την επίλυση ενός κλειδιού κατά τη διαδικασία αποκρυπτογράφησης. Επιστρέφει μια έγκυρη KEK δεδομένο ένα αναγνωριστικό κλειδιού. Αυτό παρέχει στους χρήστες τη δυνατότητα να επιλέξετε μεταξύ πολλών πλήκτρων που πραγματοποιείται σε πολλές θέσεις.

Το KEK πρέπει να εφαρμόσετε τις παρακάτω μεθόδους για την κρυπτογράφηση των δεδομένων με επιτυχία:
- wrap_key(cek): αναδιπλώνεται το καθορισμένο CEK (byte) χρησιμοποιώντας ένα αλγόριθμο της επιλογής του χρήστη. Επιστρέφει τον αριθμό-κλειδί αναδιπλωμένο.
- get_key_wrap_algorithm(): επιστρέφει τον αλγόριθμο που χρησιμοποιείται για να αναδιπλώσετε πλήκτρα.
- get_kid(): επιστρέφει το αναγνωριστικό κλειδιού συμβολοσειρά για αυτό KEK.
Το KEK πρέπει να εφαρμόσετε τις παρακάτω μεθόδους για την επιτυχία αποκρυπτογράφηση δεδομένων:
- unwrap_key (cek, αλγόριθμο): επιστρέφει τη μη αναδιπλωμένα φόρμα από το καθορισμένο CEK χρησιμοποιώντας τον αλγόριθμο καθοριστεί συμβολοσειρά.
- get_kid(): επιστρέφει μια συμβολοσειρά αναγνωριστικό κλειδιού για αυτό KEK.

Η επίλυση κλειδιού τουλάχιστον πρέπει να υλοποιήσει μια μέθοδο που, δεδομένο ένα αναγνωριστικό κλειδιού, επιστρέφει την αντίστοιχη KEK εφαρμογής στο περιβάλλον εργασίας της παραπάνω. Μόνο αυτή η μέθοδος είναι θα εκχωρηθούν της ιδιότητας key_resolver_function του αντικειμένου υπηρεσίας.

- Για την κρυπτογράφηση, χρησιμοποιείται πάντα το κλειδί και την απουσία έναν αριθμό-κλειδί θα έχει ως αποτέλεσμα σφάλμα.
- Για αποκρυπτογράφηση:
    - Η επίλυση κλειδιού, ενεργοποιείται εάν καθοριστεί για να λάβετε τον αριθμό-κλειδί. Εάν η επίλυση έχει καθοριστεί, αλλά δεν έχει μια αντιστοίχιση για το αναγνωριστικό του κλειδιού, παρουσιαστεί σφάλμα.
    - Εάν δεν έχει καθοριστεί επίλυσης αλλά έχει οριστεί έναν αριθμό-κλειδί, το πλήκτρο χρησιμοποιείται εάν το αναγνωριστικό συμφωνεί με το αναγνωριστικό του κλειδιού απαιτείται. Εάν το αναγνωριστικό δεν συμφωνούν, παρουσιαστεί σφάλμα.

      Τα δείγματα κρυπτογράφησης στο azure.storage.samples <fix URL>απεικονίζουν μια πιο λεπτομερή σενάριο λήξη-σε-end για αντικείμενα blob, ουρές και πίνακες.
        Δείγμα υλοποιήσεις του KEK και κλειδιού επίλυσης παρέχονται στο τα δείγματα αρχείων ως KeyWrapper και KeyResolver αντίστοιχα.

### <a name="requireencryption-mode"></a>Λειτουργία RequireEncryption
Οι χρήστες μπορούν να ενεργοποιήσουν προαιρετικά λειτουργίας όπου πρέπει να είναι κρυπτογραφημένα όλες τις αποστολές και λήψεις. Σε αυτήν τη λειτουργία προσπάθειες δεδομένα χωρίς μια πολιτική κρυπτογράφησης η αποστολή ή λήψη δεδομένων που δεν είναι κρυπτογραφημένα στην υπηρεσία θα αποτύχουν του υπολογιστή-πελάτη. Η σημαία **require_encryption** στο αντικείμενο υπηρεσία ελέγχου αυτήν τη συμπεριφορά.

### <a name="blob-service-encryption"></a>Κρυπτογράφηση υπηρεσίας BLOB
Ορίστε την κρυπτογράφηση πολιτικής πεδία στο αντικείμενο blockblobservice. Οτιδήποτε άλλο θα γίνεται ο χειρισμός από τη βιβλιοθήκη του προγράμματος-πελάτη εσωτερικά.

    # Create the KEK used for encryption.
    # KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.
    kek = KeyWrapper('local:key1') # Key identifier

    # Create the key resolver used for decryption.
    # KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.
    key_resolver = KeyResolver()
    key_resolver.put_key(kek)

    # Set the KEK and key resolver on the service object.
    my_block_blob_service.key_encryption_key = kek
    my_block_blob_service.key_resolver_funcion = key_resolver.resolve_key

    # Upload the encrypted contents to the blob.
    my_block_blob_service.create_blob_from_stream(container_name, blob_name, stream)

    # Download and decrypt the encrypted contents from the blob.
    blob = my_block_blob_service.get_blob_to_bytes(container_name, blob_name)

### <a name="queue-service-encryption"></a>Κρυπτογράφηση της υπηρεσίας Ουράς
Ορίστε την κρυπτογράφηση πολιτικής πεδία στο αντικείμενο queueservice. Οτιδήποτε άλλο θα γίνεται ο χειρισμός από τη βιβλιοθήκη του προγράμματος-πελάτη εσωτερικά.

    # Create the KEK used for encryption.
    # KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.
    kek = KeyWrapper('local:key1') # Key identifier

    # Create the key resolver used for decryption.
    # KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.
    key_resolver = KeyResolver()
    key_resolver.put_key(kek)

    # Set the KEK and key resolver on the service object.
    my_queue_service.key_encryption_key = kek
    my_queue_service.key_resolver_funcion = key_resolver.resolve_key

    # Add message
    my_queue_service.put_message(queue_name, content)

    # Retrieve message
    retrieved_message_list = my_queue_service.get_messages(queue_name)

### <a name="table-service-encryption"></a>Κρυπτογράφηση υπηρεσίας πίνακα
Εκτός από τη δημιουργία μιας πολιτικής κρυπτογράφησης και τον ορισμό της αίτησης επιλογές, πρέπει είτε ορίστε μια **encryption_resolver_function** στον το **tableservice**, ή να ορίσετε το χαρακτηριστικό κρυπτογράφηση για το EntityProperty.

### <a name="using-the-resolver"></a>Χρησιμοποιώντας την επίλυση

    # Create the KEK used for encryption.
    # KeyWrapper is the provided sample implementation, but the user may use their own object as long as it implements the interface above.
    kek = KeyWrapper('local:key1') # Key identifier

    # Create the key resolver used for decryption.
    # KeyResolver is the provided sample implementation, but the user may use whatever implementation they choose so long as the function set on the service object behaves appropriately.
    key_resolver = KeyResolver()
    key_resolver.put_key(kek)

    # Define the encryption resolver_function.
    def my_encryption_resolver(pk, rk, property_name):
            if property_name == 'foo':
                    return True
            return False

    # Set the KEK and key resolver on the service object.
    my_table_service.key_encryption_key = kek
    my_table_service.key_resolver_funcion = key_resolver.resolve_key
    my_table_service.encryption_resolver_function = my_encryption_resolver

    # Insert Entity
    my_table_service.insert_entity(table_name, entity)

    # Retrieve Entity
    # Note: No need to specify an encryption resolver for retrieve, but it is harmless to leave the property set.
    my_table_service.get_entity(table_name, entity['PartitionKey'], entity['RowKey'])

### <a name="using-attributes"></a>Χρήση χαρακτηριστικά
Όπως προαναφέρθηκε, μια ιδιότητα ίσως να έχουν επισημανθεί κρυπτογράφησης, αποθηκεύοντάς τα σε ένα αντικείμενο EntityProperty και ορίζοντας το πεδίο κρυπτογράφηση.

    encrypted_property_1 = EntityProperty(EdmType.STRING, value, encrypt=True)

## <a name="encryption-and-performance"></a>Κρυπτογράφηση και επιδόσεων
Λάβετε υπόψη ότι κρυπτογράφηση τα αποτελέσματα δεδομένων χώρου αποθήκευσης στο επιβάρυνσης επιπλέον επιδόσεων. Πρέπει να έχει δημιουργηθεί το περιεχόμενο κλειδί και IV, το περιεχόμενο μόνο πρέπει να είναι κρυπτογραφημένες και πρόσθετα μετα-δεδομένα πρέπει να είναι μορφοποιημένο και να αποστείλει. Αυτό επιβάρυνσης θα ποικίλλουν ανάλογα με την ποσότητα των δεδομένων που είναι κρυπτογραφημένα. Συνιστάται να ότι οι πελάτες δοκιμή πάντα των αιτήσεων για απόδοσης κατά την ανάπτυξη.

## <a name="next-steps"></a>Επόμενα βήματα

- Κάντε λήψη του [Azure βιβλιοθήκη προγράμματος-πελάτη χώρου αποθήκευσης για το πακέτο Java PyPi](https://pypi.python.org/pypi/azure-storage)
- Κάντε λήψη του [Azure αποθήκευσης βιβλιοθήκη προγράμματος-πελάτη για Python πηγαίος κώδικας από GitHub](https://github.com/Azure/azure-storage-python)
