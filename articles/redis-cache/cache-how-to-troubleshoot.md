<properties 
    pageTitle="Τρόπος αντιμετώπισης προβλημάτων Azure Redis Cache | Microsoft Azure" 
    description="Μάθετε πώς μπορείτε να επιλύσετε συνήθη ζητήματα με το Azure Redis Cache." 
    services="redis-cache" 
    documentationCenter="" 
    authors="steved0x" 
    manager="douge" 
    editor=""/>

<tags 
    ms.service="cache" 
    ms.workload="tbd" 
    ms.tgt_pltfrm="cache-redis" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.date="10/25/2016" 
    ms.author="sdanie"/>

# <a name="how-to-troubleshoot-azure-redis-cache"></a>Τρόπος αντιμετώπισης προβλημάτων Azure Redis Cache

Σε αυτό το άρθρο παρέχει οδηγίες για την αντιμετώπιση προβλημάτων τις εξής κατηγορίες Azure Redis Cache ζητημάτων.

-   [Αντιμετώπιση προβλημάτων πλευρά του προγράμματος-πελάτη](#client-side-troubleshooting) - αυτή η ενότητα παρέχει οδηγίες σχετικά με τον εντοπισμό και την επίλυση προβλημάτων που προκαλούνται από την εφαρμογή τη σύνδεση στο Azure Redis Cache.
-   [Αντιμετώπιση προβλημάτων στο διακομιστή πλευρά](#server-side-troubleshooting) - αυτή η ενότητα παρέχει οδηγίες σχετικά με τον εντοπισμό και την επίλυση προβλημάτων που προκαλούνται στην πλευρά server Azure Redis Cache.
-   [Εξαιρέσεις χρονικού ορίου StackExchange.Redis](#stackexchangeredis-timeout-exceptions) - αυτή η ενότητα παρέχει πληροφορίες σχετικά με την αντιμετώπιση προβλημάτων κατά τη χρήση του προγράμματος-πελάτη StackExchange.Redis.


>[AZURE.NOTE] Πολλά από τα βήματα αντιμετώπισης προβλημάτων σε αυτόν τον Οδηγό περιλαμβάνει οδηγίες για εκτέλεση εντολών Redis και την παρακολούθηση διάφορες μετρικών απόδοσης. Για περισσότερες πληροφορίες και οδηγίες, ανατρέξτε στα άρθρα στην ενότητα [πρόσθετες πληροφορίες](#additional-information) .

## <a name="client-side-troubleshooting"></a>Αντιμετώπιση προβλημάτων πλευρά του προγράμματος-πελάτη


Αυτή η ενότητα περιγράφει αντιμετώπισης προβλημάτων που παρουσιάζονται λόγω μια συνθήκη σχετικά με την εφαρμογή υπολογιστή-πελάτη.

-   [Πίεση μνήμης του υπολογιστή-πελάτη](#memory-pressure-on-the-client)
-   [Καταιγισμού κίνησης](#burst-of-traffic)
-   [Υψηλή προγράμματος-πελάτη της CPU](#high-client-cpu-usage)
-   [Υπέρβαση του εύρους ζώνης πλευρά του προγράμματος-πελάτη](#client-side-bandwidth-exceeded)
-   [Μέγεθος μεγάλο αίτηση/απάντηση](#large-requestresponse-size)
-   [Τι συνέβη στο Redis τα δεδομένα μου;](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a>Πίεση μνήμης του υπολογιστή-πελάτη

#### <a name="problem"></a>Πρόβλημα

Πίεση μνήμης στον υπολογιστή-πελάτη σας καθοδηγεί σε κάθε είδους προβλήματα επιδόσεων που μπορεί να καθυστερήσει η επεξεργασία των δεδομένων που έχει αποσταλεί από την παρουσία Redis χωρίς καθυστέρηση. Όταν επισκέψεις πίεση μνήμης, το σύστημα έχει συνήθως σελίδας δεδομένα από φυσική μνήμη στην εικονική μνήμη, που βρίσκεται στο δίσκο. Αυτό *ελαττωματική σελίδα* έχει ως αποτέλεσμα το σύστημα για να επιβραδύνετε σημαντικά.

#### <a name="measurement"></a>Μέτρησης 

1.  Παρακολούθηση της χρήσης μνήμης στον υπολογιστή για να βεβαιωθείτε ότι δεν υπερβαίνει διαθέσιμη μνήμη. 
2.  Οθόνη του `Page Faults/Sec` μετρητή επιδόσεων. Περισσότερα από τα συστήματα θα έχουν ορισμένα σφάλματα σελίδας ακόμα και κατά την κανονική λειτουργία, επομένως, παρακολουθήστε για αιχμές σε αυτόν το μετρητή επιδόσεων σφάλματα σελίδας που αντιστοιχούν με χρονικών ορίων.

#### <a name="resolution"></a>Ανάλυση

Αναβάθμιση του προγράμματος-πελάτη στο πρόγραμμα-πελάτη και μεγαλύτερο μέγεθος Εικονική με περισσότερη μνήμη ή στοιχείο Διάνοιξη σε σας μοτίβα χρήση μνήμης για να μειώσετε consuption μνήμης.


### <a name="burst-of-traffic"></a>Καταιγισμού κίνησης

#### <a name="problem"></a>Πρόβλημα

Καταιγισμό κίνησης σε συνδυασμό με κακής `ThreadPool` ρυθμίσεις μπορεί να έχει ως αποτέλεσμα καθυστερήσεις στην επεξεργασία δεδομένων ήδη αποστέλλεται από το διακομιστή Redis, αλλά δεν έχουν ακόμα που καταναλώθηκε στην πλευρά του προγράμματος-πελάτη.

#### <a name="measurement"></a>Μέτρησης 

Οθόνη πώς σας `ThreadPool` στατιστικά στοιχεία αλλαγή σταδιακά, χρησιμοποιώντας κωδικό [ως εξής](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs). Μπορείτε επίσης να ανατρέξετε σε το `TimeoutException` μήνυμα από StackExchange.Redis. Ακολουθεί ένα παράδειγμα:

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

Στο μήνυμα παραπάνω, υπάρχουν διάφορα ζητήματα που είναι ενδιαφέρον:

 1. Σημειώστε ότι στα το `IOCP` ενότητας και το `WORKER` την ενότητα που έχετε μια `Busy` τιμή που είναι μεγαλύτερη από το `Min` τιμή. Αυτό σημαίνει ότι το `ThreadPool` ρυθμίσεις πρέπει να προσαρμόσετε.
 2. Μπορείτε επίσης να δείτε `in: 64221`. Αυτό υποδεικνύει ότι 64211 byte που έχουν ληφθεί στο επίπεδο υποδοχής του πυρήνα, αλλά δεν έχετε ακόμη διαβαστεί από την εφαρμογή (π.χ., StackExchange.Redis). Αυτό συνήθως σημαίνει ότι η εφαρμογή σας δεν την ανάγνωση δεδομένων από το δίκτυο ως γρήγορα ο διακομιστής είναι Αποστολή σε εσάς.

#### <a name="resolution"></a>Ανάλυση

Ρυθμίστε τις παραμέτρους των [Ρυθμίσεων νήμα](https://gist.github.com/JonCole/e65411214030f0d823cb) για να βεβαιωθείτε ότι ο χώρος συγκέντρωσης νήματος θα κλιμάκωσης γρήγορα στην περιοχή καταιγισμού σενάρια.


### <a name="high-client-cpu-usage"></a>Υψηλή προγράμματος-πελάτη της CPU

#### <a name="problem"></a>Πρόβλημα

Μεγάλη χρήση της CPU του υπολογιστή-πελάτη είναι μια ένδειξη ότι το σύστημα δεν είναι δυνατό να ανταποκριθεί με την εργασία που έχει ζητήσει να εκτελέσετε. Αυτό σημαίνει ότι ο υπολογιστής-πελάτης μπορεί να αποτύχει για να επεξεργαστείτε μια απάντηση από Redis έγκαιρα Παρόλο που Redis αποστέλλονται πολύ γρήγορα την απάντηση.

#### <a name="measurement"></a>Μέτρησης

Παρακολούθηση η χρήση της CPU ευρεία συστήματος μέσω της πύλης Azure ή μέσω του μετρητή συσχετισμένη απόδοσης. Προσέξτε να μην εποπτεία CPU *διαδικασίας* , επειδή μια απλή διαδικασία μπορούν να έχουν περιορισμένη χρήση CPU την ίδια στιγμή που συνολικό σύστημα CPU μπορεί να είναι υψηλή. Παρακολουθήστε για αιχμές στη χρήση της CPU που αντιστοιχούν με χρονικών ορίων. Ως αποτέλεσμα της CPU υψηλή, μπορεί επίσης να δείτε υψηλό `in: XXX` τιμές σε `TimeoutException` μηνύματα σφάλματος, όπως περιγράφεται στην ενότητα [καταιγισμού κυκλοφορίας](#burst-of-traffic) .

>[AZURE.NOTE] StackExchange.Redis 1.1.603 και αργότερα περιλαμβάνει το `local-cpu` μετρικό στο `TimeoutException` μηνύματα σφάλματος. Βεβαιωθείτε ότι χρησιμοποιείτε την πιο πρόσφατη έκδοση του [πακέτου StackExchange.Redis NuGet](https://www.nuget.org/packages/StackExchange.Redis/). Υπάρχουν σφάλματα συνεχώς που καθορίζεται στον κώδικα να την κάνετε πιο ισχυρό χρονικών ορίων, ώστε να είναι σημαντικό να έχετε την πιο πρόσφατη έκδοση.

#### <a name="resolution"></a>Ανάλυση

Αναβάθμιση σε μεγαλύτερο μέγεθος Εικονική με μεγαλύτερη χωρητικότητα CPU ή να διερευνήσουμε την αιτία CPU αιχμές. 



### <a name="client-side-bandwidth-exceeded"></a>Υπέρβαση του εύρους ζώνης πλευρά του προγράμματος-πελάτη

#### <a name="problem"></a>Πρόβλημα

Υπολογιστές διαφορετικό μέγεθος πελάτες έχουν περιορισμούς στην πόσο εύρος ζώνης δικτύου που έχουν διαθέσιμη. Εάν το πρόγραμμα-πελάτη υπερβαίνει το διαθέσιμο εύρος ζώνης, στη συνέχεια, δεδομένων δεν θα γίνει επεξεργασία στην πλευρά του προγράμματος-πελάτη ως γρήγορα ο διακομιστής στέλνει το. Αυτό μπορεί να οδηγήσει σε χρονικών ορίων.

#### <a name="measurement"></a>Μέτρησης

Παρακολουθήστε πώς σας χρήσης του εύρους ζώνης αλλάξετε σταδιακά, χρησιμοποιώντας κωδικό [ως εξής](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs). Σημειώστε ότι αυτός ο κωδικός ενδέχεται να μην λειτουργούν με επιτυχία σε ορισμένα περιβάλλοντα με περιορισμένα δικαιώματα (όπως Azure τοποθεσίες web).

#### <a name="resolution"></a>Ανάλυση 

Αύξηση του μεγέθους του προγράμματος-πελάτη Εικονική ή να μειώσετε την κατανάλωση εύρους ζώνης δικτύου.


### <a name="large-requestresponse-size"></a>Μέγεθος μεγάλο αίτηση/απάντηση

#### <a name="problem"></a>Πρόβλημα

Μια μεγάλη αίτηση/απάντηση μπορεί να προκαλέσει χρονικών ορίων. Ως παράδειγμα, ας υποθέσουμε ότι το χρονικό όριο τιμή που έχει ρυθμιστεί στον υπολογιστή-πελάτη είναι 1 δευτερόλεπτο. Η εφαρμογή σας ζητά δύο κλειδιά (π.χ. 'A' και 'B') ταυτόχρονα (χρησιμοποιώντας το ίδιο φυσική σύνδεση δικτύου). Τα περισσότερα προγράμματα-πελάτες υποστήριξης "Pipelining" των αιτήσεων, τέτοια ώστε και τα δύο 'A' και 'B' αποστέλλονται προσκλήσεις σε σύρματος στο διακομιστή ένα μετά το άλλο χωρίς να περιμένει τις απαντήσεις. Ο διακομιστής θα στείλει τις απαντήσεις ξανά με την ίδια σειρά. Εάν η απάντηση 'A' είναι μεγάλο αρκετά αυτό μπορεί να φαγητό περισσότερες του χρονικού ορίου για οι επακόλουθες απαιτήσεις. 

Το παρακάτω παράδειγμα παρουσιάζει αυτό το σενάριο. Σε αυτό το σενάριο, αίτηση 'A' και 'B' στην οποία αποστέλλονται γρήγορα, ο διακομιστής ξεκινά γρήγορη αποστολή απαντήσεων 'A' και 'B', αλλά λόγω φορές μεταφορά δεδομένων, 'B' χαθείτε πίσω από την πρόσκληση και χρόνος, παρόλο που ο διακομιστής απαντήσει γρήγορα.

  	|-------- 1 Second Timeout (A)----------|
  	|-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a>Μέτρησης

Αυτό είναι ένα δύσκολο να μετρήσετε. Στην ουσία πρέπει να μέσου σας κώδικα προγράμματος-πελάτη για να παρακολουθείτε μεγάλο προσκλήσεων και απαντήσεων. 

#### <a name="resolution"></a>Ανάλυση

1.  Redis είναι βελτιστοποιημένη για μεγάλο αριθμό μικρές τιμές, αντί να μερικά μεγάλες τιμές. Η προτιμώμενη λύση είναι να διασπάσετε τα δεδομένα σας σε σχετικό μικρότερες τιμές. Ανατρέξτε στο θέμα το [Τι είναι η περιοχή μέγεθος ιδανική τιμή για το redis; Είναι πολύ μεγάλο μέγεθος 100KB;](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) δημοσίευση για λεπτομέρειες γύρω από Γιατί προτείνονται οι μικρότερες τιμές.
2.  Αύξηση του μεγέθους του σας Εικονική (για υπολογιστή-πελάτη και διακομιστή Cache Redis), για να λάβετε υψηλότερη δυνατότητες εύρους ζώνης, μειώνοντας φορές μεταφορά δεδομένων για μεγαλύτερο απαντήσεις. Σημειώστε ότι γρήγορα περισσότερες εύρους ζώνης μόνο στο διακομιστή είτε μόνο από το πρόγραμμα-πελάτη ενδέχεται να μην είναι αρκετά. Μετρήστε το χρήσης του εύρους ζώνης και συγκρίνετε με τις δυνατότητες του μεγέθους του Εικονική έχετε τη συγκεκριμένη στιγμή.
3.  Αύξηση του αριθμού των `ConnectionMultiplexer` αντικείμενα που χρήση και προσκλήσεις round robin πάνω από διαφορετικές συνδέσεις.


### <a name="what-happened-to-my-data-in-redis"></a>Τι συνέβη στο Redis τα δεδομένα μου;

#### <a name="problem"></a>Πρόβλημα

Να αναμένεται για ορισμένα δεδομένα να είναι με την παρουσία μου Azure Redis Cache, αλλά αυτό δεν φαίνεται να βρίσκεται εκεί.

##### <a name="resolution"></a>Ανάλυση

Ανατρέξτε στο θέμα [Τι συνέβη με τα δεδομένα μου στο Redis;](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) για πιθανές αιτίες και λύσεις.


## <a name="server-side-troubleshooting"></a>Αντιμετώπιση προβλημάτων πλευρά του διακομιστή

Αυτή η ενότητα περιγράφει αντιμετώπισης προβλημάτων που παρουσιάζονται λόγω μια συνθήκη στο διακομιστή cache.

-   [Πίεση μνήμης στο διακομιστή](#memory-pressure-on-the-server)
-   [Μεγάλη χρήση της CPU / φόρτωση διακομιστή](#high-cpu-usage-server-load)
-   [Υπέρβαση του εύρους ζώνης πλευρά του διακομιστή](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a>Πίεση μνήμης στο διακομιστή

#### <a name="problem"></a>Πρόβλημα

Πίεση μνήμης στην πλευρά του διακομιστή σας καθοδηγεί σε κάθε είδους προβλήματα επιδόσεων που μπορεί να καθυστερήσει η επεξεργασία των αιτήσεων. Όταν επισκέψεις πίεση μνήμης, το σύστημα έχει συνήθως σελίδας δεδομένα από φυσική μνήμη στην εικονική μνήμη, που βρίσκεται στο δίσκο. Αυτό *ελαττωματική σελίδα* έχει ως αποτέλεσμα το σύστημα για να επιβραδύνετε σημαντικά. Υπάρχουν διάφορες πιθανές αιτίες αυτό πίεση μνήμης: 

1.  Έχετε συμπληρώσει το cache με δυνατότητα πλήρους με τα δεδομένα. 
2.  Redis βλέπει κατακερματισμός μνήμης high - πιο συχνά που προκαλούνται από την αποθήκευση μεγάλου αντικείμενα (Redis είναι βελτιστοποιημένη για μια μικρά αντικείμενα - να δείτε το [Τι είναι η περιοχή μέγεθος ιδανική τιμή για το redis; Είναι πολύ μεγάλο μέγεθος 100KB;](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) δημοσίευση για λεπτομέρειες). 

#### <a name="measurement"></a>Μέτρησης

Redis εκθέτει δύο μετρικά που μπορεί να σας βοηθήσει να αναγνωρίζετε αυτό το ζήτημα. Το πρώτο είναι `used_memory` και το άλλο είναι `used_memory_rss`. [Αυτές οι μετρήσεις](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) είναι διαθέσιμες στην πύλη του Azure ή μέσω της εντολής [Redis ΠΛΗΡΟΦΟΡΊΕΣ](http://redis.io/commands/info) .

#### <a name="resolution"></a>Ανάλυση

Υπάρχουν πολλές πιθανές αλλαγές που μπορείτε να κάνετε για να διατηρήσετε τη χρήση της μνήμης σε καλή κατάσταση:

1. [Ρύθμιση παραμέτρων μιας πολιτικής μνήμης](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) και ρύθμιση ώρα λήξης σε των αριθμών-κλειδιών. Σημειώστε ότι αυτό μπορεί να μην επαρκούν εάν έχετε κατακερματισμός.
2. [Ρύθμιση παραμέτρων maxmemory δεσμευμένη τιμή](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) που είναι αρκετά μεγάλος, ώστε να αποζημιώσει για κατακερματισμός μνήμης.
3. Διασπάσετε το μεγάλο στο cache αντικειμένων σε μικρότερο σχετικών αντικειμένων.
4. [Κλίμακα](cache-how-to-scale.md) σε μεγαλύτερο μέγεθος cache.
5. Εάν χρησιμοποιείτε ένα [cache premium με σύμπλεγμα Redis με δυνατότητα](cache-how-to-premium-clustering.md) μπορείτε να [αυξήσετε τον αριθμό των shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).

### <a name="high-cpu-usage--server-load"></a>Μεγάλη χρήση της CPU / φόρτωση διακομιστή

#### <a name="problem"></a>Πρόβλημα

Μεγάλη χρήση της CPU μπορεί να σημαίνει ότι μπορεί να αποτύχει στην πλευρά του προγράμματος-πελάτη για να επεξεργαστείτε μια απάντηση από Redis έγκαιρα Παρόλο που Redis αποστέλλονται πολύ γρήγορα την απάντηση.

#### <a name="measurement"></a>Μέτρησης

Παρακολούθηση η χρήση της CPU ευρεία συστήματος μέσω της πύλης Azure ή μέσω του μετρητή συσχετισμένη απόδοσης. Προσέξτε να μην εποπτεία CPU *διαδικασίας* , επειδή μια απλή διαδικασία μπορούν να έχουν περιορισμένη χρήση CPU την ίδια στιγμή που συνολικό σύστημα CPU μπορεί να είναι υψηλή. Παρακολουθήστε για αιχμές στη χρήση της CPU που αντιστοιχούν με χρονικών ορίων.

#### <a name="resolution"></a>Ανάλυση

[Κλίμακα](cache-how-to-scale.md) για περισσότερη μνήμη cache σειρά με μεγαλύτερη χωρητικότητα CPU ή διερευνήσουμε την αιτία CPU αιχμές. 

### <a name="server-side-bandwidth-exceeded"></a>Υπέρβαση του εύρους ζώνης πλευρά του διακομιστή

#### <a name="problem"></a>Πρόβλημα

Παρουσίες διαφορετικό μέγεθος cache έχουν περιορισμούς στην πόσο εύρος ζώνης δικτύου που έχουν διαθέσιμη. Εάν ο διακομιστής υπερβαίνει το διαθέσιμο εύρος ζώνης, στη συνέχεια, θα δεν η αποστολή δεδομένων στον υπολογιστή-πελάτη ως γρήγορα. Αυτό μπορεί να οδηγήσει σε χρονικών ορίων.

#### <a name="measurement"></a>Μέτρησης

Μπορείτε να παρακολουθείτε την `Cache Read` ανάγνωση μετρικό σύστημα, η οποία είναι η ποσότητα των δεδομένων από το cache σε megabyte ανά δευτερόλεπτο (MB/s) κατά το καθορισμένο χρονικό διάστημα αναφοράς. Αυτή η τιμή αντιστοιχεί το εύρος ζώνης δικτύου που χρησιμοποιείται από το cache. Εάν θέλετε να ρυθμίσετε ειδοποιήσεις για όρια εύρους ζώνης δικτύου πλευρά του διακομιστή, μπορείτε να τα δημιουργήσετε χρησιμοποιώντας αυτό `Cache Read` μετρητή. Συγκρίνετε τις ενδείξεις με τις τιμές σε [αυτόν τον πίνακα](cache-faq.md#cache-performance) για τα όρια παρατηρούμενη εύρους ζώνης για διάφορες cache τιμολόγησης βαθμίδες και μεγέθη.

#### <a name="resolution"></a>Ανάλυση

Εάν είστε με συνέπεια κοντά το παρατηρούμενη μέγιστο εύρος ζώνης για το τιμολόγησης επίπεδο και cache μέγεθος, εξετάστε το ενδεχόμενο [κλίμακας](cache-how-to-scale.md) μια τιμολόγησης επίπεδο ή το μέγεθος που έχει μεγαλύτερο εύρος ζώνης δικτύου, χρησιμοποιώντας τις τιμές σε [αυτόν τον πίνακα](cache-faq.md#cache-performance) ως οδηγό.


## <a name="stackexchangeredis-timeout-exceptions"></a>Εξαιρέσεις χρονικού ορίου StackExchange.Redis

StackExchange.Redis χρησιμοποιεί μια καθορισμένη ρύθμιση παραμέτρων `synctimeout` για σύγχρονη λειτουργίες που έχει μια προεπιλεγμένη τιμή του 1000 ms. Εάν μια σύγχρονη κλήση δεν ολοκληρωθεί στην ώρα που καθορίζονται, ο υπολογιστής-πελάτης StackExchange.Redis εμφανίζει ένα σφάλμα χρονικού ορίου παρόμοιο με το παρακάτω παράδειγμα.

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


Αυτό το μήνυμα σφάλματος περιέχει μετρικά που μπορεί να σας βοηθήσει να υποδείξει την αιτία και δυνατόν επίλυση του ζητήματος. Ο παρακάτω πίνακας περιέχει λεπτομέρειες σχετικά με τα μετρικά μήνυμα σφάλματος.

| Μέτρηση μήνυμα σφάλματος | Λεπτομέρειες                                                                                                                                                                                                                                          |
|------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ΜΗΧΑΝΩΝ       | Στο το τελευταίο χρόνος εκτέλεσης: έχουν εκδοθεί 0 εντολές                                                                                                                                                                                              |
| Mgr        | Αποδίδει τη Διαχείριση socket `socket.select` που σημαίνει ότι ζητά το λειτουργικό σύστημα για να υποδείξετε ότι μια υποδοχή που έχει κάτι για να κάνετε; βασικά: το πρόγραμμα ανάγνωσης δεν ενεργά διαβάζει από το δίκτυο επειδή αυτό δεν πιστεύετε ότι υπάρχει κάτι για να το κάνετε |
| ουρά      | Υπάρχουν 73 συνολικό λειτουργίες σε εξέλιξη                                                                                                                                                                                                        |
| Qu         | 6 από τις εργασίες σε εξέλιξη στην ουρά μη απεσταλμένων και δεν έχουν εγγραφεί ακόμη στο δίκτυο εξερχομένων                                                                                                                                                           |
| Qs         | 67 λειτουργιών σε εξέλιξη he έχουν αποσταλεί στο διακομιστή, αλλά απόκριση δεν είναι ακόμη διαθέσιμη. Θα μπορούσε να είναι η απόκριση `Not yet sent by the server` ή`sent by the server but not yet processed by the client.`                                                   |
| QC         | 0 από τις εργασίες σε εξέλιξη είδατε απαντήσεις, αλλά δεν έχει επισημανθεί ακόμα ως ολοκληρωμένη λόγω αναμονή σε βρόχο ολοκλήρωσης                                                                                                                                      |
| wR         | Υπάρχει ένα ενεργό writer (δηλαδή, τις αιτήσεις 6 μη απεσταλμένων δεν παραβλέπονται) byte που/activewriters                                                                                                                                                   |
| στο         | Υπάρχουν χωρίς ενεργό προγράμματα ανάγνωσης και είναι διαθέσιμες για ανάγνωση στην το NIC byte που/activereaders μηδέν byte                                                                                                                                               |


### <a name="steps-to-investigate"></a>Βήματα για να διερευνήσουμε

1. Ως βέλτιστη πρακτική βεβαιωθείτε ότι χρησιμοποιείτε το ακόλουθο μοτίβο για σύνδεση κατά τη χρήση του προγράμματος-πελάτη StackExchange.Redis.


        private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
        {
            return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
        });
    
        public static ConnectionMultiplexer Connection
        {
            get
            {
                return lazyConnection.Value;
            }
        }


    Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [σύνδεση στο cache χρησιμοποιώντας StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).

2. Βεβαιωθείτε ότι το Cache Redis Azure και την εφαρμογή-πελάτη είναι στην ίδια περιοχή στο Azure. Για παράδειγμα, μπορείτε ίσως να λαμβάνετε χρονικών ορίων όταν το cache βρίσκεται σε Ανατολικής η.π.α., αλλά το πρόγραμμα-πελάτη είναι στη δυτική ΗΠΑ και την αίτηση δεν ολοκληρώθηκε εντός του `synctimeout` διάστημα ή που μπορεί να γρήγορα χρονικών ορίων όταν εκτελείτε εντοπισμού σφαλμάτων από τον υπολογιστή σας τοπικής ανάπτυξης. 

    Συνιστάται ιδιαίτερα να έχετε το cache και στο πρόγραμμα-πελάτη στην ίδια περιοχή Azure. Εάν έχετε ένα σενάριο που περιλαμβάνει τις κλήσεις διασταύρωσης περιοχή, θα πρέπει να ορίσετε το `synctimeout` διαστήματος σε τιμή μεγαλύτερη από το προεπιλεγμένο χρονικό διάστημα 1000 ms, συμπεριλαμβάνοντας μια `synctimeout` ιδιότητα στη συμβολοσειρά σύνδεσης. Το παρακάτω παράδειγμα εμφανίζει ένα απόκομμα συμβολοσειρά StackExchange.Redis cache σύνδεσης με μια `synctimeout` της 2000 ms.

        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...

3. Βεβαιωθείτε ότι χρησιμοποιείτε την πιο πρόσφατη έκδοση του [πακέτου StackExchange.Redis NuGet](https://www.nuget.org/packages/StackExchange.Redis/). Υπάρχουν σφάλματα συνεχώς που καθορίζεται στον κώδικα να την κάνετε πιο ισχυρό χρονικών ορίων, ώστε να είναι σημαντικό να έχετε την πιο πρόσφατη έκδοση.

4. Εάν υπάρχουν αιτήσεις που γρήγορα συνδέονται με τους περιορισμούς εύρους ζώνης στο διακομιστή ή στο πρόγραμμα-πελάτη, θα χρειαστεί περισσότερος χρόνος για να ολοκληρωθεί και συνεπώς να προκαλέσουν χρονικών ορίων. Για να δείτε εάν το χρονικό όριο οφείλεται εύρος ζώνης δικτύου στο διακομιστή, ανατρέξτε στο θέμα [υπέρβαση του εύρους ζώνης πλευρά του διακομιστή](#server-side-bandwidth-exceeded). Για να δείτε εάν το χρονικό όριο οφείλεται εύρος ζώνης δικτύου του προγράμματος-πελάτη, ανατρέξτε στο θέμα [υπέρβαση του εύρους ζώνης πλευρά του προγράμματος-πελάτη](#client-side-bandwidth-exceeded).

6. Μπορείτε γρήγορα CPU είναι συνδεδεμένη στο διακομιστή ή του υπολογιστή-πελάτη;
    -   Ελέγξτε εάν μπορείτε γρήγορα συνδέονται με CPU στον υπολογιστή-πελάτη που μπορεί να προκαλέσει την αίτηση να μην γίνεται επεξεργασία μέσα σε το `synctimeout` χρονικό διάστημα, προκαλώντας έτσι ένα χρονικό όριο. Μετακίνηση σε μεγαλύτερο μέγεθος προγράμματος-πελάτη ή τη διανομή η φόρτωση μπορούν να σας βοηθήσουν να επιτύχετε. 
    -   Έλεγχος εάν λαμβάνετε CPU δεσμευμένο στο διακομιστή, παρακολουθώντας την `CPU` [μετρικό σύστημα επιδόσεων cache](cache-how-to-monitor.md#available-metrics-and-reporting-intervals). Αιτήσεις σύντομα ενώ Redis είναι δεσμευμένο CPU μπορεί να προκαλέσει αυτά τα αιτήματα σε χρονικό όριο. Για να το αντιμετωπίσετε μπορείτε να διανομή η φόρτωση σε πολλές shards σε μνήμη cache premium ή αναβάθμιση σε ένα μεγαλύτερο μέγεθος ή τις πληροφορίες τιμολόγησης σειρά. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [Υπέρβαση εύρους ζώνης πλευρά του διακομιστή](#server-side-bandwidth-exceeded).

7. Υπάρχουν εντολές διαρκεί πολύ χρόνο για την επεξεργασία στο διακομιστή; Χρόνο εκτελεί εντολές που διαρκεί πολύ χρόνο για επεξεργασία στο διακομιστή redis μπορεί να προκαλέσει χρονικών ορίων. Ορισμένα παραδείγματα μεγάλης διάρκειας εντολές είναι `mget` με μεγάλου αριθμού πλήκτρα, `keys *` ή ακατάλληλα εγγραφή lua δεσμών ενεργειών. Μπορείτε να συνδεθείτε στην περίοδο λειτουργίας του Azure Redis Cache χρησιμοποιώντας το πρόγραμμα-πελάτη redis cli ή να χρησιμοποιήσετε την [Κονσόλα Redis](cache-configure.md#redis-console) και εκτελέστε την εντολή [SlowLog](http://redis.io/commands/slowlog) για να δείτε εάν υπάρχουν αιτήσεις διαρκεί περισσότερο από το αναμενόμενο. Διακομιστής redis και StackExchange.Redis είναι βελτιστοποιημένα για πολλές μικρές αιτήσεις και όχι λιγότερα μεγάλο αιτήσεις. Διαίρεση των δεδομένων σας σε μικρότερο μέγεθος μπλοκ μπορεί να βελτιώσει πράγματα εδώ. 

    Για πληροφορίες σχετικά με τη σύνδεση με το τελικό σημείο Azure Redis Cache SSL χρησιμοποιώντας redis cli και stunnel, ανατρέξτε στην καταχώρηση ιστολογίου [Ανακοίνωση ASP.NET κατάσταση υπηρεσίας παροχής περιόδου λειτουργίας για Redis Preview](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) . Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [SlowLog](http://redis.io/commands/slowlog).

8. Υψηλή φόρτωση διακομιστή Redis μπορεί να προκαλέσει χρονικών ορίων. Μπορείτε να παρακολουθήσετε το φόρτο του διακομιστή, παρακολουθώντας την `Redis Server Load` [μετρικό σύστημα επιδόσεων cache](cache-how-to-monitor.md#available-metrics-and-reporting-intervals). Φόρτωση διακομιστή 100 (μέγιστη τιμή) υποδεικνύει ότι ο διακομιστής redis έχει απασχολημένος, δεν υπάρχει χρόνος αδράνειας, αιτήσεις επεξεργασίας. Για να δείτε εάν εκτελείτε ορισμένες αιτήσεις ασφαλείας όλων των δυνατοτήτων του διακομιστή, εκτελέστε την εντολή SlowLog, όπως περιγράφεται στην προηγούμενη παράγραφο. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [χρήση CPU υψηλής / φόρτωση διακομιστή](#high-cpu-usage-server-load).

9. Ήταν εκεί οποιοδήποτε άλλο συμβάν στην πλευρά προγράμματος-πελάτη που θα μπορούσε να προκληθεί ένα blip δικτύου; Έλεγχος του υπολογιστή-πελάτη (web, ρόλο εργαζόμενου ή μια Εικονική Iaas) Εάν υπήρχε κάποιο συμβάν όπως κλιμάκωση τον αριθμό των εμφανίσεων προγράμματος-πελάτη προς τα επάνω ή προς τα κάτω ή για την ανάπτυξη μια νέα έκδοση του προγράμματος-πελάτη ή αυτόματης κλίμακας είναι ενεργοποιημένο; Σε μας δοκιμών που έχουν βρέθηκαν ότι μπορεί να προκαλέσει autoscale ή κλιμάκωση επάνω/κάτω σύνδεσης εξερχομένων δικτύου μπορεί να χαθούν για μερικά δευτερόλεπτα. Κωδικός StackExchange.Redis είναι είναι ανθεκτικά στις τέτοια συμβάντα και θα συνδεθείτε ξανά. Σε αυτό κατά τη διάρκεια της σύνδεσης εκ νέου τις αιτήσεις στην ουρά να λήξει το χρονικό όριο.

10. Ήταν αίτησης μεγάλο πριν από διάφορες μικρές αιτήσεις στο cache Redis που έχουν λήξει; Η παράμετρος `qs` στο σφάλμα μήνυμα σας ενημερώνει πόσες αιτήσεις έχουν σταλεί από το πρόγραμμα-πελάτη στο διακομιστή, αλλά δεν έχετε ακόμη επεξεργασία μια απάντηση. Αυτή η τιμή μπορεί να διατηρήσετε ανάπτυξη επειδή StackExchange.Redis χρησιμοποιεί μια μοναδική σύνδεση TCP και μπορεί να διαβάσει μόνο μία απάντηση κάθε φορά. Παρόλο που η πρώτη λειτουργία έληξε, δεν εμποδίζει τα δεδομένα που στέλνεται προς/από το διακομιστή και άλλες αιτήσεις αποκλείονται αυτό έχει ολοκληρωθεί, προκαλεί λήξεις χρονικών ορίων. Μια λύση είναι να ελαχιστοποιήσετε τις πιθανότητες να χρονικών ορίων, εξασφαλίζοντας ότι το cache είναι αρκετά μεγάλο για το φόρτο εργασίας και διαίρεση μεγάλες τιμές σε μικρότερο μέγεθος μπλοκ. Κάποια άλλη πιθανή λύση είναι να χρησιμοποιήσετε ένα χώρο συγκέντρωσης `ConnectionMultiplexer` αντικείμενα στο πρόγραμμα-πελάτη και επιλέξτε φόρτωση τουλάχιστον `ConnectionMultiplexer` κατά την αποστολή μιας νέας αίτησης. Αυτό θα πρέπει να εμποδίσει ένα μεμονωμένο χρονικό όριο προκαλεί άλλων αιτημάτων επίσης χρονικού ορίου.

11. Εάν χρησιμοποιείτε `RedisSessionStateprovider`, βεβαιωθείτε ότι έχετε ορίσει σωστά το χρονικό όριο "Επανάληψη". `retrytimeoutInMilliseconds`θα πρέπει να είναι υψηλότερα από `operationTimeoutinMilliseonds`, αλλιώς θα παρουσιαστεί καμία επανάληψη. Στο παρακάτω παράδειγμα `retrytimeoutInMilliseconds` έχει οριστεί σε 3000. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [ASP.NET περιόδου λειτουργίας κατάσταση υπηρεσίας παροχής για Azure Redis Cache](cache-aspnet-session-state-provider.md) και [πώς μπορείτε να χρησιμοποιήσετε τη ρύθμιση παραμέτρων της υπηρεσίας παροχής κατάσταση περιόδου λειτουργίας και παροχής Cache εξόδου](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).


    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


12. Ελέγξτε τη χρήση μνήμης στο διακομιστή Azure Redis Cache, [παρακολουθώντας](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` και `Used Memory`. Εάν μια πολιτική eviction είναι σε θέση, ξεκινά Redis evicting πλήκτρα όταν `Used_Memory` φτάσει το μέγεθος του cache. Ιδανικά, `Used Memory RSS` μόνο πρέπει να είναι λίγο υψηλότερα από `Used memory`. Μεγάλη διαφορά σημαίνει ότι ο κατακερματισμός μνήμης (εσωτερική ή εξωτερική. Όταν `Used Memory RSS` είναι μικρότερη από `Used Memory`, αυτό σημαίνει ότι το τμήμα της μνήμης cache έχει αντικατασταθεί από το λειτουργικό σύστημα. Αν συμβεί αυτό, μπορείτε να περιμένετε ορισμένες σημαντικές των αδρανειών. Επειδή Redis δεν έχει τον έλεγχό πώς τις αναθέσεις έχουν αντιστοιχιστεί σελίδων μνήμης, υψηλή `Used Memory RSS` είναι συχνά το αποτέλεσμα ενός συλλέκτη της χρήσης της μνήμης. Όταν Redis ελευθερώνει μνήμη, η μνήμη παίρνετε ξανά το πρόγραμμα εκχώρησης και το πρόγραμμα εκχώρησης ενδέχεται να ή ενδέχεται να μην δώσει τη μνήμη πίσω στο σύστημα. Μπορεί να υπάρχουν ασυμφωνία μεταξύ του `Used Memory` τιμή και μνήμης κατανάλωση καθώς αναφέρεται από το λειτουργικό σύστημα. Μπορεί να είναι λόγω το γεγονός μνήμης έχει χρησιμοποιηθεί και κυκλοφορήσει από Redis, αλλά όχι η δεδομένη πίσω στο σύστημα. Για να συμβάλει στην αντιμετώπιση προβλημάτων μνήμης, μπορείτε να εκτελέσετε τα παρακάτω βήματα.
    -   Αναβάθμιση του cache σε μεγαλύτερο μέγεθος, ώστε να μην χρησιμοποιείτε με τους περιορισμούς μνήμης στο σύστημα.
    -   Ορισμός λήξης φορές στα πλήκτρα ώστε παλαιότερων τιμές έχουν καταργηθεί η εκ των προτέρων.
    -   Οθόνη του το `used_memory_rss` cache μετρικό σύστημα. Όταν αυτή η τιμή πλησιάζει το μέγεθος του cache τους, είναι πιθανό να ξεκινήσετε βλέπουν θέματα απόδοσης. Διανομή των δεδομένων σε πολλές shards εάν είναι χρησιμοποιώντας ένα cache premium ή αναβάθμιση σε μεγαλύτερο μέγεθος cache.

    Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [Πίεση μνήμης στο διακομιστή](#memory-pressure-on-the-server).

## <a name="additional-information"></a>Πρόσθετες πληροφορίες

-   [Τι Redis Cache προσφοράς και το μέγεθος πρέπει να χρησιμοποιήσω;](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
-   [Πώς μπορώ να σημείων αναφοράς και ελέγξτε την απόδοση του cache μου;](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
-   [Πώς μπορώ να εκτελέσω εντολές Redis;](cache-faq.md#how-can-i-run-redis-commands)
-   [Πώς μπορείτε να παρακολουθείτε Azure Redis Cache](cache-how-to-monitor.md)