<properties 
    pageTitle="Σύνταξη SQL και SQL ερωτήματος για DocumentDB | Microsoft Azure" 
    description="Μάθετε σχετικά με τη σύνταξη SQL, έννοιες βάσης δεδομένων και τα ερωτήματα SQL για DocumentDB, NoSQL βάσης δεδομένων. SQL μπορεί να χρησιμοποιηθεί ως μια γλώσσα ερωτημάτων JSON στο DocumentDB." 
    keywords="σύνταξη SQL, το ερώτημα sql, ερωτήματα sql, json γλώσσα ερωτημάτων, έννοιες βάσης δεδομένων και ερωτήματα sql, συναρτήσεις συγκεντρωτικών αποτελεσμάτων"
    services="documentdb" 
    documentationCenter="" 
    authors="arramac" 
    manager="jhubbard" 
    editor="monicar"/>

<tags 
    ms.service="documentdb" 
    ms.workload="data-services" 
    ms.tgt_pltfrm="na" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.date="10/27/2016" 
    ms.author="arramac"/>

# <a name="sql-query-and-sql-syntax-in-documentdb"></a>Ερώτημα SQL και σύνταξη SQL στο DocumentDB
Microsoft Azure DocumentDB υποστηρίζει κατά την αναζήτηση εγγράφων με χρήση SQL (Structured Query Language) ως μια γλώσσα ερωτημάτων JSON. DocumentDB είναι πραγματικά χωρίς σχήματος. Σύμφωνα με τις δέσμευσης στο μοντέλο δεδομένων JSON απευθείας μέσα από το μηχανισμό βάσεων δεδομένων, παρέχει αυτόματης δημιουργίας ευρετηρίου για έγγραφα JSON χωρίς να απαιτείται ρητή διάταξη ή Δημιουργία δευτερεύουσας ευρετηρίων. 

Κατά τη σχεδίαση της γλώσσας ερωτήματος για DocumentDB έπρεπε δύο στόχους υπόψη:

-   Αντί να inventing μια νέα γλώσσα ερωτημάτων JSON, θέλουμε να υποστηρίζουν SQL. SQL είναι μία από τις πιο οικείο και δημοφιλείς γλώσσες ερωτήματος. DocumentDB SQL παρέχει μια επίσημη μοντέλο προγραμματισμού για εμπλουτισμένου ερωτήματα μέσω JSON έγγραφα.
-   Ως JSON εγγράφου βάσης δεδομένων με δυνατότητα εκτέλεσης JavaScript απευθείας από το μηχανισμό βάσεων δεδομένων, θέλουμε να χρησιμοποιήστε μοντέλο προγραμματισμού του JavaScript ως βάση για τη γλώσσα ερωτήματος. Το SQL DocumentDB βρίσκεται στο σύστημα τύπου της JavaScript, η αξιολόγηση της παράστασης και συνάρτηση κλήσης. Σε αυτό σε Ενεργοποίηση παρέχει ένα μοντέλο φυσική προγραμματισμού για σχεσιακές προβλέψεις, ιεραρχική περιήγησης μεταξύ JSON έγγραφα, αυτόματης συνδέσμους, χώρου ερωτήματα και κλήση συναρτήσεων που ορίζονται από το χρήστη (UDF) συνταχθεί εντελώς σε JavaScript, μεταξύ άλλων δυνατοτήτων. 

Θα σας πιστεύετε ότι αυτές οι δυνατότητες είναι βασικά στοιχεία για τη μείωση του τριβής μεταξύ της εφαρμογής και τη βάση δεδομένων και είναι κρίσιμης σημασίας για παραγωγικότητα προγραμματιστής.

Συνιστάται να γρήγορα αποτελέσματα, παρακολουθώντας βίντεο που ακολουθεί, όπου Aravind Ramachandran εμφανίζει κατά την υποβολή ερωτήματος δυνατότητες του DocumentDB, και μεταβαίνοντας [Ερωτήματος Αναδειχτείτε](http://www.documentdb.com/sql/demo)μας, όπου μπορείτε να δοκιμάσετε DocumentDB και να εκτελέσετε ερωτήματα SQL σε σχέση με το σύνολο δεδομένων.

> [AZURE.VIDEO dataexposedqueryingdocumentdb]

Στη συνέχεια, επιστρέψτε σε αυτό το άρθρο, όπου Ας ξεκινήσουμε με ένα πρόγραμμα εκμάθησης ερώτημα SQL που σας καθοδηγεί σε ορισμένα απλά JSON έγγραφα και εντολών SQL.

## <a name="getting-started-with-sql-commands-in-documentdb"></a>Γρήγορα αποτελέσματα με το εντολών SQL στο DocumentDB
Για να δείτε DocumentDB SQL στην εργασία, ας αρχίζουν με μερικά απλά JSON έγγραφα και θα καθοδηγήσουν ορισμένα απλά ερωτήματα σε σχέση με το. Εξετάστε το ενδεχόμενο αυτά τα δύο έγγραφα JSON σχετικά με τις δύο οικογένειες. Σημειώστε ότι με DocumentDB, θα σας δεν χρειάζεται να δημιουργήσετε οποιαδήποτε σχήματα ή δευτερεύοντα δεικτών ρητά. Απλώς πρέπει να εισαγάγετε τα έγγραφα JSON σε μια συλλογή DocumentDB και στη συνέχεια ερωτήματος. Εδώ έχουμε μια απλή JSON για την οικογένεια Ηλιοπούλου, των γονικών στοιχείων, θυγατρικά στοιχεία (και τους οικιακών), διεύθυνση και καταχώρηση πληροφορίες εγγράφου. Το έγγραφο έχει συμβολοσειρές, αριθμοί, λογικές τιμές, πίνακες και ένθετων ιδιότητες. 

**Έγγραφο**  

    {
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }


Ακολουθεί ένα δεύτερο έγγραφο με μια διακριτική διαφορά – `givenName` και `familyName` που χρησιμοποιούνται αντί `firstName` και `lastName`.

**Έγγραφο**  

    {
        "id": "WakefieldFamily",
        "parents": [
            { "familyName": "Wakefield", "givenName": "Robin" },
            { "familyName": "Miller", "givenName": "Ben" }
        ],
        "children": [
            {
                "familyName": "Merriam", 
                "givenName": "Jesse", 
                "gender": "female", "grade": 1,
                "pets": [
                    { "givenName": "Goofy" },
                    { "givenName": "Shadow" }
                ]
            },
            { 
                "familyName": "Miller", 
                 "givenName": "Lisa", 
                 "gender": "female", 
                 "grade": 8 }
        ],
        "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
        "creationDate": 1431620462,
        "isRegistered": false
    }



Τώρα ας δοκιμάσουμε μερικά ερωτήματα σε σχέση με αυτά τα δεδομένα για να κατανοήσετε ορισμένες από τις βασικές πτυχές της DocumentDB SQL. Για παράδειγμα, το ακόλουθο ερώτημα θα επιστρέψει τα έγγραφα όπου το πεδίο "αναγνωριστικό" ταιριάζει με `AndersenFamily`. Καθώς πρόκειται για μια `SELECT *`, η ολοκλήρωση εγγράφου JSON είναι το αποτέλεσμα του ερωτήματος:

**Ερώτημα**

    SELECT * 
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]


Τώρα μπορείτε να την περίπτωση όπου πρέπει να διαμορφώσετε τα δεδομένα εξόδου JSON σε ένα άλλο σχήμα. Αυτό το ερώτημα έργα ενός νέου αντικειμένου JSON με δύο επιλεγμένα πεδία, όνομα και Πόλη, κατά πόλη στη διεύθυνση έχει το ίδιο όνομα με την κατάσταση. Σε αυτήν την περίπτωση, αντιστοιχίζει "NY, NY".

**Ερώτημα**   

    SELECT {"Name":f.id, "City":f.address.city} AS Family 
    FROM Families f 
    WHERE f.address.city = f.address.state

**Αποτελέσματα**

    [{
        "Family": {
            "Name": "WakefieldFamily", 
            "City": "NY"
        }
    }]


Το επόμενο ερώτημα επιστρέφει όλα τα ονόματα δεδομένο παιδιών στην οικογένεια προγραμμάτων του οποίου το αναγνωριστικό αντιστοιχεί `WakefieldFamily` σύμφωνα με την Πόλη κατοικίας.

**Ερώτημα**

    SELECT c.givenName 
    FROM Families f 
    JOIN c IN f.children 
    WHERE f.id = 'WakefieldFamily'
    ORDER BY f.address.city ASC

**Αποτελέσματα**

    [
      { "givenName": "Jesse" }, 
      { "givenName": "Lisa"}
    ]


Προτείνεται να τραβήξετε την προσοχή σε μερικά αξιοσημείωτα πτυχές της γλώσσας ερωτήματος DocumentDB έως τα παραδείγματα που θα σας έχετε δει μέχρι στιγμής:  
 
-   Επειδή το DocumentDB SQL λειτουργεί σε τιμές JSON, ασχολείται με δέντρου σε σχήμα οντοτήτων αντί για γραμμές και στήλες. Επομένως, τη γλώσσα σας επιτρέπει να αναφέρονται σε κόμβους του δέντρου στο οποιαδήποτε τυχαίο βάθος, όπως `Node1.Node2.Node3…..Nodem`, παρόμοια με σχεσιακές SQL που αναφέρονται σε την αναφορά δύο τμημάτων της `<table>.<column>`.   
-   Η γλώσσα structured query λειτουργεί με σχήμα χωρίς δεδομένα. Επομένως, το σύστημα τύπος πρέπει να είναι συνδεδεμένο δυναμικά. Η ίδια παράσταση μπορεί να δώσει διαφορετικούς τύπους σε διαφορετικά έγγραφα. Το αποτέλεσμα του ερωτήματος είναι μια έγκυρη τιμή JSON, αλλά δεν εγγυάται να είναι σταθερή ενός σχήματος.  
-   DocumentDB υποστηρίζει μόνο αυστηρών JSON εγγράφων. Αυτό σημαίνει ότι το σύστημα τύπος και παραστάσεις είναι περιορισμένα να χειριστείτε μόνο με τους τύπους JSON. Ανατρέξτε στις [προδιαγραφές JSON](http://www.json.org/) για περισσότερες λεπτομέρειες.  
-   Μια συλλογή DocumentDB είναι ένα σχήμα χωρίς κοντέινερ JSON εγγράφων. Οι σχέσεις οντοτήτων δεδομένων εντός και μεταξύ των εγγράφων σε μια συλλογή καταγράφονται ρητά από περιορισμού και όχι από πρωτεύον κλειδί και εξωτερικό κλειδί σχέσεις. Αυτή είναι μια σημαντική πτυχή αξίζει παραπέμπουν σε λόγω συνδέσμους εντός εγγράφου περιγράφεται παρακάτω σε αυτό το άρθρο.

## <a name="documentdb-indexing"></a>Δημιουργία ευρετηρίου DocumentDB

Πριν από την λαμβάνουμε σε τη σύνταξη DocumentDB SQL, αξίζει Εξερεύνηση της δημιουργίας ευρετηρίου σχεδίασης στο DocumentDB. 

Είναι ο σκοπός της βάσης δεδομένων ευρετήρια για να εξυπηρετήσει τα ερωτήματα σε τους διάφορους φόρμες και σχήματα με κατανάλωση ελάχιστη πόρων (όπως CPU και εισόδου/εξόδου) ενώ παρέχει καλή μετάδοσης και χαμηλής λανθάνοντος χρόνου. Συχνά, η επιλογή από το σωστό ευρετήριο για την υποβολή ερωτημάτων σε μια βάση δεδομένων απαιτεί πολύ σχεδιασμού και πειραματισμός. Αυτή η προσέγγιση θέτει δύσκολο για βάσεις δεδομένων σχήματος λιγότερο όπου τα δεδομένα δεν συμμορφώνεται με ένα σχήμα αντικειμενική και εξελιχθεί γρήγορα. 

Γι ' αυτό, όταν σας έχει σχεδιαστεί η δημιουργία ευρετηρίου υποσυστήματος DocumentDB, μπορούμε να εγκαταστήσουμε τους ακόλουθους στόχους:

-   Ευρετήριο έγγραφα χωρίς να απαιτείται σχήματος: υποσυστήματος δημιουργίας ευρετηρίου δεν απαιτούν οποιεσδήποτε πληροφορίες σχήματος ή για να κάνετε τις υποθέσεις σχετικά με διάταξη από τα έγγραφα. 

-   Υποστήριξη για αποτελεσματική και εμπλουτισμένων ιεραρχική και σχεσιακές ερωτήματα: το ευρετήριο υποστηρίζει τη γλώσσα ερωτήματος DocumentDB αποτελεσματικά, συμπεριλαμβανομένης της υποστήριξης για ιεραρχική και σχεσιακούς προβλέψεις.

-   Υποστήριξη για συνεπή ερωτήματα μετά τις μια σταθερή ένταση εγγραφών: για υψηλή εγγραφής φόρτους εργασίας μετάδοσης με συνεπή ερωτήματα, το ευρετήριο ενημερώνεται βαθμιαία αποτελεσματικά και online λόγω μια σταθερή ένταση εγγραφών. Η ενημέρωση του ευρετηρίου συνεπή είναι κρίσιμης σημασίας για να εξυπηρετήσει τα ερωτήματα στο επίπεδο της συνέπειας στο οποίο ο χρήστης ρύθμιση των παραμέτρων της υπηρεσίας εγγράφου.

-   Υποστήριξη για πολλαπλή μίσθωση: δίνεται στο μοντέλο βάσει δέσμευσης για διακυβέρνησης πόρων σε μισθωτές, ενημερώσεις ευρετηρίου εκτελούνται εντός προϋπολογισμού πόρους του συστήματος (CPU, μνήμης και λειτουργίες εισαγωγής/εξαγωγής ανά δευτερόλεπτο) έχει εκχωρηθεί ανά αντιγράφου. 

-   Χώρος αποθήκευσης της αποδοτικότητας: κόστους αποτελεσματικότητας, το χώρο αποθήκευσης στο δίσκο επιβάρυνσης του ευρετηρίου είναι συνδεδεμένες και προβλέψιμα. Αυτό είναι κρίσιμης σημασίας, επειδή DocumentDB επιτρέπει ο προγραμματιστής για να κάνετε ισορροπιών κόστος βάσει μεταξύ ευρετηρίου επιβάρυνσης σχέση με τις επιδόσεις του ερωτήματος.  

Ανατρέξτε στα [δείγματα DocumentDB](https://github.com/Azure/azure-documentdb-net) στο MSDN για δείγματα που δείχνει πώς να ρυθμίσετε τις παραμέτρους της πολιτικής δημιουργίας ευρετηρίου για μια συλλογή. Ας ξεκινήσουμε τώρα τις λεπτομέρειες των τη σύνταξη DocumentDB SQL.


## <a name="basics-of-a-documentdb-sql-query"></a>Βασικά στοιχεία για ένα ερώτημα DocumentDB SQL
Κάθε ερώτημα αποτελείται από έναν όρο SELECT και προαιρετικά FROM και WHERE ανά πρότυπα ANSI SQL. Συνήθως, για κάθε ερώτημα, το αρχείο προέλευσης από τον όρο FROM είναι η απαρίθμηση. Στη συνέχεια, το φίλτρο στον όρο WHERE εφαρμόζεται στο αρχείο προέλευσης για να ανακτήσετε ένα υποσύνολο των εγγράφων JSON. Τέλος, ο όρος SELECT χρησιμοποιείται για το project τις απαιτούμενες τιμές JSON στη λίστα select.
    
    SELECT [TOP <top_expression>] <select_list> 
    [FROM <from_specification>] 
    [WHERE <filter_condition>]
    [ORDER BY <sort_specification]    


## <a name="from-clause"></a>ΑΠΌ τον όρο FROM
Το `FROM <from_specification>` όρος είναι προαιρετική, εκτός εάν το αρχείο προέλευσης είναι φιλτραρισμένο ή προβλεπόμενου αργότερα στο ερώτημα. Ο σκοπός της αυτός ο όρος είναι για να καθορίσετε το αρχείο προέλευσης δεδομένων κατά την οποία πρέπει να λειτουργούν το ερώτημα. Συνήθως ολόκληρη η συλλογή είναι η προέλευση, αλλά μπορείτε να καθορίσετε ένα υποσύνολο της συλλογής αντί για αυτό. 

Ένα ερώτημα, όπως `SELECT * FROM Families` υποδεικνύει ότι το ολόκληρη τη συλλογή των οικογενειών είναι η προέλευση βάσει του οποίου απαρίθμηση. Ένα ειδικό αναγνωριστικό ΡΊΖΑΣ μπορεί να χρησιμοποιηθεί για να αναπαραστήσετε τη συλλογή αντί να χρησιμοποιήσετε το όνομα της συλλογής. Η παρακάτω λίστα περιέχει τους κανόνες που επιβάλλονται ανά ερώτημα:

- Η συλλογή μπορεί να είναι με ψευδώνυμο, όπως `SELECT f.id FROM Families AS f` ή απλώς `SELECT f.id FROM Families f`. Δείτε εδώ `f` ισοδυναμεί με `Families`. `AS`είναι μια προαιρετική λέξη-κλειδί στο ψευδώνυμο το αναγνωριστικό.

-   Σημειώστε ότι μία φορά με ψευδώνυμο, το αρχικό αρχείο προέλευσης δεν μπορεί να είναι συνδεδεμένο. Για παράδειγμα, `SELECT Families.id FROM Families f` είναι έγκυρη σύνταξη εφόσον το αναγνωριστικό "Οικογένειες" δεν είναι δυνατό να επιλυθούν πλέον.

-   Όλες οι ιδιότητες που πρέπει να γίνει παραπομπή πρέπει να είναι πλήρως προσδιορισμένη. Κατά την απουσία τήρησης σχήματος, αυτό τίθεται σε ισχύ για να αποφύγετε τυχόν διφορούμενων συνδέσεις. Γι ' αυτό, `SELECT id FROM Families f` είναι έγκυρη σύνταξη από την ιδιότητα `id` δεν είναι συνδεδεμένο.
    
### <a name="sub-documents"></a>Δευτερεύουσα εγγράφων
Το αρχείο προέλευσης μπορεί να μειωθεί επίσης σε ένα υποσύνολο μικρότερο μέγεθος. Για παράδειγμα, για να απαρίθμηση μόνο ένα δευτερεύον δέντρο σε κάθε έγγραφο, δευτερεύουσες ριζικό κατάλογο θα μπορούσε να, στη συνέχεια, γίνονται το αρχείο προέλευσης, όπως φαίνεται στο παρακάτω παράδειγμα.

**Ερώτημα**

    SELECT * 
    FROM Families.children

**Αποτελέσματα**  

    [
      [
        {
            "firstName": "Henriette Thaulow",
            "gender": "female",
            "grade": 5,
            "pets": [
              {
                  "givenName": "Fluffy"
              }
            ]
        }
      ],
      [
        {
            "familyName": "Merriam",
            "givenName": "Jesse",
            "gender": "female",
            "grade": 1
        },
        {
            "familyName": "Miller",
            "givenName": "Lisa",
            "gender": "female",
            "grade": 8
        }
      ]
    ]

Ενώ το παραπάνω παράδειγμα χρησιμοποιείται ενός πίνακα ως προέλευση, ένα αντικείμενο μπορεί επίσης να χρησιμοποιηθεί ως η προέλευση, η οποία είναι τι εμφανίζεται στο παρακάτω παράδειγμα. Για να συμπεριληφθούν στο αποτέλεσμα του ερωτήματος θα θεωρούνται οποιαδήποτε έγκυρη JSON τιμή (όχι ακαθόριστες) που βρίσκεται στο αρχείο προέλευσης. Εάν δεν έχετε ορισμένες οικογένειες μια `address.state` τιμή, θα εξαιρούνται στο αποτέλεσμα του ερωτήματος.

**Ερώτημα**

    SELECT * 
    FROM Families.address.state

**Αποτελέσματα**

    [
      "WA", 
      "NY"
    ]


## <a name="where-clause"></a>Πρόταση WHERE
Ο όρος WHERE (**`WHERE <filter_condition>`**) είναι προαιρετικό. Καθορίζει το συνθηκών που τα έγγραφα JSON που παρέχεται από το αρχείο προέλευσης πρέπει να ικανοποιεί για να περιλαμβάνονται ως τμήμα του αποτελέσματος. Οποιοδήποτε έγγραφο JSON πρέπει να αξιολογήσετε τις καθορισμένες συνθήκες να "true" για να ληφθούν υπόψη για το αποτέλεσμα. Τον όρο WHERE χρησιμοποιείται από το επίπεδο ευρετηρίου για να προσδιορίσετε το απόλυτη μικρότερη υποσύνολο των εγγράφων προέλευσης που μπορεί να είναι τμήμα του αποτελέσματος. 

Το παρακάτω ερώτημα αιτήσεις έγγραφα που περιέχουν το όνομα ιδιότητας του οποίου η τιμή είναι `AndersenFamily`. Οποιοδήποτε άλλο έγγραφο που δεν έχει όνομα ιδιότητας, ή όπου η τιμή δεν ταιριάζουν με `AndersenFamily` αποκλείστηκε. 

**Ερώτημα**

    SELECT f.address
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
      "address": {
        "state": "WA", 
        "county": "King", 
        "city": "seattle"
      }
    }]


Το προηγούμενο παράδειγμα εμφάνιζε ερωτήματος απλής ισότητας. DocumentDB SQL υποστηρίζει επίσης μια ποικιλία ανυσματική παραστάσεων. Η πιο συχνά χρησιμοποιούμενες είναι δυαδικό και μοναδιαίος παραστάσεις. Ιδιότητα αναφορές από το αντικείμενο JSON προέλευσης είναι επίσης έγκυρες παραστάσεις. 

Τους ακόλουθους τελεστές δυαδικό υποστηρίζονται αυτήν τη στιγμή και μπορούν να χρησιμοποιηθούν σε ερωτήματα όπως φαίνεται στα παρακάτω παραδείγματα:  
<table>
<tr>
<td>Αριθμητικός μέσος</td> 
<td>+,-,*,/,%</td>
</tr>
<tr>
<td>Πράξης</td>    
<td>|, &, ^, <<, >>, >>> (δεξιό shift μηδέν γεμίσματος) </td>
</tr>
<tr>
<td>Λογική</td>
<td>ΚΑΙ, Ή ΌΧΙ</td>
</tr>
<tr>
<td>Σύγκριση</td> 
<td>=, !=, &lt;, &gt;, &lt;=, &gt;=, <></td>
</tr>
<tr>
<td>Συμβολοσειρά</td> 
<td>|| (συνένωση)</td>
</tr>
</table>  

Ας ρίξουμε μια ματιά ορισμένα ερωτήματα χρησιμοποιώντας τελεστές δυαδικό.

    SELECT * 
    FROM Families.children[0] c
    WHERE c.grade % 2 = 1     -- matching grades == 5, 1
    
    SELECT * 
    FROM Families.children[0] c
    WHERE c.grade ^ 4 = 1    -- matching grades == 5
    
    SELECT *
    FROM Families.children[0] c
    WHERE c.grade >= 5     -- matching grades == 5


Οι τελεστές μοναδιαίο +,-, ~ δεν υποστηρίζονται επίσης και μπορούν να χρησιμοποιηθούν μέσα σε ερωτήματα όπως φαίνεται στο ακόλουθο παράδειγμα:

    SELECT *
    FROM Families.children[0] c
    WHERE NOT(c.grade = 5)  -- matching grades == 1
    
    SELECT *
    FROM Families.children[0] c
    WHERE (-c.grade = -5)  -- matching grades == 5



Εκτός από δυαδικό και μοναδιαίο τελεστές, αναφορές ιδιότητα επίσης τη δυνατότητα. Για παράδειγμα, `SELECT * FROM Families f WHERE f.isRegistered` επιστρέφει το έγγραφο JSON που περιέχει την ιδιότητα `isRegistered` όπου η ιδιότητα τιμή είναι ίση με την JSON `true` τιμή. Όλες οι άλλες τιμές (false, null, δεν έχει οριστεί, `<number>`, `<string>`, `<object>`, `<array>`, κ.λπ.) υποψήφιων πελατών στο έγγραφο προέλευσης που εξαιρέθηκαν από το αποτέλεσμα. 

### <a name="equality-and-comparison-operators"></a>Τελεστές ισότητας και σύγκριση
Ο παρακάτω πίνακας εμφανίζει το αποτέλεσμα της ισότητας συγκρίσεις στο DocumentDB SQL μεταξύ οποιαδήποτε δύο τύπων JSON.
<table style = "width:300px">
   <tbody>
      <tr>
         <td valign="top">
            <strong>OP</strong>
         </td>
         <td valign="top">
            <strong>Δεν έχει οριστεί</strong>
         </td>
         <td valign="top">
            <strong>Τιμή null</strong>
         </td>
         <td valign="top">
            <strong>Δυαδική τιμή</strong>
         </td>
         <td valign="top">
            <strong>Αριθμός</strong>
         </td>
         <td valign="top">
            <strong>Συμβολοσειρά</strong>
         </td>
         <td valign="top">
            <strong>Αντικείμενο</strong>
         </td>
         <td valign="top">
            <strong>Πίνακα</strong>
         </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Δεν έχει οριστεί<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Τιμή null<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
            <strong>Ok</strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Δυαδική τιμή<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
            <strong>Ok</strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Αριθμός<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
            <strong>Ok</strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Συμβολοσειρά<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
            <strong>Ok</strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Αντικείμενο<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
            <strong>Ok</strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
      </tr>
      <tr>
         <td valign="top">
            <strong>Πίνακα<strong>
         </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
Δεν έχει οριστεί </td>
         <td valign="top">
            <strong>Ok</strong>
         </td>
      </tr>
   </tbody>
</table>

Για άλλες τελεστές σύγκρισης όπως >, > =,! =, < και < =, οι ακόλουθοι κανόνες ισχύουν:   

-   Σύγκριση σε τύπους αποτελεσμάτων στο Undefined.
-   Σύγκριση μεταξύ δύο αντικείμενα ή δύο πινάκων έχει ως αποτέλεσμα Undefined.   

Εάν το αποτέλεσμα της παράστασης ανυσματική στο φίλτρο είναι απροσδιόριστη, το αντίστοιχο έγγραφο θα δεν θα συμπεριληφθούν στο αποτέλεσμα, επειδή το Undefined λογικά δεν ισούνται με τα "true".

### <a name="between-keyword"></a>ΜΕΤΑΞΎ των λέξεων-κλειδιών
Μπορείτε επίσης να χρησιμοποιήσετε τη λέξη-κλειδί BETWEEN για να εκφράσετε ερωτήματα σε σχέση με περιοχές τιμών όπως στο ANSI SQL. ΜΕΤΑΞΎ μπορεί να χρησιμοποιηθεί σε σχέση με συμβολοσειρές ή αριθμών.

Για παράδειγμα, αυτό το ερώτημα επιστρέφει όλα τα έγγραφα οικογένειας στο οποίο είναι το πρώτο θυγατρικό βαθμού μεταξύ 1-5 (και τα δύο συμπεριλαμβανομένων των ακραίων τιμών). 

    SELECT *
    FROM Families.children[0] c
    WHERE c.grade BETWEEN 1 AND 5

Σε αντίθεση με στο ANSI SQL, μπορείτε επίσης να χρησιμοποιήσετε τον όρο BETWEEN στον όρο FROM, όπως στο παράδειγμα που ακολουθεί.

    SELECT (c.grade BETWEEN 0 AND 10)
    FROM Families.children[0] c

Για ταχύτερους χρόνους εκτέλεσης ερωτήματος, να θυμάστε ότι για να δημιουργήσετε μια πολιτική δημιουργίας ευρετηρίου που χρησιμοποιεί έναν τύπο περιοχής ευρετήριο σε σχέση με οποιαδήποτε αριθμητική ιδιότητες/διαδρομές που έχουν φιλτραριστεί BETWEEN τον όρο FROM. 

Η κύρια διαφορά μεταξύ της χρήσης BETWEEN στο DocumentDB και του ANSI SQL είναι ώστε να μπορείτε να εκφράσετε ερωτήματα περιοχή ιδιότητες μεικτών τύπων – για παράδειγμα, μπορεί να έχετε "βαθμού" είναι ένας αριθμός (5) σε ορισμένα έγγραφα και συμβολοσειρών σε άλλους ("grade4"). Σε αυτές τις περιπτώσεις, όπως στο JavaScript, μια σύγκριση μεταξύ δύο διαφορετικούς τύπους αποτελεσμάτων "απροσδιόριστο" και το έγγραφο θα παραλειφθούν.

### <a name="logical-and-or-and-not-operators"></a>Λογική (AND, OR και NOT) τελεστές
Λογικοί τελεστές λειτουργούν δυαδικές τιμές. Οι λογικές πίνακες αλήθειας για αυτούς τους τελεστές εμφανίζονται στους παρακάτω πίνακες.

OR|TRUE|FALSE|Δεν έχει οριστεί
---|---|---|---
TRUE|TRUE|TRUE|TRUE
FALSE|TRUE|FALSE|Δεν έχει οριστεί
Δεν έχει οριστεί|TRUE|Δεν έχει οριστεί|Δεν έχει οριστεί

ΚΑΙ|TRUE|FALSE|Δεν έχει οριστεί
---|---|---|---
TRUE|TRUE|FALSE|Δεν έχει οριστεί
FALSE|FALSE|FALSE|FALSE
Δεν έχει οριστεί|Δεν έχει οριστεί|FALSE|Δεν έχει οριστεί

ΔΕΝ|  |
---|---
TRUE|FALSE
FALSE|TRUE
Δεν έχει οριστεί|Δεν έχει οριστεί

### <a name="in-keyword"></a>Λέξη-ΚΛΕΙΔΊ
Η λέξη-κλειδί στην μπορεί να χρησιμοποιηθεί για να ελέγξετε εάν μια καθορισμένη τιμή συμφωνεί με οποιαδήποτε τιμή σε μια λίστα. Για παράδειγμα, αυτό το ερώτημα επιστρέφει όλα τα έγγραφα οικογένειας όπου το αναγνωριστικό είναι μία από "WakefieldFamily" ή "AndersenFamily". 
 
    SELECT *
    FROM Families 
    WHERE Families.id IN ('AndersenFamily', 'WakefieldFamily')

Αυτό το παράδειγμα επιστρέφει όλα τα έγγραφα όπου η κατάσταση είναι οποιαδήποτε από τις καθορισμένες τιμές.

    SELECT *
    FROM Families 
    WHERE Families.address.state IN ("NY", "WA", "CA", "PA", "OH", "OR", "MI", "WI", "MN", "FL")

### <a name="ternary--and-coalesce--operators"></a>Τριμερή (?) και τους τελεστές συνένωσης (?)
Οι τελεστές τριμερή και συνένωσης μπορεί να χρησιμοποιηθεί για τη δημιουργία εκφράσεων υπό συνθήκη, παρόμοια με δημοφιλείς γλώσσες προγραμματισμού όπως C# και JavaScript. 

Τον τελεστή τριμερή (?) μπορεί να είναι πολύ χρήσιμο όταν η κατασκευή νέες ιδιότητες JSON δυναμική. Για παράδειγμα, τώρα μπορείτε να συντάξετε ερωτήματα για να ταξινομήσετε τα επίπεδα κλάσης σε μια μορφή αναγνώσιμη ανθρώπων όπως αρχάριος/ενδιάμεσου/για προχωρημένους όπως φαίνεται παρακάτω.
 
     SELECT (c.grade < 5)? "elementary": "other" AS gradeLevel 
     FROM Families.children[0] c

Μπορείτε επίσης να κάνετε ένθεση των κλήσεων για να τον τελεστή like στο παρακάτω ερώτημα.
 
    SELECT (c.grade < 5)? "elementary": ((c.grade < 9)? "junior": "high")  AS gradeLevel 
    FROM Families.children[0] c

Ως με άλλες τελεστές ερωτήματος, εάν λείπουν οι ιδιότητες αναφοράς στην παράσταση υπό όρους σε οποιοδήποτε έγγραφο ή εάν οι τύποι που συγκρίνονται είναι διαφορετικό, στη συνέχεια, αυτά τα έγγραφα θα εξαιρεθούν στα αποτελέσματα του ερωτήματος.

Ο τελεστής συνένωσης (?) μπορεί να χρησιμοποιηθεί για να ελέγξετε αποτελεσματικά για την παρουσία της ιδιότητας (ρομποτική έχει οριστεί) σε ένα έγγραφο. Αυτό είναι χρήσιμο κατά την υποβολή ερωτήματος σε σχέση με ημι-δομημένα ή δεδομένα μεικτών τύπων. Για παράδειγμα, αυτό το ερώτημα επιστρέφει το "Επώνυμο" Εάν υπάρχει, ή το "Επώνυμο" Εάν δεν υπάρχει.

    SELECT f.lastName ?? f.surname AS familyName
    FROM Families f

### <a name="quoted-property-accessor"></a>Το στοιχείο πρόσβασης ιδιότητας εισαγωγικά
Μπορείτε επίσης να αποκτήσετε πρόσβαση ιδιότητες χρησιμοποιώντας τον τελεστή εισαγωγικά ιδιότητα `[]`. Για παράδειγμα, `SELECT c.grade` και `SELECT c["grade"]` θεωρούνται ισοδύναμα. Αυτή η σύνταξη είναι χρήσιμη όταν πρέπει να διαφυγής μια ιδιότητα που περιέχει διαστήματα, ειδικούς χαρακτήρες, ή συμβαίνει για να μοιραστείτε το ίδιο όνομα με μια λέξη-κλειδί SQL ή δεσμευμένη λέξη.

    SELECT f["lastName"]
    FROM Families f
    WHERE f["id"] = "AndersenFamily"


## <a name="select-clause"></a>Όρος SELECT
Ο όρος SELECT (**`SELECT <select_list>`**) είναι υποχρεωτικό και καθορίζει ποιες τιμές θα να ανακτηθούν από το ερώτημα, όπως ακριβώς στην ANSI SQL. Το υποσύνολο που έχει φιλτραριστεί επάνω από τα έγγραφα προέλευσης μεταβιβάζονται σε η φάση προβολής, όπου οι καθορισμένες τιμές JSON ανακτώνται και ενός νέου αντικειμένου JSON έχει συνταχθεί, για κάθε εισαγωγής που εισήχθησαν σε αυτό. 

Το παρακάτω παράδειγμα εμφανίζει ένα τυπικό ερώτημα ΕΠΙΛΟΓΉΣ. 

**Ερώτημα**

    SELECT f.address
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
      "address": {
        "state": "WA", 
        "county": "King", 
        "city": "seattle"
      }
    }]


### <a name="nested-properties"></a>Ένθετες ιδιότητες
Στο παρακάτω παράδειγμα, θα σας προβολή δύο ένθετη ιδιότητες `f.address.state` και `f.address.city`.

**Ερώτημα**

    SELECT f.address.state, f.address.city
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
      "state": "WA", 
      "city": "seattle"
    }]


Προβολή υποστηρίζει επίσης JSON παραστάσεων, όπως φαίνεται στο παρακάτω παράδειγμα.

**Ερώτημα**

    SELECT { "state": f.address.state, "city": f.address.city, "name": f.id }
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
      "$1": {
        "state": "WA", 
        "city": "seattle", 
        "name": "AndersenFamily"
      }
    }]


Ας ρίξουμε μια ματιά του ρόλου των `$1` εδώ. Το `SELECT` τον όρο FROM πρέπει να δημιουργήσετε ένα αντικείμενο JSON και εφόσον δεν υπάρχει κλειδί παρέχεται, χρησιμοποιούμε έμμεσα όρισμα μεταβλητής ονόματα ξεκινούν με `$1`. Για παράδειγμα, αυτό το ερώτημα επιστρέφει δύο μεταβλητές έμμεσα όρισμα, με την ετικέτα `$1` και `$2`.

**Ερώτημα**

    SELECT { "state": f.address.state, "city": f.address.city }, 
           { "name": f.id }
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
      "$1": {
        "state": "WA", 
        "city": "seattle"
      }, 
      "$2": {
        "name": "AndersenFamily"
      }
    }]


### <a name="aliasing"></a>Δυνατότητα ψευδωνύμων
Τώρα ας επέκταση παραπάνω παράδειγμα με ρητή εναλλακτικό τιμών. ΠΟΥ είναι η λέξη-κλειδί που χρησιμοποιείται για το εναλλακτικό. Σημειώστε ότι είναι προαιρετικό, όπως εμφανίζεται κατά την προβολή τη δεύτερη τιμή ως `NameInfo`. 

Σε περίπτωση που ένα ερώτημα έχει δύο ιδιότητες με το ίδιο όνομα, εναλλακτικό πρέπει να χρησιμοποιείται για να μετονομάσετε ένα ή και τα δύο από τις ιδιότητες, ώστε να τους αποσαφήνισή τους στο αποτέλεσμα πρόβλεψη.

**Ερώτημα**

    SELECT 
           { "state": f.address.state, "city": f.address.city } AS AddressInfo, 
           { "name": f.id } NameInfo
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
      "AddressInfo": {
        "state": "WA", 
        "city": "seattle"
      }, 
      "NameInfo": {
        "name": "AndersenFamily"
      }
    }]


### <a name="scalar-expressions"></a>Ανυσματική παραστάσεις
Εκτός από την ιδιότητα αναφορές, ο όρος SELECT υποστηρίζει επίσης ανυσματική παραστάσεις όπως σταθερές, αριθμητικοί παραστάσεις, λογικές παραστάσεις, κ.λπ. Για παράδειγμα, ακολουθεί ενός απλού ερωτήματος "Γεια".

**Ερώτημα**

    SELECT "Hello World"

**Αποτελέσματα**

    [{
      "$1": "Hello World"
    }]


Ακολουθεί μια πιο σύνθετη παράδειγμα που χρησιμοποιεί μια ανυσματική παράσταση.

**Ερώτημα**

    SELECT ((2 + 11 % 7)-2)/3   

**Αποτελέσματα**

    [{
      "$1": 1.33333
    }]


Στο παρακάτω παράδειγμα, το αποτέλεσμα της παράστασης ανυσματική είναι μια τιμή Boolean.

**Ερώτημα**

    SELECT f.address.city = f.address.state AS AreFromSameCityState
    FROM Families f 

**Αποτελέσματα**

    [
      {
        "AreFromSameCityState": false
      }, 
      {
        "AreFromSameCityState": true
      }
    ]


### <a name="object-and-array-creation"></a>Δημιουργία αντικειμένου και πίνακα
Μια άλλη βασικών δυνατοτήτων του DocumentDB SQL είναι η δημιουργία πίνακα/αντικειμένου. Στο προηγούμενο παράδειγμα, σημειώστε ότι που δημιουργήσαμε ενός νέου αντικειμένου JSON. Ομοίως, ένα επίσης να δημιουργήσετε πίνακες όπως φαίνεται στα παρακάτω παραδείγματα.

**Ερώτημα**

    SELECT [f.address.city, f.address.state] AS CityState 
    FROM Families f 

**Αποτελέσματα**  

    [
      {
        "CityState": [
          "seattle", 
          "WA"
        ]
      }, 
      {
        "CityState": [
          "NY", 
          "NY"
        ]
      }
    ]

### <a name="value-keyword"></a>ΤΙΜΉ λέξεων-κλειδιών
Η λέξη-κλειδί **ΤΙΜΉ** παρέχει έναν τρόπο για να επιστρέψει τιμή JSON. Για παράδειγμα, το ερώτημα που φαίνεται παρακάτω επιστρέφει την άνυσμα `"Hello World"` αντί για `{$1: "Hello World"}`.

**Ερώτημα**

    SELECT VALUE "Hello World"

**Αποτελέσματα**

    [
      "Hello World"
    ]


Το παρακάτω ερώτημα επιστρέφει την τιμή JSON χωρίς το `"address"` ετικέτας στα αποτελέσματα.

**Ερώτημα**

    SELECT VALUE f.address
    FROM Families f 

**Αποτελέσματα**  

    [
      {
        "state": "WA", 
        "county": "King", 
        "city": "seattle"
      }, 
      {
        "state": "NY", 
        "county": "Manhattan", 
        "city": "NY"
      }
    ]

Το παρακάτω παράδειγμα επεκτείνει έτσι ώστε να δείχνουν τον τρόπο για την επιστροφή τιμών στοιχειώδεις JSON (το επίπεδο φύλλων του δέντρου JSON). 

**Ερώτημα**

    SELECT VALUE f.address.state
    FROM Families f 

**Αποτελέσματα**

    [
      "WA",
      "NY"
    ]


###<a name="-operator"></a>* Τελεστής
Ο τελεστής ειδική (*) υποστηρίζεται στο project το έγγραφο ως-είναι. Όταν χρησιμοποιείται, πρέπει να είναι το μόνο πεδίο πρόβλεψη. Κατά ένα ερώτημα όπως `SELECT * FROM Families f` είναι έγκυρο, `SELECT VALUE * FROM Families f ` και `SELECT *, f.id FROM Families f ` δεν είναι έγκυροι.

**Ερώτημα**

    SELECT * 
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Αποτελέσματα**

    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]

###<a name="top-operator"></a>Τελεστής ΕΠΆΝΩ
Η λέξη-κλειδί ΕΠΆΝΩ μπορεί να χρησιμοποιηθεί για να περιορίσετε τον αριθμό των τιμών από ένα ερώτημα. Όταν ΑΡΧΉ χρησιμοποιείται σε συνδυασμό με ORDER BY, το σύνολο των αποτελεσμάτων είναι περιορισμένη για τον πρώτο αριθμό N ταξινομημένη τιμές. Διαφορετικά, επιστρέφει τον πρώτο αριθμό N αποτελεσμάτων με τη σειρά που δεν έχει οριστεί. Ως βέλτιστη πρακτική, σε μια πρόταση SELECT, χρησιμοποιείτε πάντα όρο ORDER BY με όρο ΕΠΆΝΩ του. Αυτό είναι ο μόνος τρόπος για να υποδείξετε προβλέψιμα ποιες γραμμές επηρεάζονται από την ΑΡΧΉ. 


**Ερώτημα**

    SELECT TOP 1 * 
    FROM Families f 

**Αποτελέσματα**

    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]

ΑΡΧΉ μπορεί να χρησιμοποιηθεί με μια τιμή σταθεράς (όπως φαίνεται παραπάνω) ή με μια τιμή μεταβλητής χρήση ερωτημάτων με παραμέτρους. Για περισσότερες λεπτομέρειες, ανατρέξτε στο θέμα παρακάτω ερωτήματα με παραμέτρους.

## <a name="order-by-clause"></a>Όρος ORDER BY
Όπως και στο ANSI SQL, μπορείτε να συμπεριλάβετε ένα προαιρετικό όρος Order By κατά την υποβολή ερωτήματος. Ο όρος να συμπεριλάβετε ένα προαιρετικό όρισμα Αύξουσας/Φθίνουσας για να καθορίσετε τη σειρά με την οποία πρέπει να είναι δυνατή η ανάκτηση αποτελεσμάτων. Για μια πιο λεπτομερή ματιά Order By, ανατρέξτε στην [DocumentDB σειρά με οδηγίες](documentdb-orderby.md).

Για παράδειγμα, ακολουθεί ένα ερώτημα το οποίο ανακτά οικογένειες με το όνομα της πόλης κατοικούν τη σειρά.

**Ερώτημα**

    SELECT f.id, f.address.city
    FROM Families f 
    ORDER BY f.address.city
    
**Αποτελέσματα**
    
    [
      {
        "id": "WakefieldFamily",
        "city": "NY"
      },
      {
        "id": "AndersenFamily",
        "city": "Seattle"   
      }
    ]

Και εδώ ένα ερώτημα το οποίο ανακτά οικογένειες με τη σειρά ημερομηνία δημιουργίας, η οποία είναι αποθηκευμένο ως ένας αριθμός που αντιπροσωπεύει τη χρονική σήμανση χρόνου, δηλαδή, χρόνος που πέρασε από την 1η Ιανουαρίου 1970 σε δευτερόλεπτα.

**Ερώτημα**

    SELECT f.id, f.creationDate
    FROM Families f 
    ORDER BY f.creationDate DESC
    
**Αποτελέσματα**
    
    [
      {
        "id": "WakefieldFamily",
        "creationDate": 1431620462
      },
      {
        "id": "AndersenFamily",
        "creationDate": 1431620472  
      }
    ]
    
## <a name="advanced-database-concepts-and-sql-queries"></a>Βάση δεδομένων για προχωρημένους έννοιες και ερωτήματα SQL
### <a name="iteration"></a>Διαδοχικές προσεγγίσεις
Μια νέα δομή προστέθηκε μέσω τη λέξη-κλειδί **στην** στο DocumentDB SQL για την παροχή υποστήριξης διαδοχικές προσεγγίσεις JSON πίνακες. Το αρχείο προέλευσης από παρέχει υποστήριξη για διαδοχικών προσεγγίσεων. Ας ξεκινήσουμε με το ακόλουθο παράδειγμα:

**Ερώτημα**

    SELECT * 
    FROM Families.children

**Αποτελέσματα**  

    [
      [
        {
          "firstName": "Henriette Thaulow", 
          "gender": "female", 
          "grade": 5, 
          "pets": [{ "givenName": "Fluffy"}]
        }
      ], 
      [
        {
            "familyName": "Merriam", 
            "givenName": "Jesse", 
            "gender": "female", 
            "grade": 1
        }, 
        {
            "familyName": "Miller", 
            "givenName": "Lisa", 
            "gender": "female", 
            "grade": 8
        }
      ]
    ]

Τώρα ας δούμε ένα άλλο ερώτημα που εκτελεί διαδοχικών προσεγγίσεων μέσω θυγατρικά στοιχεία της συλλογής. Σημείωση η διαφορά στον επιστρεφόμενο πίνακα. Αυτό το παράδειγμα διαιρέσεις `children` και ισοπεδώνει τα αποτελέσματα σε μόνο έναν πίνακα.  

**Ερώτημα**

    SELECT * 
    FROM c IN Families.children

**Αποτελέσματα**  

    [
      {
          "firstName": "Henriette Thaulow",
          "gender": "female",
          "grade": 5,
          "pets": [{ "givenName": "Fluffy" }]
      },
      {
          "familyName": "Merriam",
          "givenName": "Jesse",
          "gender": "female",
          "grade": 1
      },
      {
          "familyName": "Miller",
          "givenName": "Lisa",
          "gender": "female",
          "grade": 8
      }
    ]

Αυτό μπορεί να περαιτέρω χρησιμοποιηθεί για να φιλτράρετε σε κάθε μία εγγραφή του πίνακα, όπως φαίνεται στο παρακάτω παράδειγμα.

**Ερώτημα**

    SELECT c.givenName
    FROM c IN Families.children
    WHERE c.grade = 8

**Αποτελέσματα**  

    [{
      "givenName": "Lisa"
    }]

### <a name="joins"></a>Σύνδεσμοι
Σε μια σχεσιακή βάση δεδομένων, είναι σημαντικό, χρειάζεστε για να συμμετάσχετε σε πίνακες. Είναι η λογική συμπλήρωμα στη σχεδίαση κανονικοποιημένη σχήματα. Αντίθετα με αυτό, DocumentDB ασχολείται με το μοντέλο δεδομένων μη κανονικά χωρίς σχήματος εγγράφων. Αυτό είναι το λογικό ισοδύναμο του a "ιδιο-συνδέσμου".

Η σύνταξη που υποστηρίζει τη γλώσσα είναι < from_source1 > ΣΥΜΜΕΤΟΧΉ < from_source2 > ΣΥΜΜΕΤΟΧΉ... Συμμετοχή σε < from_sourceN >. Γενικά, αυτό επιστρέφει ένα σύνολο **N**- πλειάδων (πλειάδας με **N** τιμές). Κάθε πλειάδας έχει παραχθεί με τις διαδοχικές όλα τα ψευδώνυμα συλλογής πάνω από τους αντίστοιχους σύνολα τιμών. Με άλλα λόγια, αυτή είναι μια πλήρη σταυροειδές γινόμενο των συνόλων συμμετοχή σε συνδέσμου.

Τα παρακάτω παραδείγματα δείχνουν πώς λειτουργεί ο όρος ΣΥΜΜΕΤΟΧΉ. Στο παρακάτω παράδειγμα, το αποτέλεσμα είναι κενό από το γινόμενο μεταξύ κάθε εγγράφου από το αρχείο προέλευσης και ένα κενό σύνολο είναι κενό.

**Ερώτημα**

    SELECT f.id
    FROM Families f
    JOIN f.NonExistent

**Αποτελέσματα**  

    [{
    }]


Στο παρακάτω παράδειγμα, ο σύνδεσμος είναι μεταξύ ρίζας του εγγράφου και το `children` δευτερεύουσα ρίζα. Είναι ένα σταυροειδές γινόμενο μεταξύ δύο JSON αντικειμένων. Το γεγονός ότι τα παιδιά είναι ένας πίνακας δεν είναι αποτελεσματικές ο σύνδεσμος αφού μας σας ενδιαφέρει μια μεμονωμένη ρίζας που είναι ο πίνακας θυγατρικά στοιχεία. Επομένως το αποτέλεσμα περιέχει μόνο δύο αποτελέσματα, επειδή το γινόμενο μεταξύ κάθε έγγραφο με έναν πίνακα αποδόσεις ακριβώς μόνο ένα έγγραφο.

**Ερώτημα**

    SELECT f.id
    FROM Families f
    JOIN f.children
 
**Αποτελέσματα**

    [
      {
        "id": "AndersenFamily"
      }, 
      {
        "id": "WakefieldFamily"
      }
    ]


Το παρακάτω παράδειγμα εμφανίζει μια πιο συμβατικά συμμετοχή:

**Ερώτημα**

    SELECT f.id
    FROM Families f
    JOIN c IN f.children 

**Αποτελέσματα**

    [
      {
        "id": "AndersenFamily"
      }, 
      {
        "id": "WakefieldFamily"
      }, 
      {
        "id": "WakefieldFamily"
      }
    ]



Είναι το πρώτο πράγμα που πρέπει να λάβετε υπόψη ότι η `from_source` από τη **ΣΥΜΜΕΤΟΧΉ** όρος είναι έναν επαναλήπτη. Επομένως, της ροής σε αυτήν την περίπτωση είναι ως εξής:  

-   Ανάπτυξη κάθε θυγατρικό στοιχείο **c** στον πίνακα.
-   Εφαρμόστε ένα σταυροειδές γινόμενο με το ριζικό κατάλογο του εγγράφου **f** με κάθε θυγατρικό στοιχείο **c** που ήταν τίθενται στο πρώτο βήμα.
-   Τέλος, το project ρίζας αντικείμενο **f** ιδιότητα name από μόνο του. 

Το πρώτο έγγραφο (`AndersenFamily`) περιέχει μόνο ένα θυγατρικό στοιχείο, έτσι ώστε το σύνολο αποτελεσμάτων περιέχει μόνο σε ένα αντικείμενο που αντιστοιχεί σε αυτό το έγγραφο. Το δεύτερο έγγραφο (`WakefieldFamily`) περιέχει δύο θυγατρικά στοιχεία. Επομένως, το σταυροειδές γινόμενο που παράγει ένα ξεχωριστό αντικείμενο για κάθε παιδιού, συνεπώς αποτέλεσμα δύο αντικείμενα, μία για κάθε παιδί που αντιστοιχεί σε αυτό το έγγραφο. Σημειώστε ότι τα πεδία ρίζας και τα δύο αυτά τα έγγραφα θα είναι ίδια, ακριβώς όπως θα περιμένατε σε ένα σταυροειδές γινόμενο.

Το πραγματικό βοηθητικό πρόγραμμα του ΣΥΝΔΈΣΜΟΥ είναι να πλειάδων φόρμα από το σταυροειδές γινόμενο σε ένα σχήμα που διαφορετικά είναι δύσκολο να έργου. Επιπλέον, όπως θα εμφανίζεται στο παρακάτω παράδειγμα, θα μπορούσε να φιλτράρετε τον συνδυασμό των μιας πλειάδας που σας επιτρέπει να των ο χρήστης επιλέξατε συνθήκης πληρούνται από το πλειάδων συνολικά.

**Ερώτημα**

    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName 
    FROM Families f 
    JOIN c IN f.children 
    JOIN p IN c.pets
 
**Αποτελέσματα**

    [
      {
        "familyName": "AndersenFamily", 
        "childFirstName": "Henriette Thaulow", 
        "petName": "Fluffy"
      }, 
      {
        "familyName": "WakefieldFamily", 
        "childGivenName": "Jesse", 
        "petName": "Goofy"
      }, 
      {
       "familyName": "WakefieldFamily", 
       "childGivenName": "Jesse", 
       "petName": "Shadow"
      }
    ]



Αυτό το παράδειγμα είναι μια φυσική επέκταση από το προηγούμενο παράδειγμα, και εκτελεί διπλά συνδέσμου. Επομένως, το σταυροειδές γινόμενο που μπορούν να προβληθούν ως τον παρακάτω ψευδο κώδικα.

    for-each(Family f in Families)
    {   
        for-each(Child c in f.children)
        {
            for-each(Pet p in c.pets)
            {
                return (Tuple(f.id AS familyName, 
                  c.givenName AS childGivenName, 
                  c.firstName AS childFirstName,
                  p.givenName AS petName));
            }
        }
    }

`AndersenFamily`έχει ένα θυγατρικό που έχει ένα pet. Επομένως, το σταυροειδές γινόμενο αποδόσεις μία γραμμή (1*1*1) από αυτήν την οικογένεια. WakefieldFamily ωστόσο έχει δύο θυγατρικά στοιχεία, αλλά μόνο ένα θυγατρικό "Jesse" έχει οικιακών. Jesse έχει 2 οικιακών μέσω. Ως εκ τούτου το σταυροειδές γινόμενο αποδόσεις 1 γραμμές*1*2 = 2 από αυτήν την οικογένεια.

Στο επόμενο παράδειγμα, υπάρχει ένα πρόσθετο φίλτρο σε `pet`. Εξαιρούνται όλα τα πλειάδων όπου το όνομα pet δεν είναι "Σκιά". Παρατηρήστε ότι είναι δυνατή η δημιουργία πλειάδων από πίνακες, φίλτρου σε οποιοδήποτε από τα στοιχεία της πλειάδας, και οποιονδήποτε συνδυασμό από τα στοιχεία του project. 

**Ερώτημα**

    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName 
    FROM Families f 
    JOIN c IN f.children 
    JOIN p IN c.pets
    WHERE p.givenName = "Shadow"

**Αποτελέσματα**

    [
      {
       "familyName": "WakefieldFamily", 
       "childGivenName": "Jesse", 
       "petName": "Shadow"
      }
    ]


## <a name="javascript-integration"></a>Ενοποίηση JavaScript
DocumentDB παρέχει ένα μοντέλο προγραμματισμού για την εκτέλεση JavaScript βάσει λογική εφαρμογής απευθείας σε των συλλογών όσον αφορά τις αποθηκευμένες διαδικασίες και εναύσματα. Αυτό σας επιτρέπει για τα δύο:

-   Δυνατότητα να κάνετε συναλλαγών λειτουργίες CRUD για υψηλές επιδόσεις και ερωτήματα προς έγγραφα σε μια συλλογή σύμφωνα με την ενοποίηση του χρόνου εκτέλεσης JavaScript απευθείας μέσα από το μηχανισμό βάσεων δεδομένων. 
-   Μια φυσική μοντελοποίηση στοιχείο ελέγχου ροής, μεταβλητής εμβέλεια, και ανάθεσης και ενοποίησης του εξαίρεση χειρισμός στοιχειώδεις τύπους με συναλλαγές της βάσης δεδομένων. Για περισσότερες λεπτομέρειες σχετικά με την υποστήριξη DocumentDB για την ενοποίηση JavaScript, ανατρέξτε στην τεκμηρίωση προγραμματισμού του JavaScript server πλευρά.

###<a name="user-defined-functions-udfs"></a>Οι συναρτήσεις που ορίζονται από το χρήστη
Μαζί με τους τύπους που ήδη καθοριστεί σε αυτό το άρθρο, DocumentDB SQL παρέχει υποστήριξη για το συναρτήσεις που ορίζονται από το χρήστη (UDF). Συγκεκριμένα, ανυσματική UDF υποστηρίζονται όπου οι προγραμματιστές να μεταβιβάζουν στα ορίσματα μηδέν ή πολλά και να επιστρέψετε ξανά ένα μεμονωμένο όρισμα αποτέλεσμα. Κάθε ένα από τα εξής ορίσματα ελέγχονται για τη νομική JSON τιμές.  

Η σύνταξη DocumentDB SQL έχει επεκταθεί για την υποστήριξη λογική προσαρμοσμένων εφαρμογών χρησιμοποιώντας αυτές τις συναρτήσεις που ορίζονται από το χρήστη. UDF μπορεί να έχει εγγραφεί σε DocumentDB και, στη συνέχεια, να αναφέρονται ως μέρος ενός ερωτήματος SQL. Στην πραγματικότητα, το UDF exquisitely έχουν σχεδιαστεί για να χρησιμοποιούνται από ερωτήματα. Ως συμπλήρωμα για αυτήν την επιλογή, UDF δεν έχουν πρόσβαση στο αντικείμενο περιβάλλοντος που έχουν τους άλλους τύπους JavaScript (αποθηκευμένες διαδικασίες και εναύσματα). Επειδή το εκτέλεση ερωτημάτων μόνο για ανάγνωση, που μπορούν να εκτελούν σε κύρια ή σε δευτερεύον αντίγραφα. Επομένως, UDF έχουν σχεδιαστεί για να εκτελέσετε στη δευτερεύουσα αντίγραφα σε αντίθεση με άλλους τύπους JavaScript.

Ακολουθεί ένα παράδειγμα του πώς μια UDF μπορεί να είναι καταχωρημένος στο τη βάση δεδομένων DocumentDB, ειδικά κάτω από μια συλλογή εγγράφων.

   
       UserDefinedFunction regexMatchUdf = new UserDefinedFunction
       {
           Id = "REGEX_MATCH",
           Body = @"function (input, pattern) { 
                       return input.match(pattern) !== null;
                   };",
       };
       
       UserDefinedFunction createdUdf = client.CreateUserDefinedFunctionAsync(
           UriFactory.CreateDocumentCollectionUri("testdb", "families"), 
           regexMatchUdf).Result;  
                                                                             
Το προηγούμενο παράδειγμα δημιουργεί μια UDF όνομα των οποίων έχει `REGEX_MATCH`. Να δέχεται δύο τιμές συμβολοσειράς JSON `input` και `pattern` και ελέγχει εάν η πρώτη συμφωνίες το μοτίβο που καθορίζεται στη δεύτερη χρήση συνάρτησης string.match() του JavaScript.


Τώρα μπορούμε να χρησιμοποιήσουμε αυτό UDF σε ένα ερώτημα σε μια προβολή. Πρέπει να είναι έγκυρη UDF με το πρόθεμα διάκριση πεζών-κεφαλαίων "udf." Όταν η οποία ονομάζεται από μέσα σε ερωτήματα. 

>[AZURE.NOTE] Πριν από 17/3/2015, DocumentDB υποστηρίζονται UDF κλήσεις χωρίς το "udf." πρόθεμα όπως ΕΠΙΛΈΞΤΕ REGEX_MATCH(). Αυτό το μοτίβο κλήσης έχει καταργηθεί.  

**Ερώτημα**

    SELECT udf.REGEX_MATCH(Families.address.city, ".*eattle")
    FROM Families

**Αποτελέσματα**

    [
      {
        "$1": true
      }, 
      {
        "$1": false
      }
    ]

Το UDF επίσης μπορούν να χρησιμοποιηθούν μέσα σε ένα φίλτρο, όπως φαίνεται στο παρακάτω παράδειγμα, προσδιορισμένο επίσης με το "udf." πρόθεμα:

**Ερώτημα**

    SELECT Families.id, Families.address.city
    FROM Families
    WHERE udf.REGEX_MATCH(Families.address.city, ".*eattle")

**Αποτελέσματα**

    [{
        "id": "AndersenFamily",
        "city": "Seattle"
    }]


Στην πραγματικότητα, UDF είναι έγκυρες παραστάσεις ανυσματική και μπορούν να χρησιμοποιηθούν σε προβολές και φίλτρα. 

Για να αναπτύξετε στη δύναμη του UDF, ας δούμε ένα άλλο παράδειγμα με λογική υπό όρους:

       UserDefinedFunction seaLevelUdf = new UserDefinedFunction()
       {
           Id = "SEALEVEL",
           Body = @"function(city) {
                switch (city) {
                    case 'seattle':
                        return 520;
                    case 'NY':
                        return 410;
                    case 'Chicago':
                        return 673;
                    default:
                        return -1;
                    }"
            };

            UserDefinedFunction createdUdf = await client.CreateUserDefinedFunctionAsync(
                UriFactory.CreateDocumentCollectionUri("testdb", "families"), 
                seaLevelUdf);
    
    
Ακολουθεί ένα παράδειγμα που εκτελεί το UDF.

**Ερώτημα**

    SELECT f.address.city, udf.SEALEVEL(f.address.city) AS seaLevel
    FROM Families f 

**Αποτελέσματα**

     [
      {
        "city": "seattle", 
        "seaLevel": 520
      }, 
      {
        "city": "NY", 
        "seaLevel": 410
      }
    ]


Καθώς επιδεικνύουν προηγούμενα παραδείγματα, UDF ενοποίηση στη δύναμη του γλώσσα JavaScript με το SQL DocumentDB για την παροχή ενός εμπλουτισμένου προγραμματιζόμενο περιβάλλον για να κάνετε σύνθετες λογικής σχετικά με τη διαδικασία, υπό όρους με τη Βοήθεια του ενσωματωμένες δυνατότητες χρόνου εκτέλεσης JavaScript.

DocumentDB SQL παρέχει τα ορίσματα το UDF για κάθε έγγραφο στο αρχείο προέλευσης στο τρέχον στάδιο (όρο WHERE ή όρο SELECT) της επεξεργασίας το UDF. Το αποτέλεσμα είναι ενσωματωμένο στο τη συνολική διαδικασία εκτέλεσης ομαλά. Εάν οι ιδιότητες που αναφέρονται από το UDF παράμετροι δεν είναι διαθέσιμα στην τιμή JSON, η παράμετρος θεωρείται ως απροσδιόριστη και επομένως παραλείπεται εντελώς το Ενεργοποίηση UDF. Ομοίως εάν το αποτέλεσμα της το UDF έχει οριστεί, δεν περιλαμβάνεται στο αποτέλεσμα. 

Εν κατακλείδι, UDF είναι εξαιρετικό εργαλεία για να κάνετε σύνθετες επιχειρηματικής λογικής ως μέρος του ερωτήματος.

### <a name="operator-evaluation"></a>Τελεστής αξιολόγησης
DocumentDB, από το να μια βάση δεδομένων JSON, σχεδιάζει αντίστοιχο με τελεστές JavaScript και τη σημασιολογία αξιολόγησης. Ενώ DocumentDB προσπαθεί να διατηρηθούν σημασιολογία JavaScript όσον αφορά την υποστήριξη JSON, τον υπολογισμό λειτουργία προκύπτει σε κάποιες περιπτώσεις.

Στο DocumentDB SQL, σε αντίθεση με σε παραδοσιακά SQL, τους τύπους των τιμών είναι συχνά δεν γνωστά μέχρι οι τιμές στην πραγματικότητα ανακτώνται από βάση δεδομένων. Προκειμένου να αποτελεσματικά εκτέλεση ερωτημάτων, περισσότερες από τους τελεστές έχουν απαιτήσεις αυστηρών τύπου. 

DocumentDB SQL δεν μπορεί να εκτελέσει έμμεσα μετατροπών, σε αντίθεση με JavaScript. Για παράδειγμα, ένα ερώτημα, όπως `SELECT * FROM Person p WHERE p.Age = 21` ταιριάζει με έγγραφα που περιέχουν μια ιδιότητα ηλικία του οποίου η τιμή είναι η 21. Οποιοδήποτε άλλο έγγραφο του οποίου η ιδιότητα Age αντιστοιχεί πιθανώς άπειρο συμβολοσειράς "21" ή άλλες παραλλαγές όπως "021", "21.0", "0021", "00021", δεν θα είναι αντιστοιχία κ.λπ. Αυτό είναι σε αντίθεση με το JavaScript όπου οι τιμές συμβολοσειράς είναι μη ρητά διανεμηθεί σε αριθμούς (βάση τελεστή, ex: ==). Αυτή η επιλογή είναι κρίσιμης σημασίας για αντιστοίχιση σε DocumentDB SQL αποτελεσματική το ευρετήριο. 

## <a name="parameterized-sql-queries"></a>Ερωτήματα SQL με παραμέτρους
DocumentDB υποστηρίζει ερωτημάτων με παραμέτρους εκφρασμένη με την οικεία @ σημειογραφία. Με παραμέτρους SQL παρέχει έναν ισχυρό χειρισμός και Απαλλαχτείτε από χρήστη εισαγωγής, αποτροπή τυχαίες έκθεσης των δεδομένων με εισαγωγή SQL. 

Για παράδειγμα, μπορείτε να συντάξετε ένα ερώτημα που λαμβάνει επώνυμο και διεύθυνση κατάσταση ως παραμέτρους και, στη συνέχεια, να το εκτελέσει για διάφορες τιμές, επώνυμο και διεύθυνση κατάσταση που βασίζονται σε εισαγωγή από το χρήστη.

    SELECT * 
    FROM Families f
    WHERE f.lastName = @lastName AND f.address.state = @addressState

Αυτή η αίτηση μπορούν στη συνέχεια, να σταλούν στον DocumentDB ως ερώτημα με παραμέτρους JSON όπως φαίνεται παρακάτω.

    {      
        "query": "SELECT * FROM Families f WHERE f.lastName = @lastName AND f.address.state = @addressState",     
        "parameters": [          
            {"name": "@lastName", "value": "Wakefield"},         
            {"name": "@addressState", "value": "NY"},           
        ] 
    }

Το όρισμα στην ΑΡΧΉ μπορεί να οριστεί με χρήση ερωτημάτων με παραμέτρους όπως φαίνεται παρακάτω.

    {      
        "query": "SELECT TOP @n * FROM Families",     
        "parameters": [          
            {"name": "@n", "value": 10},         
        ] 
    }

Τιμές παραμέτρων μπορεί να είναι οποιαδήποτε έγκυρη JSON (συμβολοσειρές, αριθμοί, λογικές τιμές, null, ακόμα και πίνακες ή ένθετα JSON). Επίσης εφόσον DocumentDB είναι λιγότερο σχήματος, παραμέτρους δεν επικυρώνονται από οποιονδήποτε τύπο.

##<a name="built-in-functions"></a>Ενσωματωμένες συναρτήσεις
DocumentDB υποστηρίζει επίσης έναν αριθμό από ενσωματωμένες συναρτήσεις για τις κοινές εργασίες, που μπορούν να χρησιμοποιηθούν μέσα σε ερωτήματα όπως οι συναρτήσεις που ορίζονται από το χρήστη (UDF).

<table>
<tr>
<td>Μαθηματικές συναρτήσεις</td> 
<td>ABS, ανώτατο ΌΡΙΟ, EXP, FLOOR, αρχείο ΚΑΤΑΓΡΑΦΉΣ, LOG10, POWER, ROUND, ΕΙΣΌΔΟΥ, SQRT, ΤΕΤΡΆΓΩΝΟ, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, ΜΟΊΡΕΣ, π, ΑΚΤΊΝΙΑ, SIN και TAN</td>
</tr>
<tr>
<td>Συναρτήσεις ελέγχου τύπου</td>    
<td>IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED και IS_PRIMITIVE</td>
</tr>
<tr>
<td>Συναρτήσεις συμβολοσειράς</td>   
<td>CONCAT, ΠΕΡΙΈΧΕΙ, ENDSWITH, INDEX_OF, ΑΡΙΣΤΕΡΆ, ΜΉΚΟΣ, ΚΆΤΩ, LTRIM, ΑΝΤΙΚΑΤΆΣΤΑΣΗ, ΑΝΤΙΓΡΑΦΉ, ΑΝΤΊΣΤΡΟΦΗ, ΔΕΞΙΆ, RTRIM, STARTSWITH, δευτερεύουσας ΣΥΜΒΟΛΟΣΕΙΡΆΣ και ΕΠΆΝΩ</td>
</tr>
<tr>
<td>Συναρτήσεις πίνακα</td>    
<td>ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH και ARRAY_SLICE</td>
</tr>
<tr>
<td>Συναρτήσεις χώρου</td>  
<td>ST_DISTANCE, ST_WITHIN, ST_ISVALID και ST_ISVALIDDETAILED</td>
</tr>
</table>  

Εάν χρησιμοποιείτε μια συνάρτηση που ορίζονται από το χρήστη (UDF) για την οποία μια ενσωματωμένη συνάρτηση είναι πλέον διαθέσιμη αυτήν τη στιγμή, θα πρέπει να μπορείτε να χρησιμοποιήσετε τη συνάρτηση αντίστοιχο ενσωματωμένο, καθώς πρόκειται να είναι πιο γρήγορο να εκτελέσετε και πιο αποτελεσματικά. 

### <a name="mathematical-functions"></a>Μαθηματικές συναρτήσεις
Οι μαθηματικές συναρτήσεις κάθε εκτελέσετε έναν υπολογισμό, συνήθως με βάση τις τιμές εισαγωγής που παρέχονται ως ορίσματα και να επιστρέψετε μια αριθμητική τιμή. Ακολουθεί ένας πίνακας υποστηριζόμενες ενσωματωμένες συναρτήσεις μαθηματικών.

<table>
<tr>
<td><strong>Χρήση</strong></td>
<td><strong>Περιγραφή</strong></td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_abs">ABS (num_expr)</a></td> 
<td>Επιστρέφει την απόλυτη τιμή (θετικός) από το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_ceiling">CEILING (num_expr)</a></td> 
<td>Επιστρέφει τη μικρότερη τιμή ακέραιο αριθμό μεγαλύτερο ή ίσο με το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_floor">FLOOR (num_expr)</a></td> 
<td>Ο μεγαλύτερος ακέραιος επιστρέφει μικρότερη ή ίση με την καθορισμένη αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_exp">EXP (num_expr)</a></td> 
<td>Επιστρέφει εκθέτη από το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_log">LOG (num_expr [, βάση])</a></td> 
<td>Επιστρέφει τον φυσικό λογάριθμο το καθορισμένο αριθμητική παράσταση ή το λογάριθμο με την καθορισμένη βάση</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_log10">LOG10 (num_expr)</a></td> 
<td>Επιστρέφει την τιμή λογαριθμική βάση το 10 από το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_round">ROUND (num_expr)</a></td> 
<td>Επιστρέφει μια αριθμητική τιμή, στρογγυλοποιημένο προς την πλησιέστερη ακέραια τιμή.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_trunc">TRUNC (num_expr)</a></td> 
<td>Επιστρέφει μια αριθμητική τιμή, ώστε να την πλησιέστερη ακέραια τιμή.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_sqrt">Συνάρτηση SQRT (num_expr)</a></td>   
<td>Επιστρέφει την τετραγωνική ρίζα του καθορισμένου αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_square">ΤΕΤΡΆΓΩΝΟ (num_expr)</a></td>   
<td>Επιστρέφει το τετράγωνο του το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_power">POWER (num_expr, num_expr)</a></td>   
<td>Επιστρέφει την τιμή που καθορίστηκε στη δύναμη του το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_sign">ΣΎΜΒΟΛΟ (num_expr)</a></td>   
<td>Επιστρέφει την τιμή εισόδου (-1, 0, 1) από το καθορισμένο αριθμητική παράσταση.</td>
</tr>
<tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_acos">ACOS (num_expr)</a></td>   
<td>Επιστρέφει τη γωνία σε ακτίνια, της οποίας το συνημίτονο είναι η καθορισμένη αριθμητική παράσταση, ονομάζεται επίσης τόξο συνημίτονου.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_asin">ASIN (num_expr)</a></td>   
<td>Επιστρέφει τη γωνία σε ακτίνια, της οποίας το ημίτονο είναι η καθορισμένη αριθμητική παράσταση. Αυτό ονομάζεται επίσης τόξο ημιτόνου.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_atan">ATAN (num_expr)</a></td>   
<td>Επιστρέφει τη γωνία, σε ακτίνια, των οποίων η εφαπτομένη είναι η καθορισμένη αριθμητική παράσταση. Αυτό ονομάζεται επίσης το τόξο εφαπτομένης.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_atn2">ATN2 (num_expr)</a></td>   
<td>Επιστρέφει τη γωνία, σε ακτίνια, μεταξύ του άξονα x θετικό και το ακτίνας από το αρχικό σημείο στο σημείο (y, x), όπου x και y είναι οι τιμές από τις δύο παραστάσεις καθορισμένο Αιώρηση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_cos">COS (num_expr)</a></td> 
<td>Επιστρέφει το συνημίτονο τριγωνομετρικές της καθορισμένης γωνίας, σε ακτίνια, με την καθορισμένη έκφραση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_cot">COT (num_expr)</a></td> 
<td>Επιστρέφει τη συνεφαπτομένη τριγωνομετρικές της καθορισμένης γωνίας, σε ακτίνια, με την καθορισμένη αριθμητική παράσταση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_degrees">ΜΟΊΡΕΣ (num_expr)</a></td> 
<td>Επιστρέφει την αντίστοιχη γωνία σε μοίρες για μιας γωνίας καθορισμένης σε ακτίνια.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_pi">PI)</a></td>   
<td>Επιστρέφει την τιμή της σταθεράς π.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_radians">ΑΚΤΊΝΙΑ (num_expr)</a></td> 
<td>Όταν εισάγεται μια αριθμητική παράσταση, σε μοίρες, η συνάρτηση επιστρέφει ακτίνια.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_sin">SIN (num_expr)</a></td> 
<td>Επιστρέφει το ημίτονο της καθορισμένης γωνίας, του τριγωνομετρικές σε ακτίνια, με την καθορισμένη έκφραση.</td>
</tr>
<tr>
<td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_tan">TAN (num_expr)</a></td> 
<td>Επιστρέφει την εφαπτομένη της παράστασης εισαγωγής, στην καθορισμένη παράσταση.</td>
</tr>

</table> 

Για παράδειγμα, τώρα μπορείτε να εκτελέσετε ερωτήματα όπως το εξής:

**Ερώτημα**

    SELECT VALUE ABS(-4)

**Αποτελέσματα**

    [4]

Η κύρια διαφορά μεταξύ του DocumentDB συναρτήσεων σε σύγκριση με το ANSI SQL είναι ότι έχουν σχεδιαστεί ώστε να λειτουργεί καλύτερα με δεδομένα σχήματος λιγότερο και μεικτών σχήματος. Για παράδειγμα, εάν έχετε ένα έγγραφο όπου η ιδιότητα Size λείπει ή έχει μια μη αριθμητική τιμή, όπως "Άγνωστο", στη συνέχεια, το έγγραφο παραλείπεται μέσω, αντί να επιστρέφει ένα σφάλμα.

### <a name="type-checking-functions"></a>Συναρτήσεις ελέγχου τύπου
Τις συναρτήσεις ελέγχου τύπου σάς επιτρέπουν να ελέγξετε τον τύπο μιας παράστασης σε ερωτήματα SQL. Συναρτήσεις ελέγχου τύπου μπορεί να χρησιμοποιηθεί για να προσδιορίσετε τον τύπο της ιδιότητες μέσα σε έγγραφα του όταν είναι μεταβλητό ή άγνωστη. Ακολουθεί ένας πίνακας ελέγχου συναρτήσεις υποστηρίζονται ενσωματωμένη τύπου.

<table>
<tr>
  <td><strong>Χρήση</strong></td>
  <td><strong>Περιγραφή</strong></td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_array">IS_ARRAY (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι ένας πίνακας.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_bool">IS_BOOL (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι μια τιμή Boolean.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_null">IS_NULL (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι null.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_number">IS_NUMBER (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι ένας αριθμός.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_object">IS_OBJECT (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι ένα αντικείμενο JSON.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_string">IS_STRING (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι μια συμβολοσειρά.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_defined">IS_DEFINED (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν η ιδιότητα έχει εκχωρηθεί μια τιμή.</td>
</tr>
<tr>
  <td><a href="https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_is_primitive">IS_PRIMITIVE (παράσταση)</a></td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν ο τύπος της τιμής είναι συμβολοσειρά, αριθμός, δυαδική τιμή ή null.</td>
</tr>

</table>

Χρησιμοποιώντας αυτές τις συναρτήσεις, τώρα μπορείτε να εκτελέσετε ερωτήματα όπως το εξής:

**Ερώτημα**

    SELECT VALUE IS_NUMBER(-4)

**Αποτελέσματα**

    [true]

### <a name="string-functions"></a>Συναρτήσεις συμβολοσειράς
Οι παρακάτω συναρτήσεις ανυσμάτων εκτελέσετε μια πράξη σε μια τιμή συμβολοσειρά εισόδου και να επιστρέψετε μια συμβολοσειρά, αριθμητικά ή δυαδική τιμή. Ακολουθεί ένας πίνακας συναρτήσεων ενσωματωμένη συμβολοσειράς:

Χρήση|Περιγραφή
---|---
[ΜΉΚΟΣ (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_length)|Επιστρέφει το πλήθος των χαρακτήρων της καθορισμένης συμβολοσειράς παράστασης
[CONCAT (str_expr, str_expr [, str_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_concat)|Επιστρέφει μια συμβολοσειρά που είναι το αποτέλεσμα της συνένωση δύο ή περισσότερες τιμές συμβολοσειρών.
[ΔΕΥΤΕΡΕΎΟΥΣΑ (str_expr, num_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_substring)|Επιστρέφει το τμήμα του παράσταση συμβολοσειράς.
[STARTSWITH (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_startswith)|Επιστρέφει μια Boolean που υποδεικνύει εάν η πρώτη παράσταση συμβολοσειράς τελειώνει με το δεύτερο
[ENDSWITH (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_endswith)|Επιστρέφει μια Boolean που υποδεικνύει εάν η πρώτη παράσταση συμβολοσειράς τελειώνει με το δεύτερο
[ΠΕΡΙΈΧΕΙ (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_contains)|Επιστρέφει μια Boolean που υποδεικνύει εάν η πρώτη παράσταση συμβολοσειράς περιέχει τα δευτερόλεπτα.
[INDEX_OF (str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_index_of)|Επιστρέφει την αρχική θέση της πρώτης εμφάνισης του δεύτερου συμβολοσειρά παράσταση μέσα στην πρώτη παράσταση καθορισμένη συμβολοσειρά, ή -1, εάν η συμβολοσειρά δεν βρεθεί.
[LEFT (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_left)|Επιστρέφει το αριστερό μέρος της συμβολοσειράς με τον καθορισμένο αριθμό χαρακτήρων.
[RIGHT (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_right)|Επιστρέφει το δεξιό τμήμα της συμβολοσειράς με τον καθορισμένο αριθμό χαρακτήρων.
[LTRIM (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_ltrim)|Επιστρέφει μια παράσταση συμβολοσειράς μετά την καταργεί τα αρχικά κενά.
[RTRIM (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_rtrim)|Επιστρέφει μια παράσταση συμβολοσειράς μετά από περικοπή όλα τα τελικά κενά.
[ΚΆΤΩ (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_lower)|Επιστρέφει μια παράσταση συμβολοσειράς μετά τη μετατροπή δεδομένων κεφαλαίων χαρακτήρων σε πεζά.
[ΕΠΆΝΩ (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_upper)|Επιστρέφει μια παράσταση συμβολοσειράς μετά τη μετατροπή δεδομένων χαρακτήρων πεζά σε κεφαλαία γράμματα.
[ΑΝΤΙΚΑΤΆΣΤΑΣΗ (str_expr, str_expr, str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_replace)|Αντικαθιστά όλες τις εμφανίσεις του μια τιμή της καθορισμένης συμβολοσειράς με μια άλλη τιμή συμβολοσειράς.
[ΑΝΤΙΓΡΑΦΉ (str_expr, num_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_replicate)|Επαναλαμβάνει μια τιμή συμβολοσειρά έναν καθορισμένο αριθμό φορών.
[ΑΝΤΙΣΤΡΟΦΉ (str_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_reverse)|Επιστρέφει την αντίστροφη σειρά του μια τιμή συμβολοσειράς.

Χρησιμοποιώντας αυτές τις συναρτήσεις, τώρα μπορείτε να εκτελέσετε ερωτήματα όπως το εξής. Για παράδειγμα, μπορείτε να επιστρέψετε το όνομα της οικογένειας με κεφαλαία ως εξής:

**Ερώτημα**

    SELECT VALUE UPPER(Families.id)
    FROM Families

**Αποτελέσματα**

    [
        "WAKEFIELDFAMILY", 
        "ANDERSENFAMILY"
    ]

Ή συνένωση συμβολοσειρών όπως σε αυτό το παράδειγμα:

**Ερώτημα**

    SELECT Families.id, CONCAT(Families.address.city, ",", Families.address.state) AS location
    FROM Families

**Αποτελέσματα**

    [{
      "id": "WakefieldFamily",
      "location": "NY,NY"
    },
    {
      "id": "AndersenFamily",
      "location": "seattle,WA"
    }]


Συναρτήσεις συμβολοσειράς μπορεί επίσης να χρησιμοποιηθεί στον όρο WHERE για να φιλτράρετε τα αποτελέσματα, όπως στο ακόλουθο παράδειγμα:

**Ερώτημα**

    SELECT Families.id, Families.address.city
    FROM Families
    WHERE STARTSWITH(Families.id, "Wakefield")

**Αποτελέσματα**

    [{
      "id": "WakefieldFamily",
      "city": "NY"
    }]

### <a name="array-functions"></a>Συναρτήσεις πίνακα
Οι παρακάτω συναρτήσεις ανυσμάτων εκτελέσετε μια πράξη σε μια τιμή εισόδου πίνακα και επιστροφής αριθμητικές, τιμή Boolean ή έναν πίνακα. Ακολουθεί ένας πίνακας των συναρτήσεων ενσωματωμένη πίνακα:

Χρήση|Περιγραφή
---|---
[ARRAY_LENGTH (arr_expr)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_length)|Επιστρέφει τον αριθμό των στοιχείων της παράστασης καθορισμένο πίνακα.
[ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_concat)|Επιστρέφει έναν πίνακα που είναι το αποτέλεσμα της συνένωση δύο ή περισσότερες τιμές πίνακα.
[ARRAY_CONTAINS (arr_expr, παράσταση)](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_contains)|Επιστρέφει μια τιμή Boolean που υποδεικνύει εάν το όρισμα πίνακας περιέχει την καθορισμένη τιμή.
[ARRAY_SLICE (arr_expr, num_expr [, num_expr])](https://msdn.microsoft.com/library/azure/dn782250.aspx#bk_array_slice)|Επιστρέφει το τμήμα μιας παράστασης πίνακα.

Συναρτήσεις πίνακα μπορεί να χρησιμοποιηθεί για να χειριστείτε πίνακες μέσα σε JSON. Για παράδειγμα, ακολουθεί ένα ερώτημα που επιστρέφει όλα τα έγγραφα όπου έναν από τους γονείς "Robin Wakefield". 

**Ερώτημα**

    SELECT Families.id 
    FROM Families 
    WHERE ARRAY_CONTAINS(Families.parents, { givenName: "Robin", familyName: "Wakefield" })

**Αποτελέσματα**

    [{
      "id": "WakefieldFamily"
    }]

Ακολουθεί ένα ακόμη παράδειγμα που χρησιμοποιεί ARRAY_LENGTH για να βρείτε τον αριθμό των παιδιών ανά οικογένεια.

**Ερώτημα**

    SELECT Families.id, ARRAY_LENGTH(Families.children) AS numberOfChildren
    FROM Families 

**Αποτελέσματα**

    [{
      "id": "WakefieldFamily",
      "numberOfChildren": 2
    },
    {
      "id": "AndersenFamily",
      "numberOfChildren": 1
    }]

### <a name="spatial-functions"></a>Συναρτήσεις χώρου

DocumentDB υποστηρίζει τις παρακάτω ενσωματωμένες συναρτήσεις Άνοιγμα σε Γεωχωρικά Consortium (OGC) για την υποβολή ερωτημάτων σε γεωχωρικά. Για περισσότερες λεπτομέρειες σχετικά με σε γεωχωρικά υποστήριξης στο DocumentDB, ανατρέξτε στο θέμα [εργασία με σε γεωχωρικά δεδομένα σε Azure DocumentDB](documentdb-geospatial.md). 

<table>
<tr>
  <td><strong>Χρήση</strong></td>
  <td><strong>Περιγραφή</strong></td>
</tr>
<tr>
  <td>ST_DISTANCE (point_expr, point_expr)</td>
  <td>Επιστρέφει την απόσταση μεταξύ τις δύο παραστάσεις σημείο GeoJSON.</td>
</tr>
<tr>
  <td>ST_WITHIN (point_expr, polygon_expr)</td>
  <td>Επιστρέφει μια δυαδική παράσταση που υποδεικνύει εάν το σημείο GeoJSON που καθορίζεται στο πρώτο όρισμα είναι εντός του πολυγώνου GeoJSON στο δεύτερο όρισμα.</td>
</tr>
<tr>
  <td>ST_ISVALID</td>
  <td>Επιστρέφει μια τιμή Boolean που υποδεικνύει αν το καθορισμένο GeoJSON σημείο ή πολύγωνου παράσταση είναι έγκυρα.</td>
</tr>
<tr>
  <td>ST_ISVALIDDETAILED</td>
  <td>Επιστρέφει την τιμή μια τιμή JSON που περιέχει μια τιμή Boolean εάν η καθορισμένη παράσταση σημείο ή πολύγωνου GeoJSON είναι έγκυρη και δεν είναι έγκυρο, επιπλέον το λόγο για τον ως μια τιμή συμβολοσειράς.</td>
</tr>
</table>

Συναρτήσεις χώρου μπορούν να χρησιμοποιηθούν για την εκτέλεση querries εγγύτητα έναντι χώρου δεδομένων. Για παράδειγμα, ακολουθεί ένα ερώτημα που επιστρέφει όλα τα έγγραφα οικογένειας που βρίσκονται εντός 30 χιλιόμετρα του στη θέση που καθορίζεται με χρήση της συνάρτησης ενσωματωμένη ST_DISTANCE. 

**Ερώτημα**

    SELECT f.id 
    FROM Families f 
    WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000

**Αποτελέσματα**

    [{
      "id": "WakefieldFamily"
    }]

Εάν συμπεριλάβετε χώρου δημιουργίας ευρετηρίου στην πολιτική δημιουργίας ευρετηρίου σας, στη συνέχεια, "απόσταση ερωτήματα" θα είναι που σερβιρίστηκε αποτελεσματικά έως το ευρετήριο. Για περισσότερες λεπτομέρειες σχετικά με τη δημιουργία ευρετηρίου χώρου, ανατρέξτε στην ενότητα παρακάτω. Εάν δεν έχετε ένα ευρετήριο χώρου για την καθορισμένη διαδρομές, μπορείτε να εκτελέσετε εξακολουθεί να χώρου ερωτημάτων, καθορίζοντας `x-ms-documentdb-query-enable-scan` κεφαλίδα αίτησης με την τιμή ρυθμισμένη στην τιμή "true". Στο .NET, αυτό μπορεί να γίνει, μεταφέροντας το προαιρετικό όρισμα **FeedOptions** στα ερωτήματα με [EnableScanInQuery](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery) οριστεί στην τιμή true. 

ST_WITHIN μπορεί να χρησιμοποιηθεί για να ελέγξετε εάν ένα σημείο βρίσκεται μέσα σε ένα πολύγωνο. Συνήθως πολύγωνα που χρησιμοποιούνται για την αναπαράσταση όρια, όπως ταχυδρομικοί κώδικες, όρια κατάστασης ή φυσική σχηματισμούς. Ξανά Εάν συμπεριλάβετε χώρου δημιουργίας ευρετηρίου στην πολιτική δημιουργίας ευρετηρίου σας, στη συνέχεια, "μέσα" ερωτήματα θα είναι που σερβιρίστηκε αποτελεσματική έως το ευρετήριο. 

Ορίσματα πολύγωνου στο ST_WITHIN μπορεί να περιέχει μόνο ένα κουδούνισμα, δηλαδή τα πολύγωνα δεν πρέπει να περιέχουν κενά σε αυτές. Ελέγξτε τα [όρια DocumentDB](documentdb-limits.md) για τον μέγιστο αριθμό των σημείων που επιτρέπονται στον πολύγωνου για ένα ερώτημα ST_WITHIN.

**Ερώτημα**

    SELECT * 
    FROM Families f 
    WHERE ST_WITHIN(f.location, {
        'type':'Polygon', 
        'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]
    })

**Αποτελέσματα**

    [{
      "id": "WakefieldFamily",
    }]
    
>[AZURE.NOTE] Παρόμοια με τον τρόπο που δεν συμφωνούν τύποι λειτουργεί στο ερώτημα DocumentDB, εάν η τιμή θέση που καθορίζεται στο είτε όρισμα είναι ακατάλληλη ή δεν είναι έγκυρη και, στη συνέχεια, να **απροσδιόριστη** και αξιολογηθεί έγγραφο για να γίνει παράκαμψη από τα αποτελέσματα του ερωτήματος θα είναι το. Εάν το ερώτημα επιστρέφει κανένα αποτέλεσμα, εκτελέστε ST_ISVALIDDETAILED σε ο εντοπισμός σφαλμάτων γιατί ο τύπος spatail δεν είναι έγκυρη.     

ST_ISVALID και ST_ISVALIDDETAILED μπορεί να χρησιμοποιηθεί για να ελέγξετε εάν ένα αντικείμενο χώρου είναι έγκυρη. Για παράδειγμα, το ακόλουθο ερώτημα ελέγχει την εγκυρότητα ενός σημείου με μια εκτός της περιοχής γεωγραφικό πλάτος τιμή (-132.8). ST_ISVALID επιστρέφει μόνο μια τιμή Boolean και ST_ISVALIDDETAILED επιστρέφει την τιμή Boolean και μια συμβολοσειρά που περιέχει το λόγο για τον γιατί θεωρείται μη έγκυροι.

**Ερώτημα**

    SELECT ST_ISVALID({ "type": "Point", "coordinates": [31.9, -132.8] })

**Αποτελέσματα**

    [{
      "$1": false
    }]

Αυτές οι συναρτήσεις επίσης μπορεί να χρησιμοποιηθεί για την επικύρωση πολύγωνα. Για παράδειγμα, δείτε εδώ χρησιμοποιούμε ST_ISVALIDDETAILED για την επικύρωση πολύγωνου που δεν είναι κλειστό. 

**Ερώτημα**

    SELECT ST_ISVALIDDETAILED({ "type": "Polygon", "coordinates": [[ 
        [ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] 
        ]]})

**Αποτελέσματα**

    [{
       "$1": { 
          "valid": false, 
          "reason": "The Polygon input is not valid because the start and end points of the ring number 1 are not the same. Each ring of a polygon must have the same start and end points." 
        }
    }]
    
Που αναδιπλώνεται χώρου συναρτήσεις και τη σύνταξη SQL για DocumentDB. Τώρα ας δούμε πώς LINQ υποβολή ερωτημάτων έργων και τον τρόπο αλληλεπιδρά με τη σύνταξη μας έχετε δει μέχρι στιγμής.

## <a name="linq-to-documentdb-sql"></a>LINQ σε DocumentDB SQL
LINQ είναι ένα μοντέλο προγραμματισμού .NET που εκφράζει κατά τον υπολογισμό ως ερωτήματα σε ροές αντικειμένων. DocumentDB παρέχει ένα πρόγραμμα-πελάτη πλευρά βιβλιοθήκης για αλληλεπίδραση με LINQ με τη διευκόλυνση της μετατροπή μεταξύ JSON και .NET αντικείμενα και μια αντιστοίχιση από ένα υποσύνολο LINQ ερωτήματα για να DocumentDB ερωτήματα. 

Στην παρακάτω εικόνα εμφανίζεται η αρχιτεκτονική της υποστήριξης LINQ ερωτημάτων με το DocumentDB.  Χρησιμοποιώντας το πρόγραμμα-πελάτη DocumentDB, τους προγραμματιστές να δημιουργήσετε ένα αντικείμενο **IQueryable** που ερωτήματα απευθείας την υπηρεσία παροχής ερωτήματος DocumentDB, το οποίο, στη συνέχεια, μεταφράζει το ερώτημα LINQ σε ένα ερώτημα DocumentDB. Το ερώτημα μεταβιβάζεται, στη συνέχεια, στο διακομιστή DocumentDB για να ανακτήσετε ένα σύνολο αποτελεσμάτων σε μορφή JSON. Τα αποτελέσματα που επιστρέφεται είναι η αποσειριοποίηση σε μια ροή αντικειμένων .NET στην πλευρά του προγράμματος-πελάτη.

![Αρχιτεκτονική της υποστήριξης LINQ ερωτημάτων με το DocumentDB - σύνταξη SQL, JSON γλώσσα ερωτημάτων, έννοιες βάσης δεδομένων και ερωτήματα SQL][1]
 


### <a name="net-and-json-mapping"></a>Αντιστοίχιση JSON και .NET
Η αντιστοίχιση μεταξύ των αντικειμένων .NET και έγγραφα JSON είναι φυσική - κάθε πεδίο μέλος δεδομένων έχει αντιστοιχιστεί σε ένα αντικείμενο JSON, όπου το όνομα του πεδίου έχει αντιστοιχιστεί στο τμήμα "αριθμός-κλειδί" του αντικειμένου και το τμήμα "τιμή" είναι σταδιακά αντιστοιχιστεί το τμήμα της τιμής του αντικειμένου. Εξετάστε το παρακάτω παράδειγμα. Το αντικείμενο οικογένεια δημιουργήθηκε έχει αντιστοιχιστεί στο έγγραφο JSON όπως φαίνεται παρακάτω. Και το αντίστροφο, το έγγραφο JSON έχει αντιστοιχιστεί σε ένα αντικείμενο .NET.

**C# τάξης**

    public class Family
    {
        [JsonProperty(PropertyName="id")]
        public string Id;
        public Parent[] parents;
        public Child[] children;
        public bool isRegistered;
    };
    
    public struct Parent
    {
        public string familyName;
        public string givenName;
    };
    
    public class Child
    {
        public string familyName;
        public string givenName;
        public string gender;
        public int grade;
        public List<Pet> pets;
    };
    
    public class Pet
    {
        public string givenName;
    };
    
    public class Address
    {
        public string state;
        public string county;
        public string city;
    };
    
    // Create a Family object.
    Parent mother = new Parent { familyName= "Wakefield", givenName="Robin" };
    Parent father = new Parent { familyName = "Miller", givenName = "Ben" };
    Child child = new Child { familyName="Merriam", givenName="Jesse", gender="female", grade=1 };
    Pet pet = new Pet { givenName = "Fluffy" };
    Address address = new Address { state = "NY", county = "Manhattan", city = "NY" };
    Family family = new Family { Id = "WakefieldFamily", parents = new Parent [] { mother, father}, children = new Child[] { child }, isRegistered = false };


**JSON**  

    {
        "id": "WakefieldFamily",
        "parents": [
            { "familyName": "Wakefield", "givenName": "Robin" },
            { "familyName": "Miller", "givenName": "Ben" }
        ],
        "children": [
            {
                "familyName": "Merriam", 
                "givenName": "Jesse", 
                "gender": "female", 
                "grade": 1,
                "pets": [
                    { "givenName": "Goofy" },
                    { "givenName": "Shadow" }
                ]
            },
            { 
              "familyName": "Miller", 
              "givenName": "Lisa", 
              "gender": "female", 
              "grade": 8 
            }
        ],
        "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
        "isRegistered": false
    };



### <a name="linq-to-sql-translation"></a>LINQ για SQL μετάφρασης
Η υπηρεσία παροχής ερωτήματος DocumentDB εκτελεί μια βέλτιστη αντιστοίχιση προσπάθειας από ένα ερώτημα LINQ σε ένα ερώτημα DocumentDB SQL. Στην παρακάτω περιγραφή, υποθέσουμε ότι το πρόγραμμα ανάγνωσης περιλαμβάνει μια βασική οικείο περιβάλλον του LINQ.

Πρώτα, για το σύστημα τύπος, υποστηρίζουμε όλα JSON στοιχειώδεις τύπους – αριθμητική τύπους, boolean, συμβολοσειρά και null. Υποστηρίζονται μόνο αυτοί οι τύποι JSON. Υποστηρίζονται οι παρακάτω παραστάσεις ανυσματική.

-   Σταθερές τιμές – αυτά περιλαμβάνει σταθερών τιμών από τους τύπους δεδομένων στοιχειώδεις κατά την αξιολόγηση του ερωτήματος.

-   Ιδιότητα/πίνακα ευρετήριο παραστάσεις-αυτές οι παραστάσεις αναφέρουν την ιδιότητα του αντικειμένου ή ένα στοιχείο του πίνακα.

        family.Id;
        family.children[0].familyName;
        family.children[0].grade;
        family.children[n].grade; //n is an int variable

-   Αριθμητικοί παραστάσεις - αυτά περιλαμβάνουν κοινές αριθμητικοί εκφράσεις στις τιμές αριθμητικά και boolean. Για την πλήρη λίστα, ανατρέξτε στις προδιαγραφές SQL.

        2 * family.children[0].grade;
        x + y;

-   Παράσταση συμβολοσειράς σύγκρισης - αυτά περιλαμβάνουν σύγκριση τιμή συμβολοσειράς με κάποια τιμή σταθεράς συμβολοσειρά.  
 
        mother.familyName == "Smith";
        child.givenName == s; //s is a string variable

-   Αντικείμενο/πίνακας έκφραση δημιουργίας - αυτές οι παραστάσεις επιστροφής ένα αντικείμενο τύπου σύνθετης τιμή ή ανώνυμου τύπου ή ένας πίνακας με αυτά τα αντικείμενα. Αυτές οι τιμές μπορούν να ενσωματωθούν.

        new Parent { familyName = "Smith", givenName = "Joe" };
        new { first = 1, second = 2 }; //an anonymous type with 2 fields              
        new int[] { 3, child.grade, 5 };

### <a name="list-of-supported-linq-operators"></a>Λίστα των υποστηριζόμενες LINQ τελεστών
Ακολουθεί μια λίστα με τις υποστηριζόμενες LINQ τελεστές στην υπηρεσία παροχής LINQ περιλαμβάνεται με το .NET SDK DocumentDB.

-   **Επιλέξτε**: προβλέψεις μετάφραση για να ΕΠΙΛΈΞΕΤΕ το SQL συμπεριλαμβανομένων κατασκευή αντικειμένου
-   **Όπου**: φίλτρα μετάφραση προς το SQL όπου και υποστήριξη μετάφρασης μεταξύ & &, || και! Οι τελεστές SQL
-   **SelectMany**: επιτρέπει άλλων δικαιοπραξιών πίνακες για να τον όρο SQL ΣΥΜΜΕΤΟΧΉ. Μπορεί να χρησιμοποιηθεί για αλυσίδας/φωλιά παραστάσεις για να φιλτράρετε στοιχεία πίνακα
-   **OrderBy και OrderByDescending**: μεταφράζεται σε ΣΕΙΡΆ κατά αύξουσα/φθίνουσα σειρά:
-   **CompareTo**: μεταφράζεται σε περιοχή συγκρίσεις. Χρησιμοποιείται συνήθως για τις συμβολοσειρές, επειδή δεν είναι συγκρίσιμη στο .NET
-   **Λήψη**: μεταφράζεται στο επάνω μέρος του SQL για τον περιορισμό των αποτελεσμάτων ενός ερωτήματος
-   **Μαθηματικές συναρτήσεις**: υποστηρίζει μετάφρασης από. Asin Abs, Acos, του NET, Atan, Ceiling, Cos, Exp, Floor, αρχείο καταγραφής, Log10, Pow, Round, εισόδου, Sin, Sqrt, Tan, περικοπή στο ισοδύναμο ενσωματωμένες συναρτήσεις SQL.
-   **Συναρτήσεις συμβολοσειράς**: υποστηρίζει μετάφραση από. EndsWith Concat, περιέχει, της Καθαρής, IndexOf, καταμέτρηση, ToLower, TrimStart, αντικατάσταση, αντιστροφή, TrimEnd, StartsWith, δευτερεύουσα συμβολοσειρά, ToUpper για να τις ισοδύναμη ενσωματωμένες συναρτήσεις SQL.
-   **Συναρτήσεις πίνακα**: υποστηρίζει μετάφραση από. Της Καθαρής Concat περιέχει και καταμέτρηση, για να τις ισοδύναμη ενσωματωμένες συναρτήσεις SQL.
-   **Οι συναρτήσεις επέκτασης σε Γεωχωρικά**: υποστηρίζει μετάφραση από τις μεθόδους στέλεχος απόσταση, εντός του, IsValid και IsValidDetailed στα ισοδύναμη ενσωματωμένες συναρτήσεις SQL.
-   **Συνάρτηση επέκτασης που ορίζονται από το χρήστη συνάρτηση**: υποστηρίζει μετάφραση από τη μέθοδο στέλεχος UserDefinedFunctionProvider.Invoke στο αντίστοιχο χρήστη που ορίζονται από το συνάρτηση.
-   **Διάφορα**: υποστηρίζει μετάφρασης της συνένωσης και τελεστές υπό όρους. Να μεταφράσετε περιέχει να ΠΕΡΙΈΧΕΙ συμβολοσειρά, ARRAY_CONTAINS ή το SQL σε ανάλογα με το περιβάλλον.

### <a name="sql-query-operators"></a>Τελεστές ερωτήματος SQL
Ακολουθούν ορισμένα παραδείγματα που δείχνουν πώς ορισμένα από την τυπική τελεστές ερωτήματος LINQ μεταφράζονται προς τα κάτω σε DocumentDB ερωτήματα.

#### <a name="select-operator"></a>Επιλέξτε τελεστή
Η σύνταξη είναι `input.Select(x => f(x))`, όπου `f` είναι μια ανυσματική παράσταση.

**Παράσταση λάμδα LINQ**

    input.Select(family => family.parents[0].familyName);

**SQL** 

    SELECT VALUE f.parents[0].familyName
    FROM Families f



**Παράσταση λάμδα LINQ**

    input.Select(family => family.children[0].grade + c); // c is an int variable


**SQL** 

    SELECT VALUE f.children[0].grade + c
    FROM Families f 



**Παράσταση λάμδα LINQ**

    input.Select(family => new
    {
        name = family.children[0].familyName,
        grade = family.children[0].grade + 3
    });


**SQL** 

    SELECT VALUE {"name":f.children[0].familyName, 
                  "grade": f.children[0].grade + 3 }
    FROM Families f



#### <a name="selectmany-operator"></a>Τελεστής SelectMany
Η σύνταξη είναι `input.SelectMany(x => f(x))`, όπου `f` είναι μια ανυσματική παράσταση που επιστρέφει έναν τύπο συλλογής.

**Παράσταση λάμδα LINQ**

    input.SelectMany(family => family.children);

**SQL** 

    SELECT VALUE child
    FROM child IN Families.children



#### <a name="where-operator"></a>Όπου τελεστή
Η σύνταξη είναι `input.Where(x => f(x))`, όπου `f` είναι μια ανυσματική παράσταση που επιστρέφει μια τιμή Boolean.

**Παράσταση λάμδα LINQ**

    input.Where(family=> family.parents[0].familyName == "Smith");

**SQL** 

    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith" 



**Παράσταση λάμδα LINQ**

    input.Where(
        family => family.parents[0].familyName == "Smith" && 
        family.children[0].grade < 3);

**SQL** 

    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"
    AND f.children[0].grade < 3


### <a name="composite-sql-queries"></a>Σύνθετα ερωτήματα SQL
Το παραπάνω τελεστές μπορούν να αποτελούνται για να σχηματίσουν πιο ισχυρή ερωτήματα. Αφού DocumentDB υποστηρίζει ένθετων συλλογές, τη σύνθεση να είτε να συνδέονται ή ένθετων συναρτήσεων.

#### <a name="concatenation"></a>Συνένωση 

Η σύνταξη είναι `input(.|.SelectMany())(.Select()|.Where())*`. Ένα ερώτημα συνένωσης να ξεκινήσετε με μια προαιρετική `SelectMany` ερώτημα ακολουθούμενο από πολλά `Select` ή `Where` τελεστές.


**Παράσταση λάμδα LINQ**

    input.Select(family=>family.parents[0])
        .Where(familyName == "Smith");

**SQL**

    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"



**Παράσταση λάμδα LINQ**

    input.Where(family => family.children[0].grade > 3)
        .Select(family => family.parents[0].familyName);

**SQL** 

    SELECT VALUE f.parents[0].familyName
    FROM Families f
    WHERE f.children[0].grade > 3



**Παράσταση λάμδα LINQ**

    input.Select(family => new { grade=family.children[0].grade}).
        Where(anon=> anon.grade < 3);
            
**SQL** 

    SELECT *
    FROM Families f
    WHERE ({grade: f.children[0].grade}.grade > 3)



**Παράσταση λάμδα LINQ**

    input.SelectMany(family => family.parents)
        .Where(parent => parents.familyName == "Smith");

**SQL** 

    SELECT *
    FROM p IN Families.parents
    WHERE p.familyName = "Smith"



#### <a name="nesting"></a>Ένθεση

Η σύνταξη είναι `input.SelectMany(x=>x.Q())` πού βρίσκεται η ερωτήσεις μια `Select`, `SelectMany`, ή `Where` τελεστή.

Σε ένα ενσωματωμένο ερώτημα, το εσωτερικό ερώτημα εφαρμόζεται σε κάθε στοιχείο της συλλογής εξωτερικός. Ένα σημαντικό χαρακτηριστικό είναι ότι το εσωτερικό ερώτημα μπορεί να αναφέρεται σε τα πεδία από τα στοιχεία στη συλλογή του εξωτερικού όπως ιδιο-σύνδεσμοι.

**Παράσταση λάμδα LINQ**

    input.SelectMany(family=> 
        family.parents.Select(p => p.familyName));

**SQL** 

    SELECT VALUE p.familyName
    FROM Families f
    JOIN p IN f.parents


**Παράσταση λάμδα LINQ**

    input.SelectMany(family => 
        family.children.Where(child => child.familyName == "Jeff"));
            
**SQL** 

    SELECT *
    FROM Families f
    JOIN c IN f.children
    WHERE c.familyName = "Jeff"



**Παράσταση λάμδα LINQ**
            
    input.SelectMany(family => family.children.Where(
        child => child.familyName == family.parents[0].familyName));

**SQL** 

    SELECT *
    FROM Families f
    JOIN c IN f.children
    WHERE c.familyName = f.parents[0].familyName


## <a name="executing-sql-queries"></a>Εκτέλεση ερωτήματα SQL
DocumentDB εκθέτει πόρους μέσω ενός REST API που μπορεί να καλείται από οποιαδήποτε γλώσσα που είναι σε θέση να λαμβάνει αιτήσεις HTTP/HTTPS. Επιπλέον, DocumentDB προσφέρει προγραμματισμού βιβλιοθηκών για πολλές δημοφιλείς γλώσσες όπως .NET, Node.js, JavaScript και Python. Το REST API τις διάφορες βιβλιοθήκες όλα υποστήριξη και υποβολή ερωτημάτων μέσω SQL. Το .NET SDK υποστηρίζει LINQ υποβολή ερωτημάτων εκτός από SQL.

Τα παρακάτω παραδείγματα δείχνουν πώς μπορείτε να δημιουργήσετε ένα ερώτημα και να υποβάλετε σε σχέση με ένα λογαριασμό DocumentDB βάσης δεδομένων.

### <a name="rest-api"></a>REST API
DocumentDB προσφέρει μια ανοιχτή RESTful μοντέλο προγραμματισμού μέσω HTTP. Λογαριασμοί βάσης δεδομένων να μπορεί να παρασχεθεί χρησιμοποιώντας μια συνδρομή του Azure. Το μοντέλο πόρων DocumentDB αποτελείται από ένα σύνολα πόρους στην περιοχή λογαριασμός μια βάση δεδομένων, καθένα από τα οποία είναι μπορούν να χρησιμοποιηθούν με ένα URI λογική και είναι σταθερό. Ένα σύνολο πόρων αναφέρεται ως τροφοδοσία σε αυτό το έγγραφο. Ένα λογαριασμό της βάσης δεδομένων που αποτελείται από ένα σύνολο των βάσεων δεδομένων, κάθε μία που περιέχει πολλές συλλογές, κάθε μία από ποια στο-Ενεργοποίηση περιέχει έγγραφα, UDF και άλλους τύπους πόρων.

Το μοντέλο βασική αλληλεπίδραση με αυτούς τους πόρους είναι μέσω τα ρήματα HTTP GET, ΘΈΣΗ, ΔΗΜΟΣΊΕΥΣΗ και ΔΙΑΓΡΑΦΉ με τυπική ερμηνεία τους. Η ΔΗΜΟΣΊΕΥΣΗ Ρηματικές χρησιμοποιείται για τη δημιουργία ενός νέου πόρου, για την εκτέλεση μιας αποθηκευμένης διαδικασίας ή για την έκδοση ενός ερωτήματος DocumentDB. Ερωτήματα διαβάζονται πάντα μόνο λειτουργίες με χωρίς εφέ πλευρά.

Στα παρακάτω παραδείγματα παρουσιάζεται μια ΔΗΜΟΣΊΕΥΣΗ για DocumentDB ερώτημα που έχει τεθεί σε σχέση με μια συλλογή που περιέχει τα δύο έγγραφα δείγμα μας αναθεώρηση μέχρι στιγμής. Το ερώτημα έχει ένα απλό φίλτρο την ιδιότητα name JSON. Σημειώστε τη χρήση του `x-ms-documentdb-isquery` και τύπου περιεχομένου: `application/query+json` κεφαλίδες για να δηλώσετε ότι η λειτουργία είναι ένα ερώτημα.


**Αίτηση**

    POST https://<REST URI>/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/query+json

    {      
        "query": "SELECT * FROM Families f WHERE f.id = @familyId",     
        "parameters": [          
            {"name": "@familyId", "value": "AndersenFamily"}         
        ] 
    }
    

**Αποτελέσματα**

    HTTP/1.1 200 Ok
    x-ms-activity-id: 8b4678fa-a947-47d3-8dd3-549a40da6eed
    x-ms-item-count: 1
    x-ms-request-charge: 0.32
    
    <indented for readability, results highlighted>
    
    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "id":"AndersenFamily",
             "lastName":"Andersen",
             "parents":[  
                {  
                   "firstName":"Thomas"
                },
                {  
                   "firstName":"Mary Kay"
                }
             ],
             "children":[  
                {  
                   "firstName":"Henriette Thaulow",
                   "gender":"female",
                   "grade":5,
                   "pets":[  
                      {  
                         "givenName":"Fluffy"
                      }
                   ]
                }
             ],
             "address":{  
                "state":"WA",
                "county":"King",
                "city":"seattle"
             },
             "_rid":"u1NXANcKogEcAAAAAAAAAA==",
             "_ts":1407691744,
             "_self":"dbs\/u1NXAA==\/colls\/u1NXANcKogE=\/docs\/u1NXANcKogEcAAAAAAAAAA==\/",
             "_etag":"00002b00-0000-0000-0000-53e7abe00000",
             "_attachments":"_attachments\/"
          }
       ],
       "count":1
    }


Το δεύτερο παράδειγμα δείχνει ένα πιο σύνθετο ερώτημα που επιστρέφει πολλά αποτελέσματα από τη συμμετοχή.

**Αίτηση**

    POST https://<REST URI>/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/query+json
    
    {      
        "query": "SELECT 
                     f.id AS familyName, 
                     c.givenName AS childGivenName, 
                     c.firstName AS childFirstName, 
                     p.givenName AS petName 
                  FROM Families f 
                  JOIN c IN f.children 
                  JOIN p in c.pets",     
        "parameters": [] 
    }


**Αποτελέσματα**

    HTTP/1.1 200 Ok
    x-ms-activity-id: 568f34e3-5695-44d3-9b7d-62f8b83e509d
    x-ms-item-count: 1
    x-ms-request-charge: 7.84
    
    <indented for readability, results highlighted>
    
    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "familyName":"AndersenFamily",
             "childFirstName":"Henriette Thaulow",
             "petName":"Fluffy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Goofy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Shadow"
          }
       ],
       "count":3
    }


Εάν δεν μπορεί να χωρέσει αποτελέσματα ενός ερωτήματος μέσα σε μια μεμονωμένη σελίδα αποτελεσμάτων και, στη συνέχεια, το REST API επιστρέφει ένα διακριτικό συνέχισης έως το `x-ms-continuation-token` κεφαλίδας απόκρισης. Προγράμματα-πελάτες μπορούν να μεταβείτε αποτελέσματα, συμπεριλαμβανομένης της κεφαλίδας σε επόμενες αποτελέσματα. Τον αριθμό των αποτελεσμάτων ανά σελίδα μπορεί επίσης να ελέγχεται μέσω του `x-ms-max-item-count` αριθμού κεφαλίδας.

Για να διαχειριστείτε την πολιτική της συνέπειας δεδομένων για τα ερωτήματα, χρησιμοποιήστε το `x-ms-consistency-level` κεφαλίδα όπως όλες τις αιτήσεις REST API. Για την περίοδο λειτουργίας συνέπεια, απαιτείται να echo επίσης τις πιο πρόσφατες `x-ms-session-token` κεφαλίδα Cookie στην πρόσκληση σε ερώτημα. Σημειώστε ότι τη συλλογή ερωτήματος δημιουργίας ευρετηρίου πολιτικής επίσης να επηρεάσετε τη συνέπεια των αποτελεσμάτων του ερωτήματος. Με τις προεπιλεγμένες ρυθμίσεις πολιτικής ευρετηρίου για συλλογές το ευρετήριο είναι πάντα τρέχουσα με τα περιεχόμενα του εγγράφου και αποτελέσματα του ερωτήματος θα ταιριάζουν με τη συνέπεια επιλέξει για τα δεδομένα. Εάν η πολιτική δημιουργίας ευρετηρίου είναι υπάρξουν να αργό, στη συνέχεια, ερωτήματα μπορεί να επιστρέψει μη ενημερωμένες αποτελέσματα. Για περισσότερες πληροφορίες, ανατρέξτε στα [Επίπεδα συνέπειας DocumentDB] [consistency-levels].

Εάν η ρύθμιση παραμέτρων δημιουργίας ευρετηρίου πολιτική στη συλλογή δεν υποστηρίζει το καθορισμένο ερώτημα, ο διακομιστής DocumentDB επιστρέφει 400 "Ακατάλληλη αίτηση". Επιστρέφεται για ερωτήματα περιοχής σε σχέση με διαδρομές έχει ρυθμιστεί για αναζητήσεις κατακερματισμός (ισότητας) και για διαδρομές ρητά εξαιρούνται από το ευρετήριο. Το `x-ms-documentdb-query-enable-scan` κεφαλίδα μπορεί να καθοριστεί για να επιτρέψετε στο ερώτημα για να εκτελέσετε μια σάρωση όταν ένα ευρετήριο δεν είναι διαθέσιμη.

### <a name="c-net-sdk"></a>SDK C# (.NET)
Το .NET SDK υποστηρίζει LINQ και SQL υποβολή ερωτημάτων. Το παρακάτω παράδειγμα δείχνει πώς μπορείτε να εκτελέσετε το ερώτημα απλό φίλτρο που έχουν εισαχθεί προηγουμένως σε αυτό το έγγραφο.


    foreach (var family in client.CreateDocumentQuery(collectionLink, 
        "SELECT * FROM Families f WHERE f.id = \"AndersenFamily\""))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }
    
    SqlQuerySpec query = new SqlQuerySpec("SELECT * FROM Families f WHERE f.id = @familyId");
    query.Parameters = new SqlParameterCollection();
    query.Parameters.Add(new SqlParameter("@familyId", "AndersenFamily"));

    foreach (var family in client.CreateDocumentQuery(collectionLink, query))
    {
        Console.WriteLine("\tRead {0} from parameterized SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery(collectionLink)
        where f.Id == "AndersenFamily"
        select f))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }
    
    foreach (var family in client.CreateDocumentQuery(collectionLink)
        .Where(f => f.Id == "AndersenFamily")
        .Select(f => f))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }


Αυτό το δείγμα συγκρίνει δύο ιδιότητες για ισότητας μέσα σε κάθε έγγραφο και χρησιμοποιεί ανώνυμη προβλέψεις. 


    foreach (var family in client.CreateDocumentQuery(collectionLink,
        @"SELECT {""Name"": f.id, ""City"":f.address.city} AS Family 
        FROM Families f 
        WHERE f.address.city = f.address.state"))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }
    
    foreach (var family in (
        from f in client.CreateDocumentQuery<Family>(collectionLink)
        where f.address.city == f.address.state
        select new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }
    
    foreach (var family in
        client.CreateDocumentQuery<Family>(collectionLink)
        .Where(f => f.address.city == f.address.state)
        .Select(f => new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }


Το Επόμενο δείγμα εμφανίζει συνδέσμους, εκφρασμένη σε LINQ SelectMany.


    foreach (var pet in client.CreateDocumentQuery(collectionLink,
          @"SELECT p
            FROM Families f 
                 JOIN c IN f.children 
                 JOIN p in c.pets 
            WHERE p.givenName = ""Shadow"""))
    {
        Console.WriteLine("\tRead {0} from SQL", pet);
    }
    
    // Equivalent in Lambda expressions
    foreach (var pet in
        client.CreateDocumentQuery<Family>(collectionLink)
        .SelectMany(f => f.children)
        .SelectMany(c => c.pets)
        .Where(p => p.givenName == "Shadow"))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", pet);
    }



Το πρόγραμμα-πελάτη .NET επαναλαμβάνεται αυτόματα σε όλες τις σελίδες των αποτελεσμάτων του ερωτήματος στο τα μπλοκ foreach όπως φαίνεται παραπάνω. Οι επιλογές ερωτήματος που έχουν εισαχθεί στην ενότητα REST API είναι επίσης διαθέσιμες το .NET SDK χρησιμοποιώντας το `FeedOptions` και `FeedResponse` κλάσεων στη μέθοδο CreateDocumentQuery. Τον αριθμό των σελίδων είναι δυνατό να ελέγχεται με χρήση του `MaxItemCount` τη ρύθμιση. 

Μπορείτε να ελέγξετε επίσης ρητά σελιδοποίησης με τη δημιουργία `IDocumentQueryable` χρησιμοποιώντας το `IQueryable` αντικείμενο και, στη συνέχεια, διαβάζοντας το` ResponseContinuationToken` τιμές και τις μεταβιβάσουν ξανά ως `RequestContinuationToken` στο `FeedOptions`. `EnableScanInQuery`μπορεί να οριστεί σε Ενεργοποίηση σαρώνει όταν το ερώτημα δεν υποστηρίζονται από την πολιτική ρύθμιση παραμέτρων δημιουργίας ευρετηρίου. Για τις συλλογές διαμερίσματα, μπορείτε να χρησιμοποιήσετε `PartitionKey` για να εκτελέσετε το ερώτημα σε σχέση με ένα μόνο διαμερισμάτων (αν και DocumentDB αυτόματα να εξαγάγετε αυτό από το κείμενο του ερωτήματος), και `EnableCrossPartitionQuery` για να εκτελέσετε ερωτήματα που μπορεί να χρειαστεί να εκτελεστεί σε περισσότερα από ένα διαμερίσματα. 

Ανατρέξτε [DocumentDB .NET δείγματα](https://github.com/Azure/azure-documentdb-net) για περισσότερα δείγματα που περιέχει τα ερωτήματα. 

### <a name="javascript-server-side-api"></a>API διακομιστή JavaScript 
DocumentDB παρέχει ένα μοντέλο προγραμματισμού για την εκτέλεση JavaScript βάσει λογική εφαρμογής απευθείας σε των συλλογών με αποθηκευμένες διαδικασίες και εναύσματα. Η λογική JavaScript που έχουν καταχωρηθεί σε επίπεδο συλλογής, στη συνέχεια, να εκδώσετε λειτουργίες της βάσης δεδομένων στην τις λειτουργίες στα έγγραφα της δεδομένης συλλογής. Αυτές οι λειτουργίες περικλείονται σε περιβάλλοντος ΟΞΈΟΣ συναλλαγές.

Το παρακάτω παράδειγμα δείχνουν πώς μπορείτε να χρησιμοποιήσετε το queryDocuments στο διακομιστή JavaScript API ώστε ερωτήματα από το εσωτερικό αποθηκευμένες διαδικασίες και εναύσματα.


    function businessLogic(name, author) {
        var context = getContext();
        var collectionManager = context.getCollection();
        var collectionLink = collectionManager.getSelfLink()
    
        // create a new document.
        collectionManager.createDocument(collectionLink,
            { name: name, author: author },
            function (err, documentCreated) {
                if (err) throw new Error(err.message);
    
                // filter documents by author
                var filterQuery = "SELECT * from root r WHERE r.author = 'George R.'";
                collectionManager.queryDocuments(collectionLink,
                    filterQuery,
                    function (err, matchingDocuments) {
                        if (err) throw new Error(err.message);
    context.getResponse().setBody(matchingDocuments.length);
    
                        // Replace the author name for all documents that satisfied the query.
                        for (var i = 0; i < matchingDocuments.length; i++) {
                            matchingDocuments[i].author = "George R. R. Martin";
                            // we don't need to execute a callback because they are in parallel
                            collectionManager.replaceDocument(matchingDocuments[i]._self,
                                matchingDocuments[i]);
                        }
                    })
            });
    }

## <a name="aggregate-functions"></a>Συναρτήσεις συγκεντρωτικών αποτελεσμάτων

Εγγενή υποστήριξη για συναρτήσεις συγκεντρωτικών αποτελεσμάτων που βρίσκεται σε εξέλιξη, αλλά εάν χρειάζεστε πλήθος ή άθροισμα λειτουργικότητα στο μεταξύ, μπορείτε να επιτύχετε το ίδιο αποτέλεσμα με διαφορετικές μεθόδους.  

Στη διαδρομή ανάγνωσης:

- Μπορείτε να εκτελέσετε συναρτήσεις συγκεντρωτικών αποτελεσμάτων από την ανάκτηση των δεδομένων και κάνοντας ένα πλήθος τοπικά. Το περιλαμβάνει συνιστάται να χρησιμοποιήσετε μια προβολή φτηνά ερωτήματος όπως `SELECT VALUE 1` και όχι ολόκληρο το έγγραφο όπως `SELECT * FROM c`. Αυτό σας βοηθά να μεγιστοποιήσετε τον αριθμό των εγγράφων που υποβάλλονται σε επεξεργασία σε κάθε σελίδα των αποτελεσμάτων, συνεπώς αποφυγή πρόσθετων επικοινωνία με την υπηρεσία, εάν είναι απαραίτητο.
- Μπορείτε επίσης να χρησιμοποιήσετε μια αποθηκευμένη διαδικασία για να ελαχιστοποιήσετε την αδράνεια δικτύου σε επαναλαμβανόμενες μεταβάσεις. Για ένα δείγμα αποθηκευμένη διαδικασία που υπολογίζει το πλήθος για ένα ερώτημα που δίνεται φίλτρου, ανατρέξτε στο θέμα [Count.js](https://github.com/Azure/azure-documentdb-js-server/blob/master/samples/stored-procedures/Count.js). Την αποθηκευμένη διαδικασία να επιτρέψετε στους χρήστες να συνδυάσετε εμπλουτισμένου επιχειρηματικής λογικής μαζί με κάνοντας συναθροίσεις με αποτελεσματικό τρόπο.

Στη διαδρομή εγγραφής:

- Ένα άλλο κοινό μοτίβο είναι να προ-συγκέντρωση των αποτελεσμάτων της διαδρομής "Εγγραφή". Αυτό είναι ιδιαίτερα ελκυστική όταν η ένταση των αιτήσεων "ανάγνωση" είναι υψηλότερα από αυτά των αιτήσεων "σύνταξη". Μία φορά προ-συγκεντρωτική, τα αποτελέσματα είναι διαθέσιμες με ένα μόνο σημείο αίτησης ανάγνωσης.  Είναι ο καλύτερος τρόπος για να προ-συγκεντρώσετε στο DocumentDB για να ρυθμίσετε ένα έναυσμα που ενεργοποιείται με κάθε "Εγγραφή" και να ενημερώσετε ένα έγγραφο μετα-δεδομένων που περιλαμβάνει τα πιο πρόσφατα αποτελέσματα για το ερώτημα που να πραγματοποιείται. Για παράδειγμα, ανατρέξτε στα το δείγμα [UpdateaMetadata.js](https://github.com/Azure/azure-documentdb-js-server/blob/master/samples/triggers/UpdateMetadata.js) , το οποίο ενημερώνει το minSize maxSize και totalSize του εγγράφου μετα-δεδομένων για τη συλλογή. Το δείγμα μπορεί να επεκταθεί για να ενημερώσετε μια αντιπρόταση, sum, κ.λπ.

##<a name="references"></a>Αναφορές
1.  [Εισαγωγή στις Azure DocumentDB][introduction]
2.  [Προδιαγραφή DocumentDB SQL](http://go.microsoft.com/fwlink/p/?LinkID=510612)
3.  [Δείγματα DocumentDB .NET](https://github.com/Azure/azure-documentdb-net)
4.  [Επίπεδα συνέπειας DocumentDB][consistency-levels]
5.  ANSI SQL 2011 [http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681)
6.  JSON [http://json.org/](http://json.org/)
7.  Προδιαγραφή JavaScript [http://www.ecma-international.org/publications/standards/Ecma-262.htm](http://www.ecma-international.org/publications/standards/Ecma-262.htm) 
8.  LINQ [http://msdn.microsoft.com/library/bb308959.aspx](http://msdn.microsoft.com/library/bb308959.aspx) 
9.  Ερώτημα αξιολόγησης τεχνικές για μεγάλες βάσεις δεδομένων [http://dl.acm.org/citation.cfm?id=152611](http://dl.acm.org/citation.cfm?id=152611)
10. Επεξεργασία σε συστήματα παράλληλες σχεσιακή βάση δεδομένων, πατήστε το πλήκτρο ένωση IEEE υπολογιστή, 1994 ερωτήματος
11. Tan lu, Ooi, ερωτήματος επεξεργασίας σε συστήματα παράλληλες σχεσιακή βάση δεδομένων, πατήστε το πλήκτρο ένωση IEEE υπολογιστή, 1994.
12. Christopher Olston, Benjamin διαβάζω, Utkarsh Srivastava, Kumar Ravi, Ανδρέας Tomkins: γουρούνι Λατινικά: μια δεν-έτσι-ξένων γλωσσών για επεξεργασία δεδομένων SIGMOD 2008.
13.     Ζ. Graefe. Το πλαίσιο διαδοχής για βελτιστοποίηση ερωτήματος. Eng. IEEE δεδομένων Bull., 18 παράγραφος 3: 1995.


[1]: ./media/documentdb-sql-query/sql-query1.png
[introduction]: documentdb-introduction.md
[consistency-levels]: documentdb-consistency-levels.md
 
