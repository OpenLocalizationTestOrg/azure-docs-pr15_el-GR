<properties
   pageTitle="Χειρισμός πληκτρολογήστε λογικής εφαρμογές περιεχομένου | Microsoft Azure"
   description="Κατανόηση πώς οι εφαρμογές λογικής ασχολείται με τύποι περιεχομένου στη σχεδίαση και χρόνου εκτέλεσης"
   services="logic-apps"
   documentationCenter=".net,nodejs,java"
   authors="jeffhollan"
   manager="dwrede"
   editor=""/>

<tags
   ms.service="logic-apps"
   ms.devlang="multiple"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="integration"
   ms.date="10/18/2016"
   ms.author="jehollan"/>

# <a name="logic-apps-content-type-handling"></a>Χειρισμός πληκτρολογήστε λογικής εφαρμογές περιεχομένου

Υπάρχουν πολλοί διαφορετικοί τύποι περιεχομένου που μπορούν να ροής σε μια εφαρμογή της λογικής - συμπεριλαμβανομένων JSON, XML, απλά αρχεία και δυαδικά δεδομένα.  Ενώ όλα τύποι περιεχομένου που υποστηρίζονται, ορισμένες εγγενώς είναι κατανοητή από το μηχανισμό εφαρμογές λογικής και άλλους μπορεί να απαιτεί χύτευσης ή τις μετατροπές όπως απαιτείται.  Το ακόλουθο άρθρο περιγράφεται ο τρόπος ο μηχανισμός χειρισμού διαφορετικό τύποι περιεχομένου και πώς αυτές σωστά αντιμετώπισης σύμφωνα με τις ανάγκες.

## <a name="content-type-header"></a>Κεφαλίδα τύπου περιεχομένου

Για να ξεκινήσετε μια απλή, ας δούμε τις δύο `Content-Types` που δεν απαιτούν οποιαδήποτε μετατροπής ή μετατροπή σε χρήση μέσα σε μια εφαρμογή λογικής - `application/json` και `text/plain`.

### <a name="applicationjson"></a>Εφαρμογή/json

Ο μηχανισμός ροής εργασίας που βασίζεται σε το `Content-Type` κεφαλίδα από HTTP σε κλήσεις για τον προσδιορισμό του χειρισμού κατάλληλο.  Οποιαδήποτε αίτηση με τον τύπο περιεχομένου `application/json` θα αποθηκευτεί και χειρισμού ως αντικείμενο JSON.  Επιπλέον, JSON περιεχομένου μπορούν να αναλυθούν από προεπιλογή χωρίς να χρειάζεται οποιαδήποτε χύτευσης.  Επομένως, μια πρόσκληση που περιλαμβάνει την κεφαλίδα τύπου περιεχομένου `application/json ` ως εξής:

```
{
    "data": "a",
    "foo": [
        "bar"
    ]
}
```

μπορεί να αναλυθεί σε μια ροή εργασίας με μια παράσταση όπως `@body('myAction')['foo'][0]` για να λάβετε μια τιμή (σε αυτήν την περίπτωση, `bar`).  Δεν χρειάζεται καμία επιπλέον χύτευσης.  Εάν εργάζεστε με τα δεδομένα που είναι JSON, αλλά δεν έχει μια κεφαλίδα που καθορίζονται, μπορείτε να με μη αυτόματο τρόπο μετατραπεί το σε JSON χρησιμοποιώντας το `@json()` συνάρτηση (για παράδειγμα: `@json(triggerBody())['foo']`).

### <a name="textplain"></a>Κείμενο/απλό

Παρόμοια με `application/json`, μηνύματα HTTP που λαμβάνονται με την `Content-Type` κεφαλίδα του `text/plain` θα αποθηκευτούν σε καθαρή μορφή του.  Επιπλέον, εάν περιλαμβάνεται σε μια επόμενες ενέργειες χωρίς οποιαδήποτε χύτευσης την αίτηση θα αποσταλεί με ένα `Content-Type`: `text/plain` κεφαλίδα.  Για παράδειγμα, αν εργάζεστε με ένα επίπεδο αρχείο ενδέχεται να εμφανιστεί το παρακάτω περιεχόμενο HTTP:

```
Date,Name,Address
Oct-1,Frank,123 Ave.
```

as `text/plain`.  Εάν στην επόμενη ενέργεια που έστειλε ως σώμα της πρόσκλησης σε άλλη (`@body('flatfile')`), η αίτηση θα έχει μια `text/plain` επικεφαλίδα τύπου περιεχομένου.  Εάν εργάζεστε με τα δεδομένα που είναι απλού κειμένου, αλλά δεν έχει μια κεφαλίδα που καθορίζονται, μπορείτε να με μη αυτόματο τρόπο απόκλιση του με τη χρήση του κειμένου του `@string()` συνάρτηση (για παράδειγμα: `@string(triggerBody())`)

### <a name="applicationxml-and-applicationoctet-stream-and-converter-functions"></a>Εφαρμογή/xml και εφαρμογή/οκτάδα-ροή και συναρτήσεις μετατροπέα

Ο μηχανισμός εφαρμογή λογικής πάντα θα διατηρηθούν τα `Content-Type` που παραλήφθηκε στην αίτηση HTTP ή απόκριση.  Τι σημαίνει αυτό είναι όταν μια περιεχόμενο λαμβάνεται με `Content-Type` του `application/octet-stream`, συμπεριλαμβανομένων των που σε μια ενέργεια οι επόμενες με χύτευσης δεν θα έχει ως αποτέλεσμα μιας εξερχόμενης αίτησης με `Content-Type`: `application/octet-stream`.  Με αυτόν τον τρόπο ο μηχανισμός να guaruntee δεδομένα δεν θα χαθούν καθώς μετακινείται σε ολόκληρη τη ροή εργασίας.  Ωστόσο, η κατάσταση ενέργειας (εισροές και εκροές) είναι αποθηκευμένες σε ένα αντικείμενο JSON ως κείμενο να ρέει σε ολόκληρη τη ροή εργασίας.  Αυτό σημαίνει ότι για να διατηρήσει ορισμένοι τύποι δεδομένων, ο μηχανισμός θα μετατροπή του περιεχομένου σε μια συμβολοσειρά δυαδικό κωδικοποίηση base64 με κατάλληλο μετα-δεδομένων που διατηρεί και τα δύο `$content` και `$content-type` -που θα μετατραπεί αυτόματα.  Μπορείτε να μετατρέψετε επίσης με μη αυτόματο τρόπο μεταξύ τύποι περιεχομένου χρησιμοποιώντας ενσωματωμένες συναρτήσεις μετατροπέα:

* `@json()`-Μετατρέπει ρητά δεδομένων σε`application/json`
* `@xml()`-Μετατρέπει ρητά δεδομένων σε`application/xml`
* `@binary()`-Μετατρέπει ρητά δεδομένων σε`application/octet-stream`
* `@string()`-Μετατρέπει ρητά δεδομένων σε`text/plain`
* `@base64()`-Μετατρέπει το περιεχόμενο σε μια συμβολοσειρά base64
* `@base64toString()`-Μετατρέπει μια συμβολοσειρά κωδικοποίηση base64 σε`text/plain`
* `@base64toBinary()`-Μετατρέπει μια συμβολοσειρά κωδικοποίηση base64 σε`application/octet-stream`
* `@encodeDataUri()`-κωδικοποιεί μια συμβολοσειρά ως πίνακας byte dataUri
* `@decodeDataUri()`-αποκωδικοποιεί μια dataUri σε έναν πίνακα byte

Για παράδειγμα, εάν έχετε λάβει μια αίτηση HTTP με `Content-Type`: `application/xml` του:

```
<?xml version="1.0" encoding="UTF-8" ?>
<CustomerName>Frank</CustomerName>
```

Να μπορεί να μετατραπεί και να χρησιμοποιήσετε αργότερα με κάπως `@xml(triggerBody())`, ή μέσα σε μια συνάρτηση, όπως `@xpath(xml(triggerBody()), '/CustomerName')`.

### <a name="other-content-types"></a>Τύποι άλλες περιεχομένου

Άλλους τύπους περιεχομένου που υποστηρίζονται και θα λειτουργούν με μια εφαρμογή λογικής, αλλά μπορεί να απαιτεί να ανακτάτε με μη αυτόματο τρόπο το σώμα του μηνύματος με αποκωδικοποίηση το `$content`.  Για παράδειγμα, εάν να ενεργοποίηση απενεργοποίηση μιας `application/x-www-url-formencoded` αίτηση που μοιάζει με τα εξής:

```
CustomerName=Frank&Address=123+Avenue
```

από αυτό δεν απλού κειμένου ή JSON και θα αποθηκευτεί στην ενέργεια ως:

```
...
"body": {
    "$content-type": "application/x-www-url-formencoded",
    "$content": "AAB1241BACDFA=="
}
```

Όπου `$content` είναι το φορτίο κωδικοποιηθεί ως συμβολοσειρά base64 για να διατηρήσετε όλα τα δεδομένα.  Εφόσον αυτήν τη στιγμή δεν υπάρχει κάποια εγγενή λειτουργία για δεδομένων φόρμας, που θα μπορούσε να χρησιμοποιήσετε αυτά τα δεδομένα σε μια ροή εργασίας, με μη αυτόματο τρόπο την πρόσβαση στα δεδομένα με μια συνάρτηση, όπως `@string(body('formdataAction'))`.  Εάν να αποφασίσατε μου εξερχόμενη αίτηση για να έχουν επίσης το `application/x-www-url-formencoded` κεφαλίδα τύπου περιεχομένου, που θα μπορούσε να Μόλις προσθέσετε στο κυρίως σώμα ενέργειας χωρίς οποιαδήποτε χύτευσης όπως `@body('formdataAction')`.  Ωστόσο, αυτό θα λειτουργεί μόνο εάν το κυρίως κείμενο είναι η παράμετρος μόνο σε το `body` εισόδου.  Εάν προσπαθήσετε να κάνετε `@body('formdataAction')` μέσα από μια `application/json` αίτηση θα εμφανιστεί ένα σφάλμα χρόνου εκτέλεσης όπως θα στείλει κωδικοποιημένο σώμα.
