<properties
   pageTitle="Προσωρινή αποθήκευση καθοδήγηση | Microsoft Azure"
   description="Οδηγίες για προσωρινή αποθήκευση για να βελτιώσετε τις επιδόσεις και κλιμάκωση."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/14/2016"
   ms.author="masashin"/>


# <a name="caching-guidance"></a>Προσωρινή αποθήκευση καθοδήγηση

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

Προσωρινή αποθήκευση είναι μια τεχνική κοινές που στόχος για να βελτιώσετε την απόδοση και κλιμάκωση ενός συστήματος. Αυτό γίνεται με την αντιγραφή προσωρινά συχνά πρόσβαση δεδομένων για γρήγορη χώρου αποθήκευσης που βρίσκεται Κλείσιμο για να την εφαρμογή. Εάν αυτός ο χώρος αποθήκευσης δεδομένων fast βρίσκεται πιο κοντά στην εφαρμογή από το αρχικό αρχείο προέλευσης, στη συνέχεια, σε cache μπορεί να βελτιώσει σημαντικά χρόνους απόκρισης για εφαρμογές προγράμματος-πελάτη λειτουργώντας δεδομένα πιο γρήγορα.

Προσωρινή αποθήκευση είναι πιο αποτελεσματική όταν μια παρουσία του προγράμματος-πελάτη επανειλημμένα διαβάζει τα ίδια δεδομένα, ειδικά εάν ισχύουν όλες οι ακόλουθες συνθήκες στο αρχικό χώρο αποθήκευσης δεδομένων:
- Παραμένει σχετικά στατικά.
- Είναι αργή σε σύγκριση με την ταχύτητα της μνήμης cache.
- Είναι υπόκεινται υψηλού επιπέδου της διένεξης.
- Είναι πολύ μακριά όταν λανθάνων χρόνος δικτύου μπορεί να προκαλέσει την access για να είναι αργή.

## <a name="caching-in-distributed-applications"></a>Προσωρινή αποθήκευση σε κατανεμημένες εφαρμογές

Κατανεμημένες εφαρμογές υλοποίηση συνήθως είτε μία είτε και τις δύο από τις παρακάτω στρατηγικές όταν προσωρινή αποθήκευση δεδομένων:

- Χρήση ενός ιδιωτικού cache, όπου δεδομένων διατηρείται τοπικά στον υπολογιστή που εκτελεί μια παρουσία του μια εφαρμογή ή υπηρεσία.
- Χρήση ενός κοινόχρηστου cache, λειτουργώντας ως ένα κοινό προέλευσης, το οποίο είναι δυνατή η πρόσβαση από πολλές διεργασίες ή/και μηχανές.

Και στις δύο περιπτώσεις, σε cache μπορεί να πραγματοποιηθεί πλευρά του προγράμματος-πελάτη ή/και του διακομιστή. Προσωρινή αποθήκευση πλευρά του προγράμματος-πελάτη γίνεται με τη διαδικασία που παρέχει το περιβάλλον εργασίας χρήστη για ένα σύστημα, όπως ένα πρόγραμμα περιήγησης στο web ή την εφαρμογή υπολογιστή.
Προσωρινή αποθήκευση διακομιστή γίνεται με τη διαδικασία που παρέχει τις υπηρεσίες επιχειρήσεις που εκτελούνται από απόσταση.

### <a name="private-caching"></a>Ιδιωτική σε cache

Ο πιο βασικός τύπος cache είναι ένα χώρο αποθήκευσης στη μνήμη. Έχει αναμονή στο χώρο διεύθυνσης της μια απλή διαδικασία και πρόσβαση απευθείας από τον κώδικα που εκτελείται αυτής της διεργασίας. Αυτός ο τύπος της μνήμης cache είναι πολύ σύντομο για να αποκτήσετε πρόσβαση. Μπορεί επίσης να παρέχει ένα πολύ αποτελεσματικό μέσο για την αποθήκευση μέτρια ποσότητες στατική δεδομένων, επειδή το μέγεθος του cache συνήθως περιορίζεται από τον όγκο των μνήμης που είναι διαθέσιμη στον υπολογιστή που φιλοξενεί τη διαδικασία.

Εάν πρέπει να περισσότερες πληροφορίες από φυσικά πιθανές στη μνήμη cache, μπορείτε να συντάξετε δεδομένα στο cache για το τοπικό σύστημα αρχείων. Αυτό θα είναι πιο αργά για να αποκτήσετε πρόσβαση από δεδομένα που διατηρείται στη μνήμη, αλλά θα πρέπει να εξακολουθεί να είναι γρηγορότερο και πιο αξιόπιστο από την ανάκτηση δεδομένων σε ένα δίκτυο.

Εάν έχετε πολλές παρουσίες μιας εφαρμογής που χρησιμοποιεί αυτό το μοντέλο εκτελείται ταυτόχρονα, κάθε παρουσία της εφαρμογής διαθέτει δικό του cache ανεξάρτητη κρατώντας πατημένο το δικό του αντίγραφο των δεδομένων.

Θεωρήστε ότι ένα cache ως ένα στιγμιότυπο των αρχικών δεδομένων σε κάποιο σημείο στο παρελθόν. Εάν τα δεδομένα δεν είναι στατική, είναι πιθανό ότι παρουσιών της εφαρμογής διαφορετικά κρατήστε πατημένο το πλήκτρο διαφορετικές εκδόσεις των δεδομένων σε τους μνήμης cache. Επομένως, το ίδιο ερώτημα που έχει εκτελεστεί από αυτές τις περιπτώσεις μπορεί να επιστρέψει διαφορετικά αποτελέσματα, όπως φαίνεται στην εικόνα 1.

![Χρησιμοποιώντας ένα στη μνήμη cache σε διαφορετικές παρουσίες μιας εφαρμογής](media/best-practices-caching/Figure1.png)

_Εικόνα 1: Χρήση μιας στη μνήμη cache στο διαφορετικές παρουσίες μιας εφαρμογής_

### <a name="shared-caching"></a>Κοινή χρήση σε cache

Χρήση ενός κοινόχρηστου cache μπορεί να σας βοηθήσει να επιλύσουν τα προβλήματα που ενδέχεται να διαφέρουν δεδομένων σε κάθε cache, η οποία μπορεί να προκύψει με σε στη μνήμη cache. Κοινόχρηστο σε cache εξασφαλίζει ότι παρουσίες διαφορετική εφαρμογή, ανατρέξτε στην ίδια προβολή των δεδομένων στο cache. Αυτό γίνεται με τον εντοπισμό του cache σε διαφορετική θέση, συνήθως φιλοξενούνται ως μέρος μια ξεχωριστή υπηρεσία, όπως φαίνεται στην εικόνα 2.

![Χρήση ενός κοινόχρηστου cache](media/best-practices-caching/Figure2.png)

_Εικόνα 2: Χρήση ενός κοινόχρηστου cache_

Ένα σημαντικό πλεονέκτημα της η κοινόχρηστη σε cache προσέγγιση είναι η κλιμάκωση παρέχει. Πολλές υπηρεσίες κοινόχρηστο cache σχετικά με την εφαρμογή, χρησιμοποιώντας ένα σύμπλεγμα διακομιστών, και να χρησιμοποιούν λογισμικό που κατανέμει τα δεδομένα του συμπλέγματος με διαφανή τρόπο. Μια παρουσία της εφαρμογής απλώς αποστέλλει μια αίτηση για την υπηρεσία cache.
Το υποκείμενο υποδομής είναι υπεύθυνος για καθορισμού της θέσης των τα δεδομένα στο cache του συμπλέγματος. Μπορείτε εύκολα να κλιμάκωση το cache με την προσθήκη περισσότερων διακομιστών.

Υπάρχουν δύο κύρια μειονεκτήματα της κοινόχρηστο σε cache προσέγγισης:
- Το cache είναι πιο αργά για να αποκτήσετε πρόσβαση, επειδή δεν είναι πλέον είναι διατηρείται τοπικά σε κάθε παρουσία της εφαρμογής.
- Η απαίτηση για την υλοποίηση της υπηρεσίας ξεχωριστή cache μπορεί να προσθέσει πολυπλοκότητα στη λύση.

## <a name="considerations-for-using-caching"></a>Ζητήματα σχετικά με τη χρήση σε cache

Οι παρακάτω ενότητες περιγράφουν με περισσότερες λεπτομέρειες τα ζητήματα σχετικά με τη σχεδίαση και τη χρήση μιας cache.

### <a name="decide-when-to-cache-data"></a>Αποφασίσετε πότε θα προσωρινή αποθήκευση δεδομένων

Προσωρινή αποθήκευση να βελτιώσετε εντυπωσιακά επιδόσεις, την κλιμάκωση και διαθεσιμότητα. Όσο περισσότερα δεδομένα που έχετε και τόσο μεγαλύτερο του αριθμού των χρηστών που πρέπει να έχουν πρόσβαση σε αυτά τα δεδομένα, η μεγαλύτερη τα οφέλη από την προσωρινή αποθήκευση γίνονται. Αυτό συμβαίνει επειδή προσωρινή αποθήκευση μειώνει το λανθάνων χρόνος και ασυμφωνίας που είναι συσχετισμένη με χειρισμός μεγάλους όγκους ταυτόχρονες αιτήσεις στο αρχικό χώρο αποθήκευσης δεδομένων.

Για παράδειγμα, μια βάση δεδομένων μπορεί να υποστηρίζουν περιορισμένο αριθμό ταυτόχρονες συνδέσεις. Ανάκτηση δεδομένων από μια κοινόχρηστη cache, ωστόσο, και όχι η βάση δεδομένων, δίνει τη δυνατότητα για μια εφαρμογή προγράμματος-πελάτη για να αποκτήσετε πρόσβαση σε αυτά τα δεδομένα, ακόμα και εάν ο αριθμός των συνδέσεων διαθέσιμη αυτήν τη στιγμή είναι αποθεμάτων. Επιπλέον, εάν η βάση δεδομένων δεν είναι διαθέσιμη, εφαρμογές προγράμματος-πελάτη ίσως να συνεχίσετε με τη χρήση των δεδομένων που διατηρείται στο cache.

Εξετάστε το ενδεχόμενο προσωρινή αποθήκευση δεδομένων που διαβάζετε τακτικά αλλά τροποποίησης σπάνια (για παράδειγμα, τα δεδομένα που έχουν μεγαλύτερο ποσοστό του λειτουργίες ανάγνωσης από λειτουργίες εγγραφής). Ωστόσο, δεν συνιστάται να χρησιμοποιήσετε το cache ως έγκυρες χώρος αποθήκευσης κρίσιμων πληροφοριών. Αντί για αυτό, βεβαιωθείτε ότι όλες οι αλλαγές που η εφαρμογή σας δεν πρέπει να χάσετε πάντα αποθηκεύονται σε ένα χώρο αποθήκευσης μόνιμη δεδομένων. Αυτό σημαίνει ότι, εάν το cache δεν είναι διαθέσιμο, η εφαρμογή σας εξακολουθούν να μπορούν να συνεχίσει να λειτουργεί με τη χρήση του χώρου αποθήκευσης δεδομένων και να μην χάσετε σημαντικές πληροφορίες.

### <a name="determine-how-to-cache-data-effectively"></a>Καθορίσετε τον τρόπο αποτελεσματική προσωρινή αποθήκευση δεδομένων

Το κλειδί για την αποτελεσματική χρήση ένα cache βρίσκεται στο τον προσδιορισμό των πιο κατάλληλο δεδομένων σε cache και σε cache αυτήν την κατάλληλη ώρα. Μπορείτε να προσθέσετε τα δεδομένα στο cache ζήτηση την πρώτη φορά που ανακτώνται από μια εφαρμογή. Αυτό σημαίνει ότι η εφαρμογή πρέπει να κάνετε λήψη μόνο μία φορά τα δεδομένα από το χώρο αποθήκευσης δεδομένων και ότι η πρόσβαση οι επόμενες μπορεί να πληρούνται χρησιμοποιώντας το cache.

Εναλλακτικά, ένα cache μπορεί να είναι μερικώς ή πλήρως συμπληρωμένο με δεδομένα εκ των προτέρων, συνήθως κατά την εκκίνηση της εφαρμογής (προσέγγισης γνωστό ως καλλιέργεια). Ωστόσο, ενδέχεται να μην είναι χρήσιμο για την υλοποίηση καλλιέργεια για ένα μεγάλο cache, επειδή αυτή η προσέγγιση μπορεί να επιβάλει μια απότομη, υψηλή φόρτωση το αρχικό χώρο αποθήκευσης δεδομένων όταν εκτελεί την εκκίνηση της εφαρμογής.

Συχνά μια ανάλυση των μοτίβων χρήσης μπορούν να σας βοηθήσουν να αποφασίσετε αν θέλετε να πλήρως ή μερικώς συμπληρώσετε εκ των προτέρων ένα cache, και να επιλέξετε τα δεδομένα στο cache. Για παράδειγμα, μπορεί να είναι χρήσιμο να σπείρεται το cache με τα δεδομένα του προφίλ στατική χρήστη για τους πελάτες που χρησιμοποιούν την εφαρμογή τακτικά (ίσως κάθε ημέρα), αλλά όχι για τους πελάτες που χρησιμοποιούν την εφαρμογή μόνο μία φορά την εβδομάδα.

Προσωρινή αποθήκευση συνήθως λειτουργεί καλά με δεδομένα που είναι αμετάβλητες ή που αλλάζει συχνά. Παραδείγματα περιλαμβάνουν πληροφορίες αναφοράς όπως προϊόντος και τις πληροφορίες τιμολόγησης σε μια εφαρμογή ηλεκτρονικού εμπορίου ή κοινόχρηστους πόρους στατική που είναι κοστίζουν για να δημιουργήσετε. Ορισμένα ή όλα αυτά τα δεδομένα μπορεί να μεταφερθεί σε το cache κατά την εκκίνηση εφαρμογής για να ελαχιστοποιήσετε απαιτήσεις σε πόρους και τη βελτίωση της απόδοσης. Μπορεί επίσης να είναι κατάλληλες για να έχετε μια διεργασία φόντου που ενημερώνει περιοδικά αναφοράς δεδομένων στο cache για να βεβαιωθείτε ότι είναι ενημερωμένα ή που ανανεώνει το cache όταν αναφοράς δεδομένων αλλαγές.

Προσωρινή αποθήκευση είναι λιγότερο χρήσιμη για δυναμικά δεδομένα, παρόλο που υπάρχουν μερικές εξαιρέσεις σε αυτό εξέταση (ανατρέξτε στην ενότητα Cache ιδιαίτερα δυναμικά δεδομένα αργότερα σε αυτό το άρθρο για περισσότερες πληροφορίες). Όταν τα αρχικά δεδομένα αλλάζουν συχνά, οι πληροφορίες στο cache γίνονται μη ενημερωμένες πολύ γρήγορα ή επιβάρυνσης το συγχρονισμό του cache με τον αρχικό χώρου αποθήκευσης δεδομένων μειώνει την αποτελεσματικότητα της εγγραφής στο cache.

Σημειώστε ότι δεν διαθέτει ένα cache για να συμπεριλάβετε τα πλήρη δεδομένα για μια οντότητα. Για παράδειγμα, εάν ένα στοιχείο δεδομένων αντιπροσωπεύει ένα αντικείμενο πολλών τιμών όπως έναν πελάτη τράπεζα με όνομα, διεύθυνση και το υπόλοιπο του λογαριασμού, ορισμένα από αυτά τα στοιχεία ενδέχεται να παραμείνει στατικό (όπως το όνομα και τη διεύθυνση), ενώ άλλοι (όπως το υπόλοιπο του λογαριασμού) μπορεί να είναι πιο δυναμική. Σε αυτές τις περιπτώσεις, μπορεί να είναι χρήσιμο να cache τη στατική τμήματα των δεδομένων και να ανακτήσετε (ή τον υπολογισμό) μόνο τις υπόλοιπες πληροφορίες όταν είναι απαραίτητο.

Συνιστάται να διεξάγετε επιδόσεων δοκιμών και η χρήση ανάλυσης για να προσδιορίσετε εάν προ-πληθυσμού ή σε ζήτηση κατά τη φόρτωση του cache ή ένας συνδυασμός των δύο, είναι κατάλληλο. Απόφασης πρέπει να βασίζεται στη μεταβλητότητα και μοτίβο χρήσης των δεδομένων. Cache ανάλυσης χρήσης και επιδόσεων είναι ιδιαίτερα σημαντικό σε εφαρμογές που συναντήσετε χοντρό φορτία και πρέπει να είναι ιδιαίτερα μεταβλητού μεγέθους. Για παράδειγμα, σε ιδιαίτερα μεταβλητού μεγέθους σενάρια μπορεί να έχει νόημα να σπείρεται το cache για να μειώσετε τη φόρτωση στο χώρο αποθήκευσης δεδομένων φορές κορύφωσης.

Προσωρινή αποθήκευση μπορεί επίσης να χρησιμοποιηθεί για να αποφύγετε την επαναλαμβανόμενη υπολογισμούς κατά την εκτέλεση της εφαρμογής. Εάν μια λειτουργία μετατρέπει τα δεδομένα ή εκτελεί μια σύνθετη υπολογισμού, το να αποθηκεύσετε τα αποτελέσματα της λειτουργίας στο cache. Εάν το ίδιο υπολογισμό απαιτείται μετά από αυτό, η εφαρμογή απλώς να ανακτήσετε τα αποτελέσματα από το cache.

Μια εφαρμογή να τροποποιήσετε δεδομένα που είναι διατηρηθούν στο cache. Ωστόσο, συνιστάται να σκέψη της μνήμης cache ως χώρος αποθήκευσης μεταβατικές δεδομένων που μπορεί να εξαφανίζονται οποιαδήποτε στιγμή. Μην αποθηκεύετε πολύτιμο δεδομένα στο cache. Φροντίστε να διατηρείτε τις πληροφορίες στο αρχικό χώρου αποθήκευσης δεδομένων καθώς και. Αυτό σημαίνει ότι, εάν το cache δεν είναι διαθέσιμη, μπορείτε ελαχιστοποιήσετε τις πιθανότητες απώλειας δεδομένων.

### <a name="cache-highly-dynamic-data"></a>Cache ιδιαίτερα δυναμικά δεδομένα

Όταν αποθηκεύετε πληροφορίες γρήγορη αλλαγή σε ένα χώρο αποθήκευσης μόνιμη δεδομένων, αυτό μπορεί να επιβάλει μια επιβάρυνσης στο σύστημα. Για παράδειγμα, εξετάστε το ενδεχόμενο μια συσκευή που συνεχώς αναφορές κατάστασης ή ορισμένες άλλες μέτρησης. Εάν μια εφαρμογή επιλέξει να μην cache αυτών των δεδομένων με την πεποίθηση ότι οι πληροφορίες στο cache σχεδόν πάντα θα μη ενημερωμένων, στη συνέχεια, το ίδιο εξέταση θα μπορούσε να είναι αληθή κατά την αποθήκευση και ανάκτηση αυτές τις πληροφορίες από το χώρο αποθήκευσης δεδομένων. Στο χρονικό διάστημα που χρειάζεται για να αποθηκεύσετε και να κάνετε λήψη αυτών των δεδομένων, ενδέχεται να έχουν αλλάξει.

Σε μια κατάσταση όπως αυτή, μπορείτε να τα οφέλη από την αποθήκευση των πληροφοριών δυναμικής απευθείας στο cache αντί στο χώρο αποθήκευσης μόνιμη δεδομένων. Εάν τα δεδομένα είναι μη κρίσιμη και δεν απαιτεί έλεγχος, στη συνέχεια, δεν έχει σημασία αν η αλλαγή περιστασιακές θα χαθεί.

### <a name="manage-data-expiration-in-a-cache"></a>Διαχείριση λήξης δεδομένων στο cache

Στις περισσότερες περιπτώσεις, τα δεδομένα που διατηρείται σε μνήμη cache είναι ένα αντίγραφο των δεδομένων που παραμένει στην αρχική χώρου αποθήκευσης δεδομένων. Τα δεδομένα στο αρχικό χώρου αποθήκευσης δεδομένων μπορεί να αλλάξει αφού έχει cached, προκαλεί τα δεδομένα στο cache για να γίνετε μη ενημερωμένες. Πολλά συστήματα σε cache σάς επιτρέπουν να ρυθμίσετε τις παραμέτρους του cache για να λήξει δεδομένων και να μειώσετε την περίοδο για την οποία μπορεί να είναι ενημερωμένα δεδομένα.

Όταν λήξει η δεδομένα στο cache, αυτό καταργείται από το cache και την εφαρμογή πρέπει να ανακτήσετε τα δεδομένα από το αρχικό χώρο αποθήκευσης δεδομένων (το να τοποθετήσετε τις πληροφορίες που μόλις ληφθεί πίσω στη μνήμη cache). Μπορείτε να ορίσετε μια προεπιλεγμένη πολιτική λήξης όταν ρυθμίζετε τις παραμέτρους του cache. Σε πολλές υπηρεσίες cache, μπορείτε επίσης να ορίσετε την περίοδο λήξης για μεμονωμένα αντικείμενα όταν τις αποθηκεύετε μέσω προγραμματισμού στο cache.
Ορισμένες μνήμης cache σάς επιτρέπουν να καθορίσετε την περίοδο λήξης ως μια απόλυτη τιμή ή ως μια τιμή ολίσθησης που έχει ως αποτέλεσμα το στοιχείο για να καταργηθούν από το cache, εάν δεν έχει πρόσβαση εντός του καθορισμένου χρονικού διαστήματος. Αυτή η ρύθμιση αντικαθιστά οποιαδήποτε πολιτική λήξης όλο το cache, αλλά μόνο για τα επιλεγμένα αντικείμενα.

> [AZURE.NOTE] Εξετάστε το ενδεχόμενο να την περίοδο λήξης για το cache και τα αντικείμενα που περιέχει προσεκτικά. Εάν κάνετε πολύ σύντομο, αντικείμενα θα λήξει πάρα πολύ γρήγορα και θα μπορείτε να μειώσετε τα οφέλη της χρήσης του cache. Αν κάνετε την περίοδο πολύ χρόνο, υπάρχει κίνδυνος τα δεδομένα πώς να γίνετε μη ενημερωμένες.

Επίσης, είναι πιθανό ότι το cache μπορεί να γεμίσει εάν δεδομένων επιτρέπεται να παραμένουν που υπάρχουν για μεγάλο χρονικό διάστημα. Σε αυτήν την περίπτωση, τυχόν αιτήσεις για να προσθέσετε νέα στοιχεία στο cache ενδέχεται να προκαλέσουν ορισμένα στοιχεία που θα καταργηθούν υποχρεωτικά σε μια διαδικασία γνωστή ως eviction. Υπηρεσίες cache καταργήστε συνήθως δεδομένων με βάση ένα ελάχιστο πρόσφατα χρησιμοποιημένων (LRU), αλλά συνήθως μπορείτε να παρακάμψετε αυτή την πολιτική και να αποτρέψετε που έχει εξαχθεί στοιχείων. Ωστόσο, εάν λάβει αυτήν την προσέγγιση, υπάρχει κίνδυνος ότι έχετε υπερβεί το μνήμης που είναι διαθέσιμη στο cache. Μια εφαρμογή που προσπαθεί να προσθέσετε ένα στοιχείο στο cache θα αποτύχει με μια εξαίρεση.

Ορισμένες εφαρμογές σε cache μπορεί να παρέχουν πρόσθετες eviction πολιτικές. Υπάρχουν διάφοροι τύποι πολιτικών eviction. Περιλαμβάνουν τα εξής:
- Μια πολιτική πιο πρόσφατα χρησιμοποιημένων (σε την προοπτική ότι τα δεδομένα δεν θα είναι απαραίτητη ξανά).
- Μια πολιτική first-σε-first-out (παλαιότερα δεδομένα είναι έχει εξαχθεί πρώτα).
- Μια πολιτική ρητή κατάργησης που βασίζεται σε ένα συμβάν ενεργοποίησης (όπως τα δεδομένα που τροποποιείται).

### <a name="invalidate-data-in-a-client-side-cache"></a>Ακυρώνει δεδομένων σε cache πλευρά του προγράμματος-πελάτη

Δεδομένα που παραμένει στο cache μια πλευρά του προγράμματος-πελάτη είναι γενικά θεωρούνται έξω από την εποπτεία της υπηρεσίας που παρέχει τα δεδομένα στο πρόγραμμα-πελάτη. Μια υπηρεσία δεν είναι δυνατό να επιβάλετε απευθείας ένα πρόγραμμα-πελάτη για να προσθέσετε ή να καταργήσετε στοιχεία από ένα cache πλευρά του προγράμματος-πελάτη.

Αυτό σημαίνει ότι είναι πιθανό για ένα πρόγραμμα-πελάτη που χρησιμοποιεί μια κακή ρύθμιση παραμέτρων cache για να συνεχίσετε να χρησιμοποιείτε μη ενημερωμένων πληροφοριών. Για παράδειγμα, εάν δεν είναι υλοποιήσει σωστά τις πολιτικές λήξης της μνήμης cache, ένα πρόγραμμα-πελάτη μπορεί να χρησιμοποιήσετε μη ενημερωμένων πληροφοριών που είναι προσωρινά αποθηκευμένα τοπικά όταν έχει αλλάξει τις πληροφορίες στην αρχική προέλευση δεδομένων.

Εάν δημιουργείτε μια εφαρμογή web που χρησιμοποιείται δεδομένων μέσω μιας σύνδεσης HTTP, μπορείτε να επιβάλετε ρητά ένα πρόγραμμα-πελάτη web (όπως ένα πρόγραμμα περιήγησης ή διακομιστή μεσολάβησης web) για τη λήψη τις πιο πρόσφατες πληροφορίες. Μπορείτε να κάνετε εάν ένας πόρος είναι ενημερωθεί με μια αλλαγή στο URI αυτού του πόρου. Προγραμμάτων-πελατών Web Χρησιμοποιήστε συνήθως το URI ενός πόρου ως το κλειδί στο cache πλευρά του προγράμματος-πελάτη, έτσι ώστε αν αλλάξει το URI, ο υπολογιστής-πελάτης web παραβλέπει το όρισμα οποιαδήποτε προηγουμένως στο cache εκδόσεις ενός πόρου και να λαμβάνει τη νέα έκδοση αντί για αυτό.

## <a name="managing-concurrency-in-a-cache"></a>Διαχείριση συγχρονισμού σε μνήμη cache

Οι cache συχνά είναι σχεδιασμένες για κοινή χρήση από πολλές παρουσίες μιας εφαρμογής του. Κάθε παρουσία της εφαρμογής να διαβάσετε και να τροποποιήσετε δεδομένα στο cache. Επομένως, τα ίδια προβλήματα συγχρονισμού που προκύπτουν με οποιονδήποτε χώρο αποθήκευσης κοινόχρηστων δεδομένων ισχύουν επίσης για ένα cache. Σε περίπτωση όπου μια εφαρμογή πρέπει να τροποποιήσετε δεδομένα που διατηρείται στο cache, ίσως χρειαστεί να βεβαιωθείτε ότι οι ενημερώσεις που έγιναν από μία παρουσία της εφαρμογής χωρίς αντικατάσταση τις αλλαγές που έγιναν από μια άλλη παρουσία.

Ανάλογα με τη φύση των δεδομένων και την πιθανότητα διενέξεων, που μπορούν να λαμβάνουν μία από δύο μεθόδους για να ταυτόχρονης εκτέλεσης:

- __Αισιόδοξη.__ Αμέσως πριν από την ενημέρωση των δεδομένων, η εφαρμογή ελέγχει αν τα δεδομένα στο cache έχει αλλάξει μετά την ανάκτησή. Εάν τα δεδομένα εξακολουθεί να είναι το ίδιο, μπορεί να γίνει η αλλαγή. Διαφορετικά, η εφαρμογή έχει για να αποφασίσετε αν θέλετε να ενημερώσετε. (Της εταιρικής λογικής που κατευθύνει την παρούσα απόφαση είναι συγκεκριμένη εφαρμογή). Αυτή η προσέγγιση είναι κατάλληλη για περιπτώσεις όπου οι ενημερώσεις είναι σπάνια ή όπου δεν είναι πιθανό να προκύψουν διενέξεις.
- __Απαισιόδοξη.__ Όταν ανακτά τα δεδομένα, η εφαρμογή του κλειδώνει στο cache για να αποτρέψετε την αλλαγή του άλλη παρουσία. Αυτή η διαδικασία εξασφαλίζει ότι δεν προκύπτουν διενέξεις, αλλά αυτά, επίσης, να αποκλείσετε άλλες εμφανίσεις που πρέπει να επεξεργάζονται τα ίδια δεδομένα. Απαισιόδοξη ταυτόχρονης εκτέλεσης μπορεί να επηρεάσει την κλιμάκωση μιας λύσης και συνιστάται μόνο για λειτουργίες μικρής διάρκειας. Αυτή η προσέγγιση μπορεί να είναι κατάλληλες για περιπτώσεις όπου διενέξεις είναι πιο πιθανό, ειδικά εάν μια εφαρμογή ενημερώσεων πολλαπλών στοιχείων στο cache και πρέπει να εξασφαλίσετε ότι αυτές οι αλλαγές θα εφαρμοστούν με συνέπεια.

### <a name="implement-high-availability-and-scalability-and-improve-performance"></a>Υλοποίηση υψηλή διαθεσιμότητα και κλιμάκωση και Βελτιώστε την απόδοση

Αποφύγετε τη χρήση μιας cache ως κύρια αποθετήριο δεδομένων των δεδομένων. Αυτό είναι το ρόλο του αρχικού χώρου αποθήκευσης δεδομένων από την οποία συμπληρώνεται το cache. Το αρχικό χώρο αποθήκευσης δεδομένων είναι υπεύθυνη για τη διασφάλιση τη διατήρηση των δεδομένων.

Προσέξτε να μην προκαλέσει κρίσιμες εξαρτήσεων από τη διαθεσιμότητα μιας υπηρεσίας κοινόχρηστο cache στο σας λύσεις. Μια εφαρμογή πρέπει να είναι σε θέση να συνεχίσει να λειτουργεί εάν η υπηρεσία που παρέχει το κοινόχρηστο cache δεν είναι διαθέσιμη. Η εφαρμογή δεν θα πρέπει να σταματήσει να ανταποκρίνεται ή να αποτύχει κατά την αναμονή για την υπηρεσία cache για να συνεχίσετε.

Γι ' αυτό, η εφαρμογή πρέπει να προετοιμαστείτε για να εντοπίσετε τη διαθεσιμότητα της υπηρεσίας cache και επιστροφή στο αρχικό χώρο αποθήκευσης δεδομένων εάν το cache είναι προσβάσιμα. Το [διακόπτη κυκλώματος μοτίβο](http://msdn.microsoft.com/library/dn589784.aspx) είναι χρήσιμη για το χειρισμό αυτό το σενάριο. Είναι δυνατή η ανάκτηση της υπηρεσίας που παρέχει το cache και, μόλις γίνει διαθέσιμη, το cache να ειδοποιηθείτε κατά την ανάγνωση δεδομένων φόρμας αρχικό χώρου αποθήκευσης δεδομένων, ακολουθώντας μια στρατηγική όπως το [Cache παύσης μοτίβο](http://msdn.microsoft.com/library/dn589799.aspx).

Ωστόσο, ενδέχεται να υπάρξουν μια κλιμάκωση επίδραση στο σύστημα αν η εφαρμογή επιστρέψουν στο αρχικό χώρο αποθήκευσης δεδομένων όταν είναι διαθέσιμος προσωρινά το cache.
Ενώ γίνεται ανάκτηση του χώρου αποθήκευσης δεδομένων, το αρχικό χώρο αποθήκευσης δεδομένων θα μπορούσε να είναι swamped με αιτήσεις για τα δεδομένα, με αποτέλεσμα χρονικών ορίων και απέτυχε συνδέσεις.

Εξετάστε την εφαρμογή μιας τοπικής, ιδιωτικό cache σε κάθε παρουσία μιας εφαρμογής του, μαζί με το κοινόχρηστο cache που πρόσβαση σε όλες τις εμφανίσεις της εφαρμογής. Όταν η εφαρμογή ανακτά ενός στοιχείου, μπορεί να ελέγξει πρώτα στο το τοπικό cache, στη συνέχεια, στο κοινόχρηστο cache και τέλος στο τα αρχικά δεδομένα το χώρο αποθήκευσης. Το τοπικό cache μπορεί να συμπληρωθεί με τη χρήση των δεδομένων στο κάποιο κοινόχρηστο cache ή στη βάση δεδομένων εάν το κοινόχρηστο cache δεν είναι διαθέσιμη.

Αυτή η προσέγγιση απαιτεί Προσέξτε ρύθμισης παραμέτρων για να αποτρέψετε τη μη ενημερωμένες πολύ σε σχέση με το κοινόχρηστο cache του τοπικού cache. Ωστόσο, το τοπικό cache λειτουργεί ως buffer εάν το κοινόχρηστο cache είναι δυνατή η πρόσβαση. Εικόνα 3 εμφανίζει αυτήν τη δομή.

![Χρήση μιας τοπικής, ιδιωτικό cache με ένα κοινόχρηστο cache](media/best-practices-caching/Caching3.png)
_εικόνα 3: χρήση μιας τοπικής, ιδιωτικό cache με ένα κοινόχρηστο cache_

Για να υποστηρίζουν μεγάλες μνήμης cache που περιέχουν δεδομένα σχετικά μεγάλης διάρκειας, ορισμένες υπηρεσίες cache παρέχουν μια επιλογή υψηλής διαθεσιμότητας που υλοποιεί αυτόματη ανακατεύθυνση εάν το cache δεν είναι διαθέσιμη. Αυτή η προσέγγιση συνήθως περιλαμβάνει την αναπαραγωγή τα δεδομένα στο cache που είναι αποθηκευμένο σε ένα διακομιστή κύρια cache σε διακομιστή δευτερεύοντα cache και μετάβαση στον δευτερεύοντα διακομιστή εάν αποτύχει στον πρωτεύοντα διακομιστή ή συνδεσιμότητας θα χαθεί.

Για να μειώσετε το λανθάνων χρόνος που σχετίζεται με τη σύνταξη σε πολλές προορισμούς, η αναπαραγωγή δευτερεύοντα διακομιστή ενδέχεται να προκύψουν ασύγχρονα κατά την εγγραφή δεδομένων στο cache στον πρωτεύοντα διακομιστή. Αυτή η προσέγγιση υποψήφιων πελατών για την πιθανότητα ότι ορισμένες πληροφορίες στο cache μπορεί να χαθούν σε περίπτωση αποτυχίας, αλλά η αναλογία αυτών των δεδομένων θα πρέπει να είναι μικρά σε σύγκριση με το συνολικό μέγεθος της μνήμης cache.

Εάν ένα κοινόχρηστο cache είναι μεγάλο, ίσως είναι προτιμότερο να δημιουργήσετε διαμερίσματα τα δεδομένα στο cache σε κόμβους για να μειώσετε τις πιθανότητες ασυμφωνίας και τη βελτίωση κλιμάκωση. Πολλά κοινόχρηστο μνήμης cache υποστηρίζει τη δυνατότητα να προσθέσετε δυναμικά (και να καταργήσετε) κόμβους και νέα εξισορρόπηση τα δεδομένα σε διαμερίσματα. Αυτή η προσέγγιση ενδέχεται να περιλαμβάνουν σύμπλεγμα, με την οποία η συλλογή κόμβοι παρουσιάζονται σε εφαρμογές προγράμματος-πελάτη ως ένα cache απρόσκοπτη, μία. Εσωτερικά, ωστόσο, τα δεδομένα είναι γενίκευση μεταξύ κόμβους μετά από μια προκαθορισμένη διανομής στρατηγική που υπολοίπων ομοιόμορφα η φόρτωση. Το [έγγραφο διαμερισμού καθοδήγηση δεδομένων](http://msdn.microsoft.com/library/dn589795.aspx) στην τοποθεσία Web της Microsoft παρέχει περισσότερες πληροφορίες σχετικά με πιθανές διαμερισμού στρατηγικές.

Σύμπλεγμα επίσης να αυξήσετε τη διαθεσιμότητα των το cache. Εάν ένας κόμβος αποτυγχάνει, το υπόλοιπο της μνήμης cache είναι ακόμη προσβάσιμα.
Σύμπλεγμα συχνά χρησιμοποιείται σε συνδυασμό με την αναπαραγωγή και ανακατεύθυνσης. Κάθε κόμβο μπορούν να αναπαραχθούν και, στη ρεπλίκα μπορεί να γρήγορα δυνατή η σύνδεση εάν αποτύχει η τον κόμβο.

Πολλές Διαβάστε και οι λειτουργίες εγγραφής είναι πιθανό να συμπεριλαμβάνουν τιμές δεδομένων μονής ακρίβειας ή αντικείμενα. Ωστόσο, ορισμένες φορές μπορεί να χρειαστεί να αποθηκεύσετε ή να ανακτήσετε γρήγορα μεγάλους όγκους δεδομένων.
Για παράδειγμα, καλλιέργεια ένα cache ενδέχεται να περιλαμβάνουν γράφετε εκατοντάδες ή χιλιάδες των στοιχείων στο cache. Μια εφαρμογή μπορεί να χρειαστεί να ανακτήσετε μεγάλου αριθμού σχετικά στοιχεία από το cache ως μέρος της ίδια αίτηση.

Πολλά ευρείας κλίμακας μνήμης cache παρέχουν δέσμη λειτουργίες για τους σκοπούς αυτούς. Αυτό επιτρέπει σε μια εφαρμογή προγράμματος-πελάτη για να συσκευάσετε του μεγάλο όγκο των στοιχείων σε μία μόνο αίτηση και μειώνει το επιβάρυνσης που είναι συσχετισμένη με την εκτέλεση μεγάλου αριθμού μικρές αιτήσεις.

## <a name="caching-and-eventual-consistency"></a>Προσωρινή αποθήκευση και ενδεχόμενες συνέπειας

Για το μοτίβο παύσης cache για εργασία, την παρουσία της εφαρμογής που συμπληρώνει το cache πρέπει να έχετε πρόσβαση σε τις πιο πρόσφατες και συνεπή έκδοση των δεδομένων. Σε ένα σύστημα που υλοποιεί ενδεχόμενη συνέπειας (όπως ένα χώρο αποθήκευσης δεδομένων από αναπαραγωγή) Αυτό ίσως να μην πεζών και κεφαλαίων γραμμάτων.

Μία παρουσία μιας εφαρμογής του θα μπορούσε να τροποποιήσετε ένα στοιχείο δεδομένων και να ακυρώσει την στο cache έκδοση αυτού του στοιχείου. Μια άλλη παρουσία της εφαρμογής ενδέχεται να προσπαθήσει να διαβάζετε αυτό το στοιχείο από μια cache, η οποία έχει ως αποτέλεσμα ένα αποτυχημένων αιτήσεων cache, ώστε να διαβάζει τα δεδομένα από το χώρο αποθήκευσης δεδομένων και το προσθέτει στο cache. Ωστόσο, εάν ο χώρος αποθήκευσης δεδομένων έχει δεν έχει συγχρονιστεί με τα άλλα αντίγραφα πλήρως, την παρουσία της εφαρμογής θα μπορούσε να διαβάσετε και να τη συμπλήρωση του cache με την παλιά τιμή.

Για περισσότερες πληροφορίες σχετικά με τη Διαχείριση συνέπεια δεδομένων, ανατρέξτε στη σελίδα [Εισαγωγή συνέπειας δεδομένων](http://msdn.microsoft.com/library/dn589800.aspx) στην τοποθεσία Web της Microsoft.

### <a name="protect-cached-data"></a>Προστατεύστε τα δεδομένα στο cache

Ανεξάρτητα από την υπηρεσία cache μπορείτε να χρησιμοποιήσετε, εξετάστε το ενδεχόμενο να πώς να προστατεύσετε τα δεδομένα που διατηρείται στο cache από μη εξουσιοδοτημένη πρόσβαση. Υπάρχουν δύο βασικές προτεραιότητες:

- Η προστασία προσωπικών δεδομένων των δεδομένων στο cache
- Η προστασία προσωπικών δεδομένων των δεδομένων όπως ρέει ανάμεσα στις το cache και την εφαρμογή που χρησιμοποιεί το cache

Για να προστατέψετε τα δεδομένα στο cache, της υπηρεσίας cache ενδέχεται να υλοποιήσετε ένα ελέγχου ταυτότητας μηχανισμό που απαιτεί εφαρμογές καθορίσετε τα εξής:
- Ποια ταυτότητες να αποκτήσετε πρόσβαση σε δεδομένα στο cache.
- Ποιες λειτουργίες (ανάγνωση και εγγραφή) που επιτρέπονται για την εκτέλεση αυτών των ταυτοτήτων.

Για μείωση της επιβάρυνσης που είναι συσχετισμένη με την ανάγνωση και εγγραφή δεδομένων, αφού έχει εκχωρηθεί μια ταυτότητα εγγραφής ή/και πρόσβαση για ανάγνωση στο cache, το οποίο ταυτότητας να χρησιμοποιήσετε οποιαδήποτε δεδομένα στο cache.

Εάν θέλετε να περιορίσετε την πρόσβαση σε υποσύνολα δεδομένων στο cache, μπορείτε να κάνετε ένα από τα εξής:

- Διαίρεση του cache σε διαμερίσματα (χρησιμοποιώντας το cache διαφορετικούς διακομιστές) και μόνο εκχώρηση πρόσβασης με ταυτότητες για τα διαμερίσματα που θα πρέπει να επιτρέπεται να χρησιμοποιήσει.
- Κρυπτογράφηση των δεδομένων σε κάθε υποσύνολο με διαφορετικά κλειδιά και δώστε τα κλειδιά κρυπτογράφησης μόνο για τις ταυτότητες που θα πρέπει να έχετε πρόσβαση σε κάθε υποσύνολο. Μια εφαρμογή προγράμματος-πελάτη ενδέχεται να έχετε τη δυνατότητα να ανακτήσετε όλα τα δεδομένα στο cache, αλλά μόνο θα μπορείτε να αποκρυπτογραφήσετε τα δεδομένα για την οποία έχει τα πλήκτρα.

Μπορείτε επίσης πρέπει να προστατέψετε τα δεδομένα, όπως κείμενο να ρέει και έξοδος από το cache. Για να το κάνετε αυτό, που εξαρτώνται από τις δυνατότητες ασφαλείας που παρέχονται από την υποδομή δικτύου που χρησιμοποιούν εφαρμογές προγράμματος-πελάτη για να συνδεθείτε με το cache. Εάν το cache έχει υλοποιηθεί χρησιμοποιώντας ένα διακομιστή επιτόπου μέσα στην ίδια εταιρεία που φιλοξενεί τις εφαρμογές προγράμματος-πελάτη, στη συνέχεια, την απομόνωση του ίδιου του δικτύου μπορεί να απαιτεί να εκτελέσετε κάποια επιπλέον βήματα. Εάν το cache βρίσκεται απομακρυσμένα και απαιτεί σύνδεση TCP ή HTTP μέσω ενός δημόσιου δικτύου (όπως το Internet), εξετάστε την εφαρμογή SSL.

## <a name="considerations-for-implementing-caching-with-microsoft-azure"></a>Ζητήματα για την εφαρμογή σε cache με το Microsoft Azure

Azure παρέχει το Cache Redis Azure. Αυτή είναι μια εφαρμογή του Άνοιγμα αρχείου προέλευσης cache Redis που εκτελείται ως υπηρεσία σε ένα κέντρο δεδομένων του Azure. Παρέχει μια υπηρεσία σε cache που είναι δυνατή η πρόσβαση από οποιαδήποτε εφαρμογή του Azure, εάν η εφαρμογή έχει υλοποιηθεί ως μια υπηρεσία cloud, μια τοποθεσία Web, ή μέσα σε μια εικονική μηχανή Azure. Οι cache μπορεί να είναι κοινόχρηστο από εφαρμογές προγράμματος-πελάτη που έχουν τον αριθμό-κλειδί κατάλληλα δικαιώματα πρόσβασης.

Azure Redis Cache είναι μια λύση σε cache υψηλών επιδόσεων που παρέχει διαθεσιμότητα, κλιμάκωση και ασφάλεια. Τυπικά εκτελείται ως υπηρεσία που εκτείνεται έναν ή περισσότερους υπολογιστές αποκλειστικό. Επιχειρεί να αποθηκεύει όσες πληροφορίες μπορεί να στη μνήμη για να βεβαιωθείτε ότι γρήγορη πρόσβαση. Αυτή η αρχιτεκτονική προορίζεται για την παροχή χαμηλής λανθάνων χρόνος και υψηλή απόδοση, μειώνοντας την ανάγκη για την εκτέλεση λειτουργιών αργή εισόδου/εξόδου.

 Azure Redis Cache είναι συμβατό με πολλά από τα διάφορα API που χρησιμοποιούνται από εφαρμογές προγράμματος-πελάτη. Εάν έχετε υπάρχουσες εφαρμογές που χρησιμοποιούν ήδη το Cache Redis Azure που εκτελείται στην εσωτερική εγκατάσταση, το Cache Redis Azure παρέχει μια γρήγορη μετεγκατάσταση διαδρομή για προσωρινή αποθήκευση στο cloud.

> [AZURE.NOTE] Azure παρέχει επίσης την υπηρεσία Cache διαχειριζόμενων. Αυτή η υπηρεσία είναι με βάση το μηχανισμό Azure Service ύφασμα Cache. Σας επιτρέπει να δημιουργήσετε ένα κατανεμημένο cache που μπορεί να είναι κοινόχρηστο από εφαρμογές συνδεδεμένων Γενικά. Το cache φιλοξενείται σε διακομιστές υψηλών επιδόσεων που εκτελούνται σε ένα κέντρο δεδομένων του Azure.
Ωστόσο, αυτή η επιλογή δεν είναι πλέον συνιστάται και παρέχεται μόνο για την υποστήριξη υπάρχουσες εφαρμογές που έχουν ενσωματωθεί να το χρησιμοποιήσετε. Για όλες τις νέα ανάπτυξη, χρησιμοποιήστε Azure Redis Cache.
>
> Επιπλέον, Azure υποστηρίζει σε cache στο ρόλο. Αυτή η δυνατότητα σάς επιτρέπει να δημιουργήσετε ένα cache ειδικά για μια υπηρεσία στο cloud.
Το cache φιλοξενείται από τις παρουσίες του ρόλου web ή εργαζόμενου και είναι δυνατή μόνο από τους ρόλους που λειτουργούν ως μέρος της ίδιας μονάδας ανάπτυξης υπηρεσία cloud. (Μια μονάδα ανάπτυξης είναι το σύνολο των παρουσιών ρόλο που έχουν αναπτυχθεί ως μια υπηρεσία στο cloud με μια συγκεκριμένη περιοχή.) Ομαδοποιημένη το cache και όλες τις εμφανίσεις του ρόλου μέσα στην ίδια μονάδα ανάπτυξης που φιλοξενεί το cache γίνονται τμήμα του ίδιου συμπλέγματος cache. Ωστόσο, αυτή η επιλογή δεν είναι πλέον συνιστάται και παρέχεται μόνο για την υποστήριξη υπάρχουσες εφαρμογές που έχουν ενσωματωθεί να το χρησιμοποιήσετε. Για όλες τις νέα ανάπτυξη, χρησιμοποιήστε Azure Redis Cache.
>
> Υπηρεσία Cache διαχειριζόμενων Azure και Cache στο ρόλο Azure είναι αυτήν τη στιγμή έχει καταχωρηθεί για συνταξιοδότηση στην 16ο Νοεμβρίου 2016.
Καλό είναι ότι μπορείτε να μετεγκαταστήσετε Azure Redis Cache προετοιμασία για αυτό συνταξιοδότηση. Για περισσότερες πληροφορίες, επισκεφθείτε τη σελίδα   [Τι είναι το Azure Redis Cache προσφοράς και τι μέγεθος θα πρέπει να χρησιμοποιήσω;](redis-cache/cache-faq.md#what-redis-cache-offering-and-size-should-i-use) στην τοποθεσία Web της Microsoft.


### <a name="features-of-redis"></a>Δυνατότητες του Redis

 Redis είναι περισσότερο από ένα διακομιστή απλού cache. Παρέχει μια κατανεμημένη βάση δεδομένων στη μνήμη με ένα σύνολο εκτεταμένη εντολή που υποστηρίζει πολλές συνηθισμένα σενάρια. Αυτές περιγράφονται παρακάτω σε αυτό το έγγραφο, η ενότητα χρησιμοποιώντας Redis σε cache. Αυτή η ενότητα συνοψίζει ορισμένες από τις βασικές δυνατότητες που παρέχει Redis.

### <a name="redis-as-an-in-memory-database"></a>Redis ως βάση δεδομένων στη μνήμη

Redis υποστηρίζει και τα δύο λειτουργίες ανάγνωσης και εγγραφής. Στο Redis, μπορείτε να προστατέψετε εγγραφές από αποτυχία συστήματος είτε αποθηκεύονται περιοδικά σε ένα αρχείο τοπικό στιγμιότυπο ή σε ένα αρχείο καταγραφής μόνο για προσάρτηση. Αυτό δεν συμβαίνει σε πολλά μνήμης cache (το οποίο θα πρέπει να θεωρούνται αποθηκεύει προσωρινό δεδομένων).

 Όλες οι εγγραφές έχουν ασύγχρονης και αποκλείει πελάτες από την ανάγνωση και εγγραφή δεδομένων. Όταν Redis ξεκινά εκτελείται, διαβάζει τα δεδομένα από το αρχείο στιγμιότυπου ή το αρχείο καταγραφής και χρησιμοποιεί για να δημιουργήσετε το στη μνήμη cache. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [Redis διατήρησης](http://redis.io/topics/persistence) στην τοποθεσία Web του Redis.

> [AZURE.NOTE] Redis δεν εγγυάται ότι όλες οι εγγραφές θα αποθηκευτούν σε περίπτωση αποτυχίας καταστροφική, αλλά στη χειρότερη περίπτωση που ενδέχεται να χαθούν μόνο μερικά δευτερόλεπτα αξίζει των δεδομένων. Να θυμάστε ότι ένα cache δεν προορίζεται για την εκτέλεση ενεργειών ως προέλευση έγκυρων δεδομένων, και είναι ευθύνη των εφαρμογών χρησιμοποιώντας το cache για να εξασφαλίσετε ότι κρίσιμων δεδομένων αποθηκεύεται με επιτυχία στο κατάστημα κατάλληλα δεδομένα. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα το [cache παύσης μοτίβο](http://msdn.microsoft.com/library/dn589799.aspx).

#### <a name="redis-data-types"></a>Redis τύποι δεδομένων

Redis είναι μια τιμή του αριθμού-κλειδιού store, όπου μπορούν να περιέχουν τιμές απλή τύπους ή δομές σύνθετα δεδομένα όπως Κατακερματισμοί, λίστες, και σύνολα. Υποστηρίζει ένα σύνολο ατομικής λειτουργίες σε αυτούς τους τύπους δεδομένων. Πλήκτρα μπορεί να είναι μόνιμο ή με ετικέτες με περιορισμένη χρόνου ζωής, σημείο στο οποίο τον αριθμό-κλειδί και την αντίστοιχη τιμή καταργούνται αυτόματα από το cache. Για περισσότερες πληροφορίες σχετικά με την Redis κλειδιά και τιμές, επισκεφθείτε τη σελίδα [μια εισαγωγή σχετικά με Redis τύπους δεδομένων και αντλήσεις](http://redis.io/topics/data-types-intro) στην τοποθεσία Web του Redis.

#### <a name="redis-replication-and-clustering"></a>Αναπαραγωγή redis και συμπλέγματος

Redis υποστηρίζει υποδείγματος/υφισταμένου αναπαραγωγής για να βεβαιωθείτε ότι διαθεσιμότητα και να διατηρήσετε μεταγωγή. Γράψτε λειτουργίες σε έναν κόμβο κύρια Redis αναπαράγονται σε μία ή περισσότερες δευτερεύουσες κόμβους. Λειτουργίες ανάγνωσης μπορεί να δοθεί από το υπόδειγμα ή οποιαδήποτε από τα υφιστάμενους.

Σε περίπτωση ένα διαμερίσματα δικτύου, υφιστάμενους να συνεχίσετε να χρησιμοποιηθεί δεδομένων και, στη συνέχεια, με διαφάνεια συγχρονίσετε ξανά με το πρότυπο όταν η σύνδεση έχει αποκατασταθεί. Για περισσότερες λεπτομέρειες, επισκεφθείτε τη σελίδα [αναπαραγωγής](http://redis.io/topics/replication) στην τοποθεσία Web του Redis.

Redis παρέχει επίσης σύμπλεγμα, η οποία σας επιτρέπει να με διαφάνεια διαμερισμάτων δεδομένων σε shards σε διακομιστές και ανακοίνωση η φόρτωση. Αυτή η δυνατότητα βελτιώνει την κλιμάκωση, επειδή μπορούν να προστεθούν νέες Redis διακομιστές και τα δεδομένα που έχουν γίνει νέα δημιουργία διαμερισμάτων ως το μέγεθος του cache αυξάνεται.

Επιπλέον, κάθε διακομιστή στο σύμπλεγμα μπορούν να αναπαραχθούν με χρήση του υποδείγματος/υφισταμένου αναπαραγωγής. Αυτό εξασφαλίζει διαθεσιμότητα σε κάθε κόμβο του συμπλέγματος. Για περισσότερες πληροφορίες σχετικά με το σύμπλεγμα και sharding, επισκεφθείτε τη [σελίδα εκμάθησης σύμπλεγμα Redis](http://redis.io/topics/cluster-tutorial) στην τοποθεσία Web του Redis.

### <a name="redis-memory-use"></a>Χρήση της μνήμης redis

Ένα cache Redis έχει πεπερασμένο μέγεθος που εξαρτάται από τους πόρους που είναι διαθέσιμα στον κεντρικό υπολογιστή. Όταν ρυθμίζετε τις παραμέτρους ενός διακομιστή Redis, μπορείτε να καθορίσετε τη μέγιστη ποσότητα μνήμης μπορεί να χρησιμοποιήσει. Μπορείτε επίσης να ρυθμίσετε έναν αριθμό-κλειδί στο cache Redis να έχετε μια ώρα λήξης, μετά από την οποία είναι καταργούνται αυτόματα από το cache. Αυτή η δυνατότητα μπορεί να σας βοηθήσει εμποδίζουν τη συμπλήρωση με παλιό ή μη ενημερωμένες δεδομένα στη μνήμη cache του.

Όταν γεμίσει μνήμης, Redis να αυτόματα καταργήστε κλειδιά και τις τιμές τους, ακολουθώντας έναν αριθμό πολιτικών. Η προεπιλογή είναι LRU (τουλάχιστον πρόσφατα χρησιμοποιημένων), αλλά μπορείτε επίσης να επιλέξετε άλλες πολιτικές όπως evicting πλήκτρα τυχαία ή να απενεργοποιήσετε eviction εντελώς (σε ποια, πεζών-κεφαλαίων προσπάθειες για να προσθέσετε στοιχεία ΑΠΟΤΥΧΙΑ το cache εάν είναι πλήρης). Στη σελίδα [Με χρήση Redis ως ένα cache LRU](http://redis.io/topics/lru-cache) παρέχει περισσότερες πληροφορίες.

### <a name="redis-transactions-and-batches"></a>Redis συναλλαγές και δέσμες

Redis ενεργοποιεί μια εφαρμογή προγράμματος-πελάτη για να υποβάλετε μια σειρά λειτουργιών που ανάγνωση και εγγραφή δεδομένων στο cache ως ατομικής συναλλαγή. Όλες οι εντολές στη συναλλαγή είναι εγγυημένη για να εκτελέσετε διαδοχικά και δεν υπάρχουν εντολές εκδοθεί από άλλα προγράμματα-πελάτες ταυτόχρονες θα είναι αλληλένδετες μεταξύ τους.

Ωστόσο, δεν υπάρχουν true συναλλαγές όπως σχεσιακή βάση δεδομένων θα εκτέλεσή τους. Επεξεργασία συναλλαγών αποτελείται από δύο σταδίων--το πρώτο είναι όταν οι εντολές βρίσκονται στην ουρά και το δεύτερο είναι όταν οι εντολές που εκτελούνται. Κατά τη διάρκεια του σταδίου ουράς εντολή, τις εντολές που περιλαμβάνει τη συναλλαγή υποβάλλονται από το πρόγραμμα-πελάτη. Εάν παρουσιαστεί κάποιο σφάλμα σε αυτό το σημείο (όπως ένα συντακτικό σφάλμα ή εσφαλμένο αριθμό παράμετροι), στη συνέχεια, Redis αρνηθεί να επεξεργαστεί ολόκληρη η συναλλαγή και απορρίπτει το.

Κατά την εκτέλεση φάση, Redis εκτελεί κάθε εντολή στην ουρά με τη σειρά. Εάν αποτύχει μια εντολή σε αυτήν τη φάση, Redis συνεχίζει με την επόμενη εντολή στην ουρά και δεν επαναφέρουν τα εφέ όλες οι εντολές που έχετε εκτελέσει ήδη. Αυτήν τη φόρμα απλοποιημένη συναλλαγής σάς βοηθά να διατηρήσετε την απόδοση και να αποφύγετε προβλήματα επιδόσεων που προκαλούνται από διένεξης.

Redis υλοποίηση της φόρμας αισιόδοξη κλειδώματος για να σας βοηθήσουν στη διατήρηση συνέπειας. Για λεπτομερείς πληροφορίες σχετικά με τις συναλλαγές και κλείδωμα με Redis, επισκεφθείτε τη [σελίδα συναλλαγές](http://redis.io/topics/transactions) στην τοποθεσία Web του Redis.

Redis υποστηρίζει επίσης μη συναλλαγών δέσμης των αιτήσεων. Το πρωτόκολλο Redis που χρησιμοποιούν προγράμματα-πελάτες για την αποστολή εντολών σε ένα διακομιστή Redis ενεργοποιεί ένα πρόγραμμα-πελάτη για να στείλετε μια σειρά λειτουργιών ως μέρος της ίδια αίτηση. Αυτό μπορεί να σας βοηθήσει να μειώσετε κατακερματισμός πακέτο στο δίκτυο. Κατά την επεξεργασία της δέσμης, εκτελείται κάθε εντολή. Εάν κάποια από αυτές τις εντολές είναι ακατάλληλη, αυτά θα απορρίπτονται (το οποίο δεν συμβαίνει με μια συναλλαγή), αλλά οι υπόλοιπες εντολές θα εκτελεστεί. Δεν υπάρχει επίσης εγγυημένη σχετικά με τη σειρά με την οποία θα γίνει επεξεργασία τις εντολές στη δέσμη.

### <a name="redis-security"></a>Redis ασφαλείας

Redis είναι εστιασμένη καθαρά σε παρέχοντας γρήγορη πρόσβαση σε δεδομένα και έχει σχεδιαστεί για να εκτελέσετε μέσα σε μια αξιόπιστη περιβάλλον που είναι δυνατή μόνο από προγράμματα-πελάτες του αξιόπιστη. Redis υποστηρίζει ένα μοντέλο περιορισμένη ασφαλείας βάσει τον έλεγχο ταυτότητας τον κωδικό πρόσβασης. (Είναι δυνατό να καταργήσετε εντελώς, τον έλεγχο ταυτότητας Παρόλο που δεν συνιστάται αυτό.)

Όλοι οι πελάτες με έλεγχο ταυτότητας κοινή χρήση τον ίδιο κωδικό πρόσβασης καθολικού και αποκτήστε πρόσβαση στους ίδιους πόρους. Εάν χρειάζεστε πιο ολοκληρωμένη εισόδου ασφαλείας, πρέπει να υλοποιήσετε το δικό σας επίπεδο ασφαλείας μπροστά από το διακομιστή Redis και όλες τις αιτήσεις προγράμματος-πελάτη πρέπει να περάσει από αυτό το επίπεδο επιπλέον. Redis πρέπει να δεν είναι εκτεθειμένη σε υπολογιστές-πελάτες μη αξιόπιστα ή χωρίς έλεγχο ταυτότητας απευθείας.

Μπορείτε να περιορίσετε την πρόσβαση στις εντολές απενεργοποιώντας τους ή μετονομασία τους (και, παρέχοντας μόνο Προνομιούχους προγράμματα-πελάτες με τα νέα ονόματα).

Redis δεν υποστηρίζει απευθείας οποιαδήποτε μορφή της κρυπτογράφησης δεδομένων, ώστε όλα κωδικοποίηση πρέπει να πραγματοποιηθεί από εφαρμογές προγράμματος-πελάτη. Επιπλέον, Redis δεν παρέχει κάθε μορφή ασφάλεια μεταφοράς. Εάν θέλετε να προστατέψετε τα δεδομένα ως κείμενο να ρέει στο δίκτυο, συνιστάται να εφαρμογής ενός διακομιστή μεσολάβησης SSL.

Για περισσότερες πληροφορίες, επισκεφθείτε τη σελίδα [Redis ασφαλείας](http://redis.io/topics/security) στην τοποθεσία Web του Redis.

> [AZURE.NOTE] Azure Redis Cache παρέχει δικό του επίπεδο ασφάλειας μέσω του οποίου συνδέονται οι υπολογιστές-πελάτες. Διακομιστές της υποκείμενης Redis δεν είναι εκτεθειμένη στο δημόσιο δίκτυο.

### <a name="using-the-azure-redis-cache"></a>Χρήση του cache Azure Redis

Το Cache Redis Azure παρέχει πρόσβαση στους διακομιστές Redis που εκτελούνται σε διακομιστές που φιλοξενούνται σε ένα κέντρο δεδομένων του Azure; λειτουργεί ως μια πρόσοψη που παρέχει έλεγχο πρόσβασης και την ασφάλεια. Που μπορούν να προμηθεύσουν ένα cache, χρησιμοποιώντας την πύλη διαχείρισης Azure. Η πύλη παρέχει πολλές προκαθορισμένες ρυθμίσεις παραμέτρων, διαβάθμιση από το cache 53GB εκτελείται ως μια αποκλειστική υπηρεσία που υποστηρίζει επικοινωνίες SSL (για την προστασία προσωπικών δεδομένων) και η αναπαραγωγή υποδείγματος/υφισταμένου με μια SLA διαθεσιμότητας 99,9%, προς τα κάτω σε μια 250 MB cache χωρίς αλληλεπίδραση (χωρίς τις εγγυήσεις της διαθεσιμότητας) εκτελείται σε κοινόχρηστο υλικού.

Χρησιμοποιώντας την πύλη διαχείρισης Azure, μπορείτε να επίσης ρύθμιση παραμέτρων της πολιτικής eviction της μνήμης cache και τον έλεγχο της πρόσβασης στο cache, προσθέτοντας χρήστες στο τους ρόλους που παρέχονται. Κάτοχος, συνεργάτης, Reader. Αυτές οι ρόλοι καθορίζουν τις ενέργειες που μπορούν να εκτελούν τα μέλη της. Για παράδειγμα, τα μέλη του ρόλου κατόχου έχουν πλήρη έλεγχο όσον αφορά το cache (συμπεριλαμβανομένων των ασφαλείας) και τα περιεχόμενά της, τα μέλη του ρόλου συμβολής να διαβάζετε και να γράφετε τις πληροφορίες στο cache και τα μέλη του ρόλου Reader μόνο να ανακτήσετε δεδομένα από το cache.

Οι περισσότερες εργασίες διαχείρισης που εκτελούνται μέσω της πύλης διαχείρισης Azure και για αυτόν το λόγο πολλές από τις διαθέσιμες στην τυπική έκδοση του Redis διαχείρισης εντολές δεν είναι διαθέσιμες, συμπεριλαμβανομένης της δυνατότητας για να τροποποιήσετε τις ρυθμίσεις παραμέτρων μέσω προγραμματισμού, τον τερματισμό του διακομιστή Redis, ρύθμιση παραμέτρων επιπλέον slaves ή υποχρεωτικά αποθήκευση δεδομένων στο δίσκο.

Η πύλη διαχείρισης Azure περιλαμβάνει μια εύκολη γραφική απεικόνιση που σας επιτρέπει να παρακολουθείτε τις επιδόσεις της μνήμης cache. Για παράδειγμα, μπορείτε να προβάλετε τον αριθμό των συνδέσεων που γίνονται, ο αριθμός των αιτήσεων που εκτελούνται, τον όγκο των ανάγνωσης και εγγραφής, και τον αριθμό των cache επισκέψεις έναντι αποτυχίες cache. Χρησιμοποιώντας αυτές τις πληροφορίες, μπορείτε να προσδιορίσετε την αποτελεσματικότητα της μνήμης cache και, εάν είναι απαραίτητο εναλλαγή σε διαφορετική ρύθμιση παραμέτρων ή αλλαγή της πολιτικής eviction. Επιπλέον, μπορείτε να δημιουργήσετε τις ειδοποιήσεις που στέλνουν μηνύματα ηλεκτρονικού ταχυδρομείου με το διαχειριστή εάν μία ή περισσότερες κρίσιμες μετρικά υπερβαίνουν μια περιοχή αναμενόμενο. Για παράδειγμα, εάν ο αριθμός των αποτυχημένων αιτήσεων cache υπερβαίνει μιας καθορισμένης τιμής την τελευταία ώρα, ο διαχειριστής μπορεί να ειδοποιηθούν καθώς το cache μπορεί να είναι πολύ μικρό ή δεδομένων μπορεί να είναι που έχει εξαχθεί πάρα πολύ γρήγορα.

Μπορείτε επίσης να παρακολουθήσετε CPU, μνήμης και χρήση δικτύου για το cache.

Για περισσότερες πληροφορίες και παραδείγματα που δείχνει πώς να δημιουργήσετε και να ρυθμίσετε τις παραμέτρους μιας Cache Redis Azure, επισκεφθείτε τη σελίδα [οριζόντιο γύρω από το Azure Redis Cache](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) στο ιστολόγιο του Azure.

## <a name="caching-session-state-and-html-output"></a>Κατάσταση σε cache περιόδου λειτουργίας και εξόδου HTML

Εάν έχετε δημιουργία ASP.NET εφαρμογές που εκτελέσετε χρησιμοποιώντας τους ρόλους Azure web, μπορείτε να αποθηκεύσετε πληροφορίες κατάστασης λειτουργίας και εξόδου HTML σε ένα Cache Redis Azure web. Η υπηρεσία παροχής κατάσταση λειτουργίας για Azure Redis Cache σάς επιτρέπει να κάνετε κοινή χρήση πληροφοριών περιόδου λειτουργίας ανάμεσα σε διαφορετικές παρουσίες μιας εφαρμογής web ASP.NET και είναι πολύ χρήσιμη στις περιπτώσεις συστοιχία web όπου συσχέτισης υπολογιστή-πελάτη διακομιστή δεν είναι διαθέσιμη και σε cache περιόδου λειτουργίας δεδομένων στη μνήμη δεν θα είναι κατάλληλα.

Χρήση της υπηρεσίας παροχής κατάσταση περιόδου λειτουργίας με Azure Redis Cache προσφέρει διάφορα οφέλη, όπως:

- Το να κάνετε κοινή χρήση κατάσταση περιόδου λειτουργίας μεταξύ μεγάλου αριθμού των εμφανίσεων μιας εφαρμογής web ASP.NET, παρέχοντας βελτιωμένη δυνατότητα κλιμάκωσης,
- Υποστηρίζει ελέγχεται, ταυτόχρονες πρόσβαση σε τα ίδια δεδομένα κατάστασης περιόδου λειτουργίας για πολλά προγράμματα ανάγνωσης και ένα μεμονωμένο πρόγραμμα εγγραφής, και
- Μπορεί να χρησιμοποιήσει τη συμπίεση για να αποθηκεύσετε μνήμη και να βελτιώσετε τις επιδόσεις του δικτύου.

Για περισσότερες πληροφορίες, επισκεφθείτε τη σελίδα [ASP.NET περιόδου λειτουργίας κατάσταση υπηρεσίας παροχής για Azure Redis Cache](redis-cache/cache-aspnet-session-state-provider.md) στην τοποθεσία Web της Microsoft.

> [AZURE.NOTE] Μην χρησιμοποιείτε την υπηρεσία παροχής κατάσταση λειτουργίας για Azure Redis Cache για εφαρμογές ASP.NET που εκτελούνται εκτός του Azure περιβάλλοντος. Η αδράνεια των πρόσβαση του cache από εκτός του Azure να αποκλείσετε τα οφέλη επιδόσεων από την προσωρινή αποθήκευση δεδομένων.

Ομοίως, η υπηρεσία παροχής Cache εξόδου για Azure Redis Cache σάς επιτρέπει να αποθηκεύσετε τις απαντήσεις HTTP που δημιουργούνται από μια εφαρμογή web ASP.NET. Χρήση της υπηρεσίας παροχής Cache εξόδου με Azure Redis Cache μπορεί να βελτιώσει τις ώρες απόκριση με τις εφαρμογές που αποδίδει σύνθετες εξόδου HTML; Χρησιμοποιήστε παρουσιών της εφαρμογής παραγωγής παρόμοια απαντήσεις μπορεί να κάνει το κοινόχρηστο εξόδου τμημάτων στα το cache αντί για δημιουργία αυτό HTML υπολογίσουν εξόδου.  Για περισσότερες πληροφορίες, επισκεφθείτε τη σελίδα [ASP.NET εξόδου Cache υπηρεσία παροχής που χρησιμοποιείτε για το Azure Redis Cache](redis-cache/cache-aspnet-output-cache-provider.md) στην τοποθεσία Web της Microsoft.

### <a name="azure-redis-cache"></a>Azure Redis cache

Azure Redis Cache παρέχει πρόσβαση σε διακομιστές Redis που φιλοξενούνται σε ένα κέντρο δεδομένων του Azure. Λειτουργεί ως μια πρόσοψη που παρέχει έλεγχο πρόσβασης και την ασφάλεια. Μπορείτε να προμήθεια ένα cache χρησιμοποιώντας την πύλη του Azure.

Η πύλη παρέχει πολλές προκαθορισμένες ρυθμίσεις παραμέτρων. Αυτές κυμαίνονται από ένα cache 53 GB εκτελείται ως μια αποκλειστική υπηρεσία που υποστηρίζει επικοινωνίες SSL (για την προστασία προσωπικών δεδομένων) και υποδείγματος/υφισταμένου αλληλεπίδραση με ένα SLA διαθεσιμότητας 99,9%, προς τα κάτω σε ένα 25 0 MB cache χωρίς αλληλεπίδραση (χωρίς τις εγγυήσεις της διαθεσιμότητας) εκτελείται σε κοινόχρηστο υλικού.

Με την πύλη Azure, μπορείτε να επίσης ρύθμιση παραμέτρων της πολιτικής eviction της μνήμης cache και τον έλεγχο της πρόσβασης στο cache, προσθέτοντας χρήστες στο τους ρόλους που παρέχονται.  Αυτούς τους ρόλους, το οποίο ορίζετε τις λειτουργίες που μπορούν να εκτελούν τα μέλη, συμπεριλάβετε κάτοχο, συμβολής και ανάγνωσης. Για παράδειγμα, τα μέλη του ρόλου κατόχου έχουν πλήρη έλεγχο όσον αφορά το cache (συμπεριλαμβανομένων των ασφαλείας) και τα περιεχόμενά της, τα μέλη του ρόλου συμβολής να διαβάζετε και να γράφετε τις πληροφορίες στο cache και τα μέλη του ρόλου Reader μόνο να ανακτήσετε δεδομένα από το cache.

Οι περισσότερες εργασίες διαχείρισης που εκτελούνται μέσω της πύλης Azure. Για αυτόν το λόγο, πολλές από τις εντολές διαχείρισης που είναι διαθέσιμες στην τυπική έκδοση του Redis δεν είναι διαθέσιμη, συμπεριλαμβανομένης της δυνατότητας για να τροποποιήσετε τη ρύθμιση παραμέτρων μέσω προγραμματισμού, τερματίστε το διακομιστή Redis, ρύθμιση παραμέτρων επιπλέον υφιστάμενους ή υποχρεωτικά αποθήκευση δεδομένων στο δίσκο.

Η πύλη του Azure περιλαμβάνει μια εύκολη γραφική απεικόνιση που σας επιτρέπει να παρακολουθείτε τις επιδόσεις της μνήμης cache. Για παράδειγμα, μπορείτε να προβάλετε τον αριθμό των συνδέσεων που γίνονται, ο αριθμός των αιτήσεων που εκτελούνται, τον όγκο των ανάγνωσης και εγγραφής, και τον αριθμό των επισκέψεων cache έναντι αποτυχίες cache. Χρησιμοποιώντας αυτές τις πληροφορίες, μπορείτε να προσδιορίσετε την αποτελεσματικότητα της μνήμης cache και εάν είναι απαραίτητο, μεταβείτε σε μια διαφορετική ρύθμιση παραμέτρων ή να αλλάξετε την πολιτική eviction.

Επιπλέον, μπορείτε να δημιουργήσετε τις ειδοποιήσεις που στέλνουν μηνύματα ηλεκτρονικού ταχυδρομείου με το διαχειριστή εάν μία ή περισσότερες κρίσιμες μετρικά υπερβαίνουν μια περιοχή αναμενόμενο. Για παράδειγμα, μπορεί να θέλετε να λαμβάνω διαχειριστής, εάν ο αριθμός αποτυχιών cache υπερβαίνει μιας καθορισμένης τιμής την τελευταία ώρα, επειδή σημαίνει αυτό το cache μπορεί να είναι πολύ μικρό ή δεδομένων μπορεί να είναι που έχει εξαχθεί πάρα πολύ γρήγορα.

Μπορείτε επίσης να παρακολουθείτε τη χρήση της CPU, μνήμη, και δικτύου για το cache.

Για περισσότερες πληροφορίες και παραδείγματα που δείχνει πώς να δημιουργήσετε και να ρυθμίσετε τις παραμέτρους μιας Cache Redis Azure, επισκεφθείτε τη σελίδα [οριζόντιο γύρω από το Azure Redis Cache](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) στο ιστολόγιο του Azure.

## <a name="caching-session-state-and-html-output"></a>Κατάσταση σε cache περιόδου λειτουργίας και εξόδου HTML

Εάν δημιουργείτε εφαρμογές web ASP.NET ότι εκτελέσετε χρησιμοποιώντας τους ρόλους Azure web, μπορείτε να αποθηκεύσετε την περίοδο λειτουργίας αναφέρουν πληροφορίες και εξόδου HTML σε μια Azure Redis Cache. Η υπηρεσία παροχής κατάσταση λειτουργίας για Azure Redis Cache σάς επιτρέπει να κάνετε κοινή χρήση πληροφοριών περιόδου λειτουργίας ανάμεσα σε διαφορετικές παρουσίες μιας εφαρμογής web ASP.NET και είναι πολύ χρήσιμη στις περιπτώσεις συστοιχία web όπου συσχέτισης υπολογιστή-πελάτη διακομιστή δεν είναι διαθέσιμη και σε cache περιόδου λειτουργίας δεδομένων στη μνήμη δεν θα είναι κατάλληλα.

Χρήση της υπηρεσίας παροχής κατάσταση περιόδου λειτουργίας με Azure Redis Cache προσφέρει διάφορα οφέλη, όπως:

- Κατάσταση περιόδου λειτουργίας κοινής χρήσης με μεγάλο αριθμό των παρουσιών της εφαρμογές web ASP.NET.
- Παροχή βελτιωμένη δυνατότητα κλιμάκωσης.
- Υποστήριξη ελέγχεται, ταυτόχρονες πρόσβαση σε τα ίδια δεδομένα κατάστασης περιόδου λειτουργίας για πολλά προγράμματα ανάγνωσης και ένα μεμονωμένο πρόγραμμα εγγραφής.
- Χρήση της συμπίεσης για να αποθηκεύσετε μνήμη και να βελτιώσετε τις επιδόσεις του δικτύου.

Για περισσότερες πληροφορίες, επισκεφθείτε τη σελίδα [ASP.NET περιόδου λειτουργίας κατάσταση υπηρεσίας παροχής για Azure Redis Cache](redis-cache/cache-aspnet-session-state-provider.md) στην τοποθεσία Web της Microsoft.

> [AZURE.NOTE] Μην χρησιμοποιείτε την υπηρεσία παροχής κατάσταση λειτουργίας για Azure Redis Cache με εφαρμογές ASP.NET που εκτελούνται εκτός του Azure περιβάλλοντος. Η αδράνεια των πρόσβαση του cache από εκτός του Azure να αποκλείσετε τα οφέλη επιδόσεων από την προσωρινή αποθήκευση δεδομένων.

Ομοίως, η υπηρεσία παροχής cache εξόδου για Azure Redis Cache σάς επιτρέπει να αποθηκεύσετε τις απαντήσεις HTTP που δημιουργούνται από μια εφαρμογή web ASP.NET. Χρήση της υπηρεσίας παροχής cache εξόδου με Azure Redis Cache μπορεί να βελτιώσει τις ώρες απόκριση με τις εφαρμογές που αποδίδει σύνθετες εξόδου HTML. Παρουσιών της εφαρμογής που δημιουργούν παρόμοια αποκρίσεις να κάνετε χρήση των του κοινόχρηστου εξόδου τμημάτων στα το cache αντί για δημιουργία αυτό HTML υπολογίσουν εξόδου. Για περισσότερες πληροφορίες, επισκεφθείτε τη σελίδα [ASP.NET εξόδου cache υπηρεσία παροχής που χρησιμοποιείτε για το Azure Redis Cache](redis-cache/cache-aspnet-output-cache-provider.md) στην τοποθεσία Web της Microsoft.

## <a name="building-a-custom-redis-cache"></a>Δημιουργία ενός προσαρμοσμένου cache Redis

Azure Redis Cache λειτουργεί ως μια πρόσοψη του υποκείμενου τους διακομιστές Redis. Προς το παρόν υποστηρίζει ένα σταθερό σύνολο ρυθμίσεις παραμέτρων αλλά δεν παρέχει για σύμπλεγμα Redis. Εάν χρειάζεστε μια ρύθμιση παραμέτρων για προχωρημένους που δεν καλύπτεται από το cache Azure Redis (όπως μια μεγαλύτερη από 53 GB cache) μπορείτε να δημιουργήσετε και να φιλοξενείτε τις δικές σας διακομιστές Redis χρησιμοποιώντας Azure εικονικές μηχανές.

Αυτή είναι μια σύνθετη ενδεχομένως διαδικασία επειδή ίσως χρειαστεί να δημιουργήσετε διάφορες ΣΠΣ θα ενεργήσει ως κόμβους κύριες και δευτερεύουσες εάν θέλετε για την υλοποίηση της αναπαραγωγής. Επιπλέον, εάν θέλετε να δημιουργήσετε ένα σύμπλεγμα, στη συνέχεια, χρειάζεστε πολλά υποδείγματα και δευτερεύουσες διακομιστές. Μια τοπολογία ελάχιστους ομαδοποιημένων αναπαραγωγής που παρέχει ένα υψηλό επίπεδο διαθεσιμότητα και κλιμάκωση περιλαμβάνει τουλάχιστον έξι ΣΠΣ οργανωμένα σε τρεις ζεύγη των διακομιστών υποδείγματος/υφισταμένου (ένα σύμπλεγμα πρέπει να περιέχει τουλάχιστον τρεις κύριες κόμβοι).

Κάθε ζεύγος υποδείγματος/υφισταμένου πρέπει να βρίσκεται κοντά μεταξύ τους για να ελαχιστοποιήσετε λανθάνοντος χρόνου. Ωστόσο, κάθε σύνολο ζεύγη μπορεί να να εκτελείται σε διαφορετική Azure κέντρα δεδομένων που βρίσκεται σε διαφορετικές περιοχές, εάν θέλετε να εντοπίσετε δεδομένα στο cache Κλείσιμο για τις εφαρμογές που είναι πιο πιθανό να το χρησιμοποιείτε. Η σελίδα [Εκτελείται Redis σε μια Εικονική Linux CentOS στα Azure](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) στην τοποθεσία Web του Microsoft καθοδηγεί σε ένα παράδειγμα που δείχνει πώς μπορείτε να δημιουργήσετε και να ρυθμίσετε έναν κόμβο Redis εκτελείται ως Εικονική μηχανή Azure.

[AZURE.NOTE] Έχετε υπόψη ότι εάν εφαρμόσετε τις δικές σας cache Redis με αυτόν τον τρόπο, είστε υπεύθυνοι για παρακολούθηση, τη διαχείριση και ασφάλιση της υπηρεσίας.

## <a name="partitioning-a-redis-cache"></a>Δημιουργία διαμερισμάτων ένα cache Redis

Δημιουργία διαμερισμάτων του cache περιλαμβάνει διαίρεση του cache σε πολλούς υπολογιστές. Αυτήν τη δομή σας προσφέρει αρκετά πλεονεκτήματα χρησιμοποιώντας ένα μεμονωμένο cache διακομιστή, όπως:

- Δημιουργία μιας cache που είναι πολύ μεγαλύτερο από μπορούν να αποθηκευτούν σε ένα διακομιστή.
- Διανομή δεδομένων σε διακομιστές, τη βελτίωση της διαθεσιμότητας. Εάν μία server αποτυγχάνει ή θα είναι δυνατή η πρόσβαση, τα δεδομένα που περιέχει δεν είναι διαθέσιμη, αλλά τα δεδομένα στους διακομιστές υπόλοιπο εξακολουθεί να είναι δυνατή η πρόσβαση. Για μια cache, αυτό δεν είναι κρίσιμης σημασίας επειδή τα δεδομένα στο cache είναι μόνο ένα μεταβατικές αντίγραφο των δεδομένων που διατηρείται σε μια βάση δεδομένων. Δεδομένα στο cache σε ένα διακομιστή που θα γίνει χωρίς δυνατότητα πρόσβασης μπορούν να cache σε διαφορετικό διακομιστή.
- Διασπορά η φόρτωση στους διακομιστές, συνεπώς βελτίωση της απόδοσης και κλιμάκωση.
- Κλείστε το Geolocating δεδομένων στους χρήστες που έχουν πρόσβαση, μειώνοντας έτσι λανθάνοντος χρόνου.

Για μια cache, η πιο κοινή μορφή των διαμερισμάτων είναι sharding. Σε αυτή τη στρατηγική, κάθε διαμερίσματα (ή shard) είναι μια cache Redis στο δικό του δεξιά. Μια συγκεκριμένη partition κατευθύνεται δεδομένων με τη χρήση λογική sharding, η οποία μπορεί να χρησιμοποιεί μια ποικιλία προσεγγίσεις για τη διανομή των δεδομένων. Το [μοτίβο Sharding](http://msdn.microsoft.com/library/dn589797.aspx) παρέχει περισσότερες πληροφορίες σχετικά με την εφαρμογή sharding.

Για να υλοποιήσετε διαμερισμάτων σε μνήμη cache Redis, μπορείτε να κάνετε μία από τις παρακάτω μεθόδους:

- _Δρομολόγηση ερωτήματος πλευρά του διακομιστή._ Σε αυτήν την τεχνική, μια εφαρμογή προγράμματος-πελάτη στέλνει μια πρόσκληση σε οποιονδήποτε από τους διακομιστές Redis που αποτελούν το cache (πιθανότατα την πλησιέστερη server). Κάθε διακομιστής Redis αποθηκεύει μετα-δεδομένων που περιγράφει τα διαμερίσματα που περιέχει, ενώ περιλαμβάνει επίσης πληροφορίες σχετικά με το ποιες βρίσκονται τα διαμερίσματα σε άλλους διακομιστές. Ο διακομιστής Redis εξετάζει την αίτηση προγράμματος-πελάτη. Εάν μπορούν να επιλυθούν τοπικά, αυτό θα εκτελέσει την απαιτούμενη λειτουργία. Διαφορετικά αυτό θα προωθεί την αίτηση στο κατάλληλο διακομιστή. Αυτό το μοντέλο έχει υλοποιηθεί με Redis σύμπλεγμα και περιγράφεται με περισσότερες λεπτομέρειες στη σελίδα [Redis σύμπλεγμα πρόγραμμα εκμάθησης](http://redis.io/topics/cluster-tutorial) στην τοποθεσία Web του Redis. Σύμπλεγμα redis είναι διαφανή σε εφαρμογές προγράμματος-πελάτη και πρόσθετους διακομιστές Redis μπορούν να προστεθούν σε σύμπλεγμα (και τα δεδομένα εκ νέου διαμερίσματα) χωρίς να χρειάζεται να αλλάξετε τις παραμέτρους των υπολογιστών-πελατών.

- _Δημιουργία διαμερισμάτων πλευρά του προγράμματος-πελάτη._ Σε αυτό το μοντέλο, την εφαρμογή-πελάτη περιέχει λογική (πιθανώς στη φόρμα μιας βιβλιοθήκης) που δρομολογεί αιτήσεις στον κατάλληλο διακομιστή Redis. Αυτή η προσέγγιση μπορεί να χρησιμοποιηθεί με το Azure Redis Cache. Δημιουργία πολλών Azure Redis μνήμης cache (μία για κάθε διαμερίσματα δεδομένων) και υλοποίηση της λογικής πλευρά του προγράμματος-πελάτη που δρομολογεί τα αιτήματα στη σωστή μνήμη cache. Εάν του συνδυασμού διαμερισμάτων αλλάξει (εάν επιπλέον μνήμης cache για Redis Azure δημιουργούνται, για παράδειγμα), εφαρμογές προγράμματος-πελάτη, ίσως χρειαστεί να ρυθμιστούν.

- _Διακομιστής μεσολάβησης μέσω διαμερισμάτων._ Σε αυτό το σχήμα, το πρόγραμμα-πελάτη αποστολή εφαρμογές αιτήσεις σε μια υπηρεσία ενδιάμεσες διακομιστή μεσολάβησης που κατανοούν πώς έχει διαμερίσματα τα δεδομένα και, στη συνέχεια, να δρομολογεί την αίτηση στην κατάλληλη Redis διακομιστή. Αυτή η προσέγγιση μπορεί επίσης να χρησιμοποιηθεί με το Cache Redis Azure. η υπηρεσία μεσολάβησης μπορεί να υλοποιηθεί ως υπηρεσία Azure cloud. Αυτή η προσέγγιση απαιτεί ένα πρόσθετο επίπεδο πολυπλοκότητα για την υλοποίηση της υπηρεσίας και αιτήσεις ενδέχεται να χρειαστεί περισσότερος χρόνος για να εκτελέσετε από τη χρήση διαμερισμάτων πλευρά του προγράμματος-πελάτη.

Στη σελίδα [διαμέριση: Τρόπος για να διαιρέσετε δεδομένα μεταξύ πολλών παρουσιών Redis](http://redis.io/topics/partitioning) σε Redis την τοποθεσία Web παρέχει περαιτέρω πληροφορίες σχετικά με την εφαρμογή διαμερισμάτων με Redis.

### <a name="implement-redis-cache-client-applications"></a>Υλοποίηση Redis εφαρμογές προγράμματος-πελάτη cache

Redis υποστηρίζει εφαρμογές προγράμματος-πελάτη που έχουν δημιουργηθεί σε πολλές γλώσσες προγραμματισμού. Εάν δημιουργείτε νέες εφαρμογές χρησιμοποιώντας το .NET Framework, συνιστάται η προσέγγιση είναι να χρησιμοποιήσετε τη βιβλιοθήκη StackExchange.Redis προγράμματος-πελάτη. Αυτή η βιβλιοθήκη παρέχει ένα μοντέλο αντικειμένου .NET Framework που συνοψίζει τις λεπτομέρειες για τη σύνδεση σε ένα διακομιστή Redis, εντολές αποστολή και λήψη απαντήσεων. Είναι διαθέσιμα στο Visual Studio ως ένα πακέτο NuGet. Μπορείτε να χρησιμοποιήσετε αυτήν τη βιβλιοθήκη ίδιο για να συνδεθείτε με μια Cache Redis Azure ή ένα προσαρμοσμένο cache Redis φιλοξενούνται σε μια Εικονική.

Για να συνδεθείτε σε ένα διακομιστή Redis μπορείτε να χρησιμοποιήσετε τη στατική `Connect` μέθοδο το `ConnectionMultiplexer` τάξης. Τη σύνδεση που δημιουργεί αυτή η μέθοδος έχει σχεδιαστεί για να χρησιμοποιηθούν σε όλη τη διάρκεια ζωής της εφαρμογής υπολογιστή-πελάτη και την ίδια σύνδεση μπορούν να χρησιμοποιηθούν από πολλά νήματα ταυτόχρονες. Μην συνδεθείτε ξανά και αποσυνδέεστε κάθε φορά που εκτελείτε μια λειτουργία Redis επειδή αυτό μπορεί να μειώσει τις επιδόσεις.

Μπορείτε να καθορίσετε τις παραμέτρους της σύνδεσης, όπως τη διεύθυνση του τον κεντρικό υπολογιστή του Redis και τον κωδικό πρόσβασης. Εάν χρησιμοποιείτε το Azure Redis Cache, ο κωδικός πρόσβασης είναι είτε το πρωτεύον ή δευτερεύον κλειδί που δημιουργείται για το Azure Redis Cache χρησιμοποιώντας την πύλη διαχείρισης Azure.

Αφού έχετε συνδέσει με το διακομιστή Redis, μπορείτε να αποκτήσετε μια λαβή από τη βάση δεδομένων Redis που λειτουργεί ως το cache. Η σύνδεση Redis παρέχει το `GetDatabase` μέθοδο για να το κάνετε αυτό. Στη συνέχεια, μπορείτε να ανακτήσετε στοιχεία από το cache και να αποθηκεύετε τα δεδομένα στο cache, χρησιμοποιώντας το `StringGet` και `StringSet` μεθόδους. Αυτές οι μέθοδοι αναμένετε έναν αριθμό-κλειδί ως παράμετρο, και να επιστρέψετε στο στοιχείο είτε στο cache που έχει μια τιμή που ταιριάζει (`StringGet`) ή να προσθέσετε το στοιχείο στο cache με αυτό το κλειδί (`StringSet`).

Ανάλογα με τη θέση του διακομιστή Redis, πολλές λειτουργίες ίσως να προκύψουν ορισμένες λανθάνων χρόνος ενώ μια αίτηση μεταδίδεται στο διακομιστή και επιστρέφεται μια απάντηση στο πρόγραμμα-πελάτη. Η βιβλιοθήκη StackExchange παρέχει ασύγχρονης εκδόσεις του πολλές από τις μεθόδους που εκθέτει για να παραμείνει αποκρίνεται εφαρμογές προγράμματος-πελάτη. Αυτές οι μέθοδοι υποστηρίζει το [Βάσει εργασίας ασύγχρονης μοτίβο](http://msdn.microsoft.com/library/hh873175.aspx) στο .NET Framework.

Το παρακάτω τμήμα κώδικα εμφανίζει μια μέθοδο με το όνομα `RetrieveItem`. Παρουσιάζει μια εφαρμογή του μοτίβου cache παύσης βάση Redis και τη βιβλιοθήκη StackExchange. Η μέθοδος λαμβάνει μια τιμή συμβολοσειρά κλειδιού και επιχειρήσει να ανακτήσει το αντίστοιχο στοιχείο από το cache Redis καλώντας την `StringGetAsync` μέθοδο (της ασύγχρονης έκδοσης του `StringGet`).

Εάν το στοιχείο δεν βρεθεί, την λήψη από τα υποκείμενα δεδομένα προέλευσης χρησιμοποιώντας το `GetItemFromDataSourceAsync` μέθοδο (το οποίο είναι ένα τοπικό μέθοδο και δεν είναι μέλος της βιβλιοθήκης StackExchange). Στη συνέχεια, προστίθεται στο cache, χρησιμοποιώντας το `StringSetAsync` μέθοδο, ώστε να μπορεί να ανακτηθεί πιο γρήγορα επόμενη φορά.

```csharp
// Connect to the Azure Redis cache
ConfigurationOptions config = new ConfigurationOptions();
config.EndPoints.Add("<your DNS name>.redis.cache.windows.net");
config.Password = "<Redis cache key from management portal>";
ConnectionMultiplexer redisHostConnection = ConnectionMultiplexer.Connect(config);
IDatabase cache = redisHostConnection.GetDatabase();
...
private async Task<string> RetrieveItem(string itemKey)
{
    // Attempt to retrieve the item from the Redis cache
    string itemValue = await cache.StringGetAsync(itemKey);

    // If the value returned is null, the item was not found in the cache
    // So retrieve the item from the data source and add it to the cache
    if (itemValue == null)
    {
        itemValue = await GetItemFromDataSourceAsync(itemKey);
        await cache.StringSetAsync(itemKey, itemValue);
    }

    // Return the item
    return itemValue;
}
```

Το `StringGet` και `StringSet` μεθόδους δεν περιορίζονται για την ανάκτηση ή την αποθήκευση τιμές συμβολοσειρών. Μπορούν να πάρουν οποιοδήποτε στοιχείο που είναι σειριοποιημένο ως πίνακας των byte. Εάν χρειάζεστε για να αποθηκεύσετε ένα αντικείμενο .NET, μπορείτε να το σειριοποίηση ως ροή byte και να χρησιμοποιήσετε το `StringSet` μέθοδο για να γράψετε το στο cache.

Ομοίως, μπορείτε να διαβάσετε ένα αντικείμενο από το cache με τη χρήση του `StringGet` μέθοδο και αποσειριοποίηση το ως ένα αντικείμενο .NET. Ο ακόλουθος κώδικας εμφανίζει ένα σύνολο μεθόδων επέκταση για τη διασύνδεση IDatabase (το `GetDatabase` μέθοδος μιας σύνδεσης Redis επιστρέφει ένα `IDatabase` αντικειμένου), καθώς και ορισμένα δείγμα κώδικα που χρησιμοποιεί αυτές τις μεθόδους για την ανάγνωση και εγγραφή μια `BlogPost` αντικειμένων στο cache:

```csharp
public static class RedisCacheExtensions
{
    public static async Task<T> GetAsync<T>(this IDatabase cache, string key)
    {
        return Deserialize<T>(await cache.StringGetAsync(key));
    }

    public static async Task<object> GetAsync(this IDatabase cache, string key)
    {
        return Deserialize<object>(await cache.StringGetAsync(key));
    }

    public static async Task SetAsync(this IDatabase cache, string key, object value)
    {
        await cache.StringSetAsync(key, Serialize(value));
    }

    static byte[] Serialize(object o)
    {
        byte[] objectDataAsStream = null;

        if (o != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream())
            {
                binaryFormatter.Serialize(memoryStream, o);
                objectDataAsStream = memoryStream.ToArray();
            }
        }

        return objectDataAsStream;
    }

    static T Deserialize<T>(byte[] stream)
    {
        T result = default(T);

        if (stream != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream(stream))
            {
                result = (T)binaryFormatter.Deserialize(memoryStream);
            }
        }

        return result;
    }
}
```

Ο ακόλουθος κώδικας απεικονίζει μια μέθοδο με το όνομα `RetrieveBlogPost` που χρησιμοποιεί αυτές τις μεθόδους επέκταση για να διαβάζετε και να γράφετε μια δυνατότητα σειριοποίησης `BlogPost` αντικειμένων στο cache ακολουθώντας το μοτίβο cache παύσης:

```csharp
// The BlogPost type
[Serializable]
private class BlogPost
{
    private HashSet<string> tags = new HashSet<string>();

    public BlogPost(int id, string title, int score, IEnumerable<string> tags)
    {
        this.Id = id;
        this.Title = title;
        this.Score = score;
        this.tags = new HashSet<string>(tags);
    }

    public int Id { get; set; }
    public string Title { get; set; }
    public int Score { get; set; }
    public ICollection<string> Tags { get { return this.tags; } }
}
...
private async Task<BlogPost> RetrieveBlogPost(string blogPostKey)
{
    BlogPost blogPost = await cache.GetAsync<BlogPost>(blogPostKey);
    if (blogPost == null)
    {
        blogPost = await GetBlogPostFromDataSourceAsync(blogPostKey);
        await cache.SetAsync(blogPostKey, blogPost);
    }

    return blogPost;
}
```

Redis υποστηρίζει την εντολή pipelining εάν μια εφαρμογή προγράμματος-πελάτη στέλνει πολλών ασύγχρονων αιτήσεων. Redis να Πολυπλεξία τις αιτήσεις χρησιμοποιώντας την ίδια σύνδεση αντί να λαμβάνει και να ανταποκρίνεται στις εντολές σε μια ακολουθία αντικειμενική.

Αυτή η προσέγγιση βοηθά στη μείωση λανθάνων χρόνος, καθιστώντας πιο αποτελεσματική χρήση του δικτύου. Το παρακάτω τμήμα κώδικα εμφανίζει ένα παράδειγμα το οποίο ανακτά τις λεπτομέρειες των δύο πελάτες ταυτόχρονα. Ο κώδικας υποβάλλει δύο αιτήσεις και, στη συνέχεια, εκτελεί ορισμένες άλλες Επεξεργασία (δεν εμφανίζεται) πριν από την αναμονή για να λάβετε τα αποτελέσματα. Το `Wait` μέθοδος του αντικειμένου cache είναι παρόμοια με το .NET Framework `Task.Wait` μέθοδο:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
var task1 = cache.StringGetAsync("customer:1");
var task2 = cache.StringGetAsync("customer:2");
...
var customer1 = cache.Wait(task1);
var customer2 = cache.Wait(task2);
```

Η σελίδα [Azure Redis Cache τεκμηρίωση](https://azure.microsoft.com/documentation/services/cache/) στην τοποθεσία Web της Microsoft παρέχει περισσότερες πληροφορίες σχετικά με τον τρόπο για να γράψετε εφαρμογές προγράμματος-πελάτη που μπορούν να χρησιμοποιούν το Cache Redis Azure. Πρόσθετες πληροφορίες είναι διαθέσιμες στη [βασική χρήση σελίδας](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md) στην τοποθεσία Web του StackExchange.Redis.

Η σελίδα [αγωγούς και multiplexers](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md) στην τοποθεσία Web του ίδιου παρέχει περισσότερες πληροφορίες σχετικά με ασύγχρονων λειτουργιών και pipelining με Redis και τη βιβλιοθήκη StackExchange.  Στην επόμενη ενότητα σε αυτό το άρθρο, χρησιμοποιώντας Redis σε cache, παρέχει παραδείγματα ορισμένα από τα πιο προηγμένες τεχνικές που μπορείτε να εφαρμόσετε στα δεδομένα που παραμένει στο cache μια Redis.

## <a name="using-redis-caching"></a>Χρήση Redis σε cache

Η πιο απλός χρήση Redis για προσωρινή αποθήκευση ανησυχίες είναι ζεύγη κλειδιού-τιμής όπου η τιμή είναι μια συμβολοσειρά Αμετάφραστη μήκος που μπορεί να περιέχει δυαδικά δεδομένα. (Αυτό είναι ουσιαστικά ένας πίνακας των byte που μπορούν να αντιμετωπίζεται ως συμβολοσειρά). Αυτό το σενάριο έχει απεικονίζονται στις εφαρμογές προγράμματος-πελάτη του Cache Redis υλοποίηση ενότητα νωρίτερα σε αυτό το άρθρο.

Σημειώστε ότι πλήκτρα περιέχει επίσης Αμετάφραστη δεδομένων, ώστε να μπορείτε να χρησιμοποιήσετε οποιαδήποτε δυαδικές πληροφορίες ως το κλειδί. Όσο περισσότερο το κλειδί είναι, ωστόσο, το περισσότερο χώρο θα χρειαστεί να αποθηκεύσετε και τόσο περισσότερος χρόνος θα χρειαστεί να εκτελέσετε λειτουργίες αναζήτησης. Για χρηστικότητα και διευκόλυνση της συντήρησης, σχεδίαση σας keyspace προσεκτικά και χρησιμοποιήστε πλήκτρα χαρακτηριστικό (αλλά όχι λεπτομερής).

Για παράδειγμα, μπορείτε να χρησιμοποιήσετε δομημένες πλήκτρα όπως "πελατών: 100" για να αντιπροσωπεύει τον αριθμό-κλειδί για τον πελάτη με 100 Αναγνωριστικό και όχι απλώς "100". Αυτό το σχήμα σάς επιτρέπει να διακρίνετε εύκολα μεταξύ των τιμών που αποθηκεύουν διαφορετικούς τύπους δεδομένων. Για παράδειγμα, μπορείτε, επίσης, θα μπορούσε να χρησιμοποιήσετε τον αριθμό-κλειδί "Παραγγελίες: 100" για να αντιπροσωπεύει το κλειδί για τη σειρά με το Αναγνωριστικό 100.

Εκτός από μονοδιάστατη δυαδικό συμβολοσειρές, μια τιμή σε ένα ζεύγος κλειδιού-τιμής Redis επίσης να κρατήσετε πιο δομημένες πληροφορίες, συμπεριλαμβανομένων των λιστών, σύνολα (ταξινομημένες και χωρίς ταξινόμηση) και κατακερματίζουν. Redis παρέχει ένα σύνολο ολοκληρωμένη εντολή που να διαχειριστείτε αυτούς τους τύπους και πολλές από αυτές τις εντολές είναι διαθέσιμες σε εφαρμογές .NET Framework μέσω ενός προγράμματος-πελάτη βιβλιοθήκη όπως StackExchange. Η σελίδα [μια εισαγωγή σχετικά με Redis τύπους δεδομένων και αντλήσεις](http://redis.io/topics/data-types-intro) στην τοποθεσία Web του Redis παρέχει μια πιο λεπτομερή επισκόπηση των αυτούς τους τύπους και τις εντολές που μπορείτε να χρησιμοποιήσετε για το χειρισμό τους.

Αυτή η ενότητα συνοψίζει ορισμένες συνήθεις περιπτώσεις χρήσης για αυτούς τους τύπους δεδομένων και εντολές.

### <a name="perform-atomic-and-batch-operations"></a>Εκτέλεση ατομικής και μαζικών λειτουργιών

Redis υποστηρίζει μιας σειράς ατομικής get-και-το σύνολο των λειτουργιών σε τιμές συμβολοσειρών. Αυτές οι λειτουργίες κατάργηση τους κινδύνους πιθανές αγωνιστικά που ενδέχεται να προκύψουν κατά τη χρήση ξεχωριστή `GET` και `SET` εντολές. Οι λειτουργίες που είναι διαθέσιμες περιλαμβάνουν τα εξής:

- `INCR`, `INCRBY`, `DECR`, και `DECRBY`, που εκτελούν ατομικής αύξηση και μείωση λειτουργίες σε ακέραιες τιμές αριθμητικά δεδομένα. Η βιβλιοθήκη StackExchange παρέχει υπερφορτωμένες εκδόσεις του το `IDatabase.StringIncrementAsync` και `IDatabase.StringDecrementAsync` μεθόδους για να εκτελέσετε αυτές τις λειτουργίες και επιστρέφουν την προκύπτουσα τιμή που είναι αποθηκευμένα στο cache. Το παρακάτω τμήμα κώδικα δείχνει πώς μπορείτε να χρησιμοποιήσετε τις παρακάτω μεθόδους:

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  await cache.StringSetAsync("data:counter", 99);
  ...
  long oldValue = await cache.StringIncrementAsync("data:counter");
  // Increment by 1 (the default)
  // oldValue should be 100

  long newValue = await cache.StringDecrementAsync("data:counter", 50);
  // Decrement by 50
  // newValue should be 50
  ```

- `GETSET`, οποίο ανακτά την τιμή που είναι συσχετισμένη με έναν αριθμό-κλειδί και αλλάζει σε μια νέα τιμή. Η βιβλιοθήκη StackExchange καθιστά αυτήν τη λειτουργία διαθέσιμο έως το `IDatabase.StringGetSetAsync` μέθοδο. Το τμήμα κώδικα παρακάτω παρουσιάζει ένα παράδειγμα αυτής της μεθόδου. Αυτός ο κωδικός επιστρέφει την τρέχουσα τιμή που είναι συσχετισμένη με το πλήκτρο "δεδομένων: αντιπρόταση" από το προηγούμενο παράδειγμα. Στη συνέχεια, επαναφέρει την τιμή για αυτό το κλειδί στην τιμή μηδέν, όλων ως μέρος του την ίδια λειτουργία:

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  string oldValue = await cache.StringGetSetAsync("data:counter", 0);
  ```

- `MGET`και `MSET`, που να επιστρέφουν ή να αλλάξετε ένα σύνολο τιμών συμβολοσειράς ως μία λειτουργία. Το `IDatabase.StringGetAsync` και `IDatabase.StringSetAsync` μεθόδους είναι φορτωμένη υπερβολικά να υποστηρίζει αυτή η λειτουργία, όπως φαίνεται στο ακόλουθο παράδειγμα:

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  // Create a list of key-value pairs
  var keysAndValues =
      new List<KeyValuePair<RedisKey, RedisValue>>()
      {
          new KeyValuePair<RedisKey, RedisValue>("data:key1", "value1"),
          new KeyValuePair<RedisKey, RedisValue>("data:key99", "value2"),
          new KeyValuePair<RedisKey, RedisValue>("data:key322", "value3")
      };

  // Store the list of key-value pairs in the cache
  cache.StringSet(keysAndValues.ToArray());
  ...
  // Find all values that match a list of keys
  RedisKey[] keys = { "data:key1", "data:key99", "data:key322"};
  RedisValue[] values = null;
  values = cache.StringGet(keys);
  // values should contain { "value1", "value2", "value3" }
  ```

Μπορείτε επίσης να συνδυάσετε πολλές εργασίες σε μία συναλλαγή Redis όπως περιγράφεται στο Redis συναλλαγές δέσμες ενότητα και νωρίτερα σε αυτό το άρθρο. Η βιβλιοθήκη StackExchange παρέχει υποστήριξη για συναλλαγές μέσω του `ITransaction` περιβάλλοντος εργασίας.

Μπορείτε να δημιουργήσετε ένα `ITransaction` αντικειμένου με χρήση του `IDatabase.CreateTransaction` μέθοδο. Κλήση εντολές για τη συναλλαγή, χρησιμοποιώντας τις μεθόδους που παρέχονται από το `ITransaction` αντικειμένου.

Το `ITransaction` περιβάλλον παρέχει πρόσβαση σε ένα σύνολο από μεθόδους που είναι παρόμοια με εκείνα προσβάσιμη από το `IDatabase` περιβάλλοντος εργασίας, με τη διαφορά ότι όλες οι μέθοδοι είναι ασύγχρονης. Αυτό σημαίνει ότι είναι μόνο που εκτελούνται όταν το `ITransaction.Execute` καλείται η μέθοδος. Η τιμή που επιστρέφεται από το `ITransaction.Execute` μέθοδο υποδεικνύει εάν η συναλλαγή δημιουργήθηκε με επιτυχία (αληθές) ή εάν απέτυχε (false).

Το παρακάτω τμήμα κώδικα παρουσιάζει ένα παράδειγμα που μετρητές δύο διαστήματα και μειώνεται ως μέρος της ίδιας πράξης:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
ITransaction transaction = cache.CreateTransaction();
var tx1 = transaction.StringIncrementAsync("data:counter1");
var tx2 = transaction.StringDecrementAsync("data:counter2");
bool result = transaction.Execute();
Console.WriteLine("Transaction {0}", result ? "succeeded" : "failed");
Console.WriteLine("Result of increment: {0}", tx1.Result);
Console.WriteLine("Result of decrement: {0}", tx2.Result);
```

Να θυμάστε ότι οι συναλλαγές Redis σε αντίθεση με τις συναλλαγές σχεσιακές βάσεις δεδομένων. Το `Execute` μέθοδο ουρές απλώς όλες οι εντολές που αποτελούν το κίνησης να εκτελείται και, εάν οποιαδήποτε από αυτές είναι ακατάλληλη, στη συνέχεια, η συναλλαγή έχει διακοπεί. Εάν όλες οι εντολές στην ουρά με επιτυχία, κάθε εντολή εκτελείται ασύγχρονα.

Εάν δεν οποιαδήποτε εντολή, οι άλλες συνεχίστε εξακολουθεί να επεξεργασίας. Εάν χρειάζεστε για να επαληθεύσετε ότι ολοκληρώθηκε με επιτυχία μια εντολή, που πρέπει να κάνετε λήψη τα αποτελέσματα της εντολής, χρησιμοποιώντας την ιδιότητα **αποτέλεσμα** από την αντίστοιχη εργασία, όπως φαίνεται στο παραπάνω παράδειγμα. Ανάγνωση της ιδιότητας **αποτέλεσμα** θα αποκλεισμός συνομιλίας μέχρι να ολοκληρωθεί η εργασία.

Για περισσότερες πληροφορίες, ανατρέξτε στη σελίδα [συναλλαγών σε Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md) στην τοποθεσία Web του StackExchange.Redis.

Κατά την εκτέλεση λειτουργιών δέσμης ενεργειών, μπορείτε να χρησιμοποιήσετε το `IBatch` περιβάλλοντος εργασίας της βιβλιοθήκης StackExchange. Αυτή η διασύνδεση παρέχει πρόσβαση σε ένα σύνολο μεθόδων παρόμοια με εκείνα προσβάσιμη από το `IDatabase` περιβάλλοντος εργασίας, με τη διαφορά ότι όλες οι μέθοδοι είναι ασύγχρονης.

Μπορείτε να δημιουργήσετε ένα `IBatch` αντικειμένου με χρήση το `IDatabase.CreateBatch` μέθοδο και, στη συνέχεια, εκτελέστε τη δέσμη, χρησιμοποιώντας το `IBatch.Execute` μέθοδο, όπως φαίνεται στο παρακάτω παράδειγμα. Αυτός ο κωδικός απλώς ορίζει τιμή συμβολοσειράς, διαστήματα και μειώνεται το ίδιο μετρητές που χρησιμοποιούνται στο προηγούμενο παράδειγμα, και εμφανίζει τα αποτελέσματα:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
IBatch batch = cache.CreateBatch();
batch.StringSetAsync("data:key1", 11);
var t1 = batch.StringIncrementAsync("data:counter1");
var t2 = batch.StringDecrementAsync("data:counter2");
batch.Execute();
Console.WriteLine("{0}", t1.Result);
Console.WriteLine("{0}", t2.Result);
```

Είναι σημαντικό να κατανοήσετε ότι σε αντίθεση με μια συναλλαγή, εάν αποτύχει μια εντολή σε μια δέσμη επειδή είναι ακατάλληλη, τις άλλες εντολές μπορεί να εξακολουθεί να εκτελείται. Το `IBatch.Execute` μέθοδος δεν επιστρέφει κάποια ένδειξη της επιτυχίας ή αποτυχίας.

### <a name="perform-fire-and-forget-cache-operations"></a>Εκτέλεση fire και ξεχάσετε λειτουργίες cache

Redis fire υποστηρίζει και ξεχάσετε λειτουργίες χρησιμοποιώντας την εντολή σημαίες. Σε αυτήν την περίπτωση, το πρόγραμμα-πελάτη απλώς ξεκινά μια πράξη, αλλά έχει χωρίς ενδιαφέρον για το αποτέλεσμα και δεν περιμένετε για την εντολή να ολοκληρωθεί. Το παρακάτω παράδειγμα δείχνει πώς μπορείτε να εκτελέσετε την εντολή INCR ως ένα fire και ξεχάσετε λειτουργία:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
await cache.StringSetAsync("data:key1", 99);
...
cache.StringIncrement("data:key1", flags: CommandFlags.FireAndForget);
```

### <a name="specify-automatically-expiring-keys"></a>Καθορισμός αυτόματα λήξης πλήκτρα

Όταν αποθηκεύετε ένα στοιχείο σε μια μνήμη cache Redis, μπορείτε να καθορίσετε ένα χρονικό όριο μετά από την οποία το στοιχείο θα καταργηθούν αυτόματα από το cache. Μπορείτε επίσης να υποβάλετε ερώτημα πόσο περισσότερο χρόνο έχει έναν αριθμό-κλειδί πριν από τη λήξη, χρησιμοποιώντας το `TTL` εντολή. Αυτή η εντολή είναι διαθέσιμη στις εφαρμογές StackExchange χρησιμοποιώντας το `IDatabase.KeyTimeToLive` μέθοδο.

Το παρακάτω τμήμα κώδικα δείχνει πώς μπορείτε να ορίσετε μια ώρα λήξης της 20 δευτερόλεπτα σε έναν αριθμό-κλειδί και ερωτήματος η υπόλοιπη διάρκεια ζωής του αριθμού-κλειδιού:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration time of 20 seconds
await cache.StringSetAsync("data:key1", 99, TimeSpan.FromSeconds(20));
...
// Query how much time a key has left to live
// If the key has already expired, the KeyTimeToLive function returns a null
TimeSpan? expiry = cache.KeyTimeToLive("data:key1");
```

Μπορείτε επίσης να ορίσετε την ώρα λήξης για μια συγκεκριμένη ημερομηνία και ώρα, χρησιμοποιώντας την εντολή ΛΉΞΗΣ, το οποίο είναι διαθέσιμο στη βιβλιοθήκη StackExchange ως το `KeyExpireAsync` μέθοδο:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration date of midnight on 1st January 2015
await cache.StringSetAsync("data:key1", 99);
await cache.KeyExpireAsync("data:key1",
    new DateTime(2015, 1, 1, 0, 0, 0, DateTimeKind.Utc));
...
```

> _Συμβουλή:_ Μπορείτε να καταργήσετε με μη αυτόματο τρόπο ένα στοιχείο από το cache, χρησιμοποιώντας την εντολή DEL, το οποίο είναι διαθέσιμο μέσω της βιβλιοθήκης StackExchange ως το `IDatabase.KeyDeleteAsync` μέθοδο.

### <a name="use-tags-to-cross-correlate-cached-items"></a>Χρήση ετικετών για διασταυρούμενο-συσχετίζονται στοιχείων στο cache

Ένα σύνολο Redis είναι μια συλλογή από πολλά στοιχεία που μοιράζονται ένα μεμονωμένο κλειδί. Μπορείτε να δημιουργήσετε ένα σύνολο, χρησιμοποιώντας την εντολή SADD. Μπορείτε να ανακτήσετε τα στοιχεία σε ένα σύνολο, χρησιμοποιώντας την εντολή SMEMBERS. Η βιβλιοθήκη StackExchange εκτελεί την εντολή SADD με το `IDatabase.SetAddAsync` μέθοδο και SMEMBERS την εντολή με το `IDatabase.SetMembersAsync` μέθοδο.

Μπορείτε επίσης να συνδυάσετε υπάρχοντα σύνολα για να δημιουργήσετε νέα σύνολα χρησιμοποιώντας το SDIFF (ορισμός διαφορά), ΣΚΩΡΊΑ (ορισμός τομή) και εντολές SUNION (ορισμός Ένωση). Η βιβλιοθήκη StackExchange ενοποιεί τις εργασίες αυτές με την `IDatabase.SetCombineAsync` μέθοδο. Η πρώτη παράμετρος σε αυτήν τη μέθοδο Καθορίζει τη λειτουργία συνόλου για να εκτελέσετε.

Τα ακόλουθα τμήματα κώδικα εμφανίζουν πώς μπορεί να είναι χρήσιμο για τη γρήγορη την αποθήκευση και ανάκτηση συλλογές σχετικών στοιχείων σύνολα. Αυτός ο κωδικός χρησιμοποιεί το `BlogPost` τύπου που περιγράφεται στην ενότητα εφαρμογές προγράμματος-πελάτη Cache Redis υλοποίηση νωρίτερα σε αυτό το άρθρο.

A `BlogPost` αντικείμενο περιέχει τέσσερα πεδία — ένα Αναγνωριστικό, έναν τίτλο, μια βαθμολογία κατάταξης και μια συλλογή από ετικέτες. Το πρώτο τμήμα κώδικα παρακάτω εμφανίζει το δείγμα δεδομένων που χρησιμοποιείται για τη συμπλήρωση μιας C# λίστας `BlogPost` αντικείμενα:

```csharp
List<string[]> tags = new List<string[]>()
{
    new string[] { "iot","csharp" },
    new string[] { "iot","azure","csharp" },
    new string[] { "csharp","git","big data" },
    new string[] { "iot","git","database" },
    new string[] { "database","git" },
    new string[] { "csharp","database" },
    new string[] { "iot" },
    new string[] { "iot","database","git" },
    new string[] { "azure","database","big data","git","csharp" },
    new string[] { "azure" }
};

List<BlogPost> posts = new List<BlogPost>();
int blogKey = 0;
int blogPostId = 0;
int numberOfPosts = 20;
Random random = new Random();
for (int i = 0; i < numberOfPosts; i++)
{
    blogPostId = blogKey++;
    posts.Add(new BlogPost(
        blogPostId,               // Blog post ID
        string.Format(CultureInfo.InvariantCulture, "Blog Post #{0}",
            blogPostId),          // Blog post title
        random.Next(100, 10000),  // Ranking score
        tags[i % tags.Count]));   // Tags--assigned from a collection
                                  // in the tags list
}
```

Μπορείτε να αποθηκεύσετε τις ετικέτες για κάθε `BlogPost` αντικειμένου ως σύνολο σε μνήμη cache Redis και να συσχετίσετε κάθε σύνολο με το Αναγνωριστικό του `BlogPost`. Αυτή η δυνατότητα επιτρέπει μια εφαρμογή για να βρείτε γρήγορα όλες τις ετικέτες που ανήκουν σε μια συγκεκριμένη δημοσίευση ιστολογίου. Για να ενεργοποιήσετε την αναζήτηση προς την αντίθετη κατεύθυνση και εύρεση όλων των καταχωρήσεων ιστολογίου που κάνουν κοινή χρήση μια συγκεκριμένη ετικέτα, μπορείτε να δημιουργήσετε ένα άλλο σύνολο όπου διατηρείται το ιστολόγιο του δημοσιεύσεις αναφορά το Αναγνωριστικό ετικέτας στο κλειδί:

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Tags are easily represented as Redis Sets
foreach (BlogPost post in posts)
{
    string redisKey = string.Format(CultureInfo.InvariantCulture,
        "blog:posts:{0}:tags", post.Id);
    // Add tags to the blog post in Redis
    await cache.SetAddAsync(
        redisKey, post.Tags.Select(s => (RedisValue)s).ToArray());

    // Now do the inverse so we can figure how which blog posts have a given tag
    foreach (var tag in post.Tags)
    {
        await cache.SetAddAsync(string.Format(CultureInfo.InvariantCulture,
            "tag:{0}:blog:posts", tag), post.Id);
    }
}
```

Αυτές τις δομές σάς επιτρέπουν να εκτελέσετε πολλά κοινά ερωτήματα πολύ αποτελεσματικά. Για παράδειγμα, μπορείτε να βρείτε και να εμφανίσετε όλες τις ετικέτες για την καταχώρηση ιστολογίου 1 ως εξής:

```csharp
// Show the tags for blog post #1
foreach (var value in await cache.SetMembersAsync("blog:posts:1:tags"))
{
    Console.WriteLine(value);
}
```

Μπορείτε να βρείτε όλες τις ετικέτες που είναι κοινά και για ιστολόγιο δημοσίευση 1 και ιστολόγιο δημοσίευση 2 με την εκτέλεση μιας λειτουργίας Διασταύρωση σύνολο, ως εξής:

```csharp
// Show the tags in common for blog posts #1 and #2
foreach (var value in await cache.SetCombineAsync(SetOperation.Intersect, new RedisKey[]
    { "blog:posts:1:tags", "blog:posts:2:tags" }))
{
    Console.WriteLine(value);
}
```

Και μπορείτε να βρείτε όλες τις δημοσιεύσεις ιστολογίου που περιέχει μια συγκεκριμένη ετικέτα:

```csharp
// Show the ids of the blog posts that have the tag "iot".
foreach (var value in await cache.SetMembersAsync("tag:iot:blog:posts"))
{
    Console.WriteLine(value);
}
```

### <a name="find-recently-accessed-items"></a>Εύρεση πρόσφατα πρόσβαση σε στοιχεία

Μια κοινή εργασία που απαιτούνται από τις πολλές εφαρμογές είναι για να βρείτε τα πιο πρόσφατα πρόσβαση σε στοιχεία. Για παράδειγμα, μια τοποθεσία ιστολογίου μπορεί να θέλετε να εμφανίσετε πληροφορίες σχετικά με την πιο πρόσφατη ώρα ανάγνωσης καταχωρήσεων ιστολογίου.

Μπορείτε να υλοποιήσετε αυτή η λειτουργία, χρησιμοποιώντας μια λίστα Redis. Μια λίστα Redis περιέχει πολλά στοιχεία που έχουν το ίδιο κλειδί. Στη λίστα λειτουργεί ως μια ουρά πολλαπλών αντιστοιχίσεων. Να πατήσετε στοιχεία σε ένα από τα άκρα της λίστας χρησιμοποιώντας τις εντολές (δεξιά push) RPUSH και LPUSH (αριστερή push). Μπορείτε να ανακτήσετε στοιχεία από ένα από τα άκρα της λίστας, χρησιμοποιώντας τις εντολές LPOP και RPOP. Μπορείτε επίσης να επιστρέψετε ένα σύνολο στοιχείων, χρησιμοποιώντας τις εντολές LRANGE και ΤΑΚΤΟΠΟΊΗΣΗ.

Τα παρακάτω τμήματα κώδικα δείχνουν πώς μπορείτε να εκτελέσετε αυτές τις λειτουργίες χρησιμοποιώντας τη βιβλιοθήκη StackExchange. Αυτός ο κωδικός χρησιμοποιεί το `BlogPost` τύπου από το προηγούμενο παράδειγμα. Κατά την ανάγνωση μια καταχώρηση ιστολογίου από το χρήστη, την `IDatabase.ListLeftPushAsync` μέθοδο προωθεί τον τίτλο της καταχώρησης ιστολογίου πάνω σε μια λίστα που είναι συσχετισμένη με το πλήκτρο "blog:recent_posts" στο Redis cache.

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:recent_posts";
BlogPost blogPost = ...; // Reference to the blog post that has just been read
await cache.ListLeftPushAsync(
    redisKey, blogPost.Title); // Push the blog post onto the list
```

Όπως διαβάζονται περισσότερες καταχωρήσεων ιστολογίου, τους τίτλους προωθούνται στην ίδια λίστα. Στη λίστα είναι σύμφωνα με τη σειρά με την οποία έχουν προστεθεί τους τίτλους. Η πιο πρόσφατη ώρα ανάγνωσης καταχωρήσεων ιστολογίου είναι προς το αριστερό άκρο της λίστας. (Εάν η ίδια καταχώρηση ιστολογίου είναι ανάγνωση περισσότερες από μία φορές, θα έχει πολλές καταχωρήσεις στη λίστα.)

Μπορείτε να εμφανίσετε τους τίτλους την πιο πρόσφατη ώρα ανάγνωσης δημοσιεύσεις με τη χρήση του `IDatabase.ListRange` μέθοδο. Η μέθοδος αυτή σας μεταφέρει το κλειδί που περιέχει τη λίστα, ένα σημείο εκκίνησης και ένα τελικό σημείο. Ο ακόλουθος κώδικας ανακτά οι τίτλοι των 10 καταχωρήσεων ιστολογίου (στοιχεία από 0 έως 9) στο τέλος πιο αριστερή της λίστας:

```csharp
// Show latest ten posts
foreach (string postTitle in await cache.ListRangeAsync(redisKey, 0, 9))
{
    Console.WriteLine(postTitle);
}
```

Λάβετε υπόψη ότι η `ListRangeAsync` μέθοδος δεν καταργεί τα στοιχεία από τη λίστα. Για να το κάνετε αυτό, μπορείτε να χρησιμοποιήσετε το `IDatabase.ListLeftPopAsync` και `IDatabase.ListRightPopAsync` μεθόδους.

Για να αποτρέψετε την ανάπτυξη απεριόριστο χρονικό διάστημα στη λίστα, μπορείτε να cull περιοδικά στοιχεία με περικοπή στη λίστα. Αλλά το τμήμα κώδικα παρακάτω σας δείχνει πώς μπορείτε να καταργήσετε όλες τις πέντε πιο αριστερή στοιχείων από τη λίστα:

```csharp
await cache.ListTrimAsync(redisKey, 0, 5);
```

### <a name="implement-a-leader-board"></a>Υλοποίηση πίνακα επικεφαλής

Από προεπιλογή, τα στοιχεία σε ένα σύνολο πραγματοποιούνται δεν με κάποια συγκεκριμένη σειρά. Μπορείτε να δημιουργήσετε μια ταξινομημένη σύνολο, χρησιμοποιώντας την εντολή ZADD (το `IDatabase.SortedSetAdd` μέθοδο στη βιβλιοθήκη StackExchange). Τα στοιχεία έχουν παραγγελθεί, χρησιμοποιώντας μια αριθμητική τιμή που ονομάζεται βαθμολογία, που παρέχεται ως παράμετρο, για να την εντολή.

Το παρακάτω τμήμα κώδικα προσθέτει τον τίτλο της καταχώρησης ιστολογίου μια ταξινομημένη λίστα. Σε αυτό το παράδειγμα, κάθε καταχώρηση ιστολογίου έχει επίσης ένα πεδίο βαθμολογία που περιέχει τη σειρά κατάταξης της καταχώρησης ιστολογίου.

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:post_rankings";
BlogPost blogPost = ...; // Reference to a blog post that has just been rated
await cache.SortedSetAddAsync(redisKey, blogPost.Title, blogpost.Score);
```

Μπορείτε να ανακτήσετε τα οι τίτλοι των καταχωρήσεων ιστολογίου και τη βαθμολογία σε αύξουσα σειρά βαθμολογία, χρησιμοποιώντας το `IDatabase.SortedSetRangeByRankWithScores` μέθοδο:

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(redisKey))
{
    Console.WriteLine(post);
}
```

> [AZURE.NOTE] Η βιβλιοθήκη StackExchange παρέχει επίσης την `IDatabase.SortedSetRangeByRankAsync` μέθοδο, η οποία επιστρέφει τα δεδομένα σε σειρά βαθμολογία, αλλά δεν επιστρέφει τις βαθμολογίες.

Μπορείτε επίσης να ανάκτηση στοιχείων σε φθίνουσα σειρά των βαθμών που είναι και να περιορισμός του αριθμού των στοιχείων που επιστρέφονται, παρέχοντας πρόσθετες παραμέτρους για να το `IDatabase.SortedSetRangeByRankWithScoresAsync` μέθοδο. Το επόμενο παράδειγμα εμφανίζει τους τίτλους και τις επιδόσεις του πρώτων 10 στην κατάταξη ιστολογίου:

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(
                               redisKey, 0, 9, Order.Descending))
{
    Console.WriteLine(post);
}
```

Το επόμενο παράδειγμα χρησιμοποιεί το `IDatabase.SortedSetRangeByScoreWithScoresAsync` μέθοδο, το οποίο μπορείτε να χρησιμοποιήσετε για να περιορίσετε τα στοιχεία που επιστρέφονται με εκείνα που περιλαμβάνονται σε μια δεδομένη βαθμολογία περιοχής:

```csharp
// Blog posts with scores between 5000 and 100000
foreach (var post in await cache.SortedSetRangeByScoreWithScoresAsync(
                               redisKey, 5000, 100000))
{
    Console.WriteLine(post);
}
```

### <a name="message-by-using-channels"></a>Μήνυμα με τη χρήση καναλιών

Εκτός από ενεργεί ως προσωρινής μνήμης δεδομένων, ένα διακομιστή Redis παρέχει ανταλλαγή μηνυμάτων μέσω ενός μηχανισμού υψηλών επιδόσεων publisher/συνδρομητών. Εφαρμογές προγράμματος-πελάτη μπορούν να εγγραφούν σε ένα κανάλι και άλλες εφαρμογές ή υπηρεσίες να δημοσιεύσετε μηνύματα στο κανάλι. Εγγραφή εφαρμογές, στη συνέχεια, θα λάβετε αυτά τα μηνύματα και να επεξεργαστείτε τους.

Redis παρέχει την εντολή ΕΓΓΡΑΦΉ για εφαρμογές προγράμματος-πελάτη για να χρησιμοποιήσετε για να εγγραφείτε για κανάλια. Αυτή η εντολή αναμένει το όνομα του ένα ή περισσότερα κανάλια στην οποία η εφαρμογή θα δεχτεί μηνύματα. Περιλαμβάνει τη βιβλιοθήκη StackExchange το `ISubscription` περιβάλλον, που επιτρέπει σε μια εφαρμογή .NET Framework για να εγγραφείτε και να δημοσιεύσετε σε κανάλια.

Μπορείτε να δημιουργήσετε ένα `ISubscription` αντικειμένου με χρήση του `GetSubscriber` μέθοδο της σύνδεσης με το διακομιστή Redis. Στη συνέχεια, μπορείτε να ακούσετε για τα μηνύματα σε ένα κανάλι, χρησιμοποιώντας το `SubscribeAsync` μέθοδο αυτού του αντικειμένου. Το ακόλουθο παράδειγμα κώδικα δείχνει πώς μπορείτε να εγγραφείτε σε ένα κανάλι με το όνομα "μηνύματα: blogPosts":

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
await subscriber.SubscribeAsync("messages:blogPosts", (channel, message) =>
{
    Console.WriteLine("Title is: {0}", message);
});
```

Η πρώτη παράμετρος για να το `Subscribe` μέθοδος είναι το όνομα του καναλιού. Αυτό το όνομα ακολουθεί τις ίδιες συμβάσεις που χρησιμοποιούνται από αριθμούς-κλειδιά στο cache. Το όνομα μπορεί να περιέχει δυαδικά δεδομένα, παρόλο που συνιστάται να χρησιμοποιήσετε σχετικά μικρή, χαρακτηριστικό συμβολοσειρές ώστε να εξασφαλίζεται ότι καλές επιδόσεις και συντήρησης.

Σημειώστε επίσης ότι χώρου ονομάτων που χρησιμοποιείται από τα κανάλια είναι ξεχωριστό από που χρησιμοποιούνται από αριθμούς-κλειδιά. Αυτό σημαίνει ότι μπορείτε να έχετε καναλιών και τα πλήκτρα που έχουν το ίδιο όνομα, παρόλο που αυτό μπορεί να κάνει πιο δύσκολο για να διατηρήσετε κώδικα της εφαρμογής σας.

Η δεύτερη παράμετρος είναι μια ενέργεια πληρεξούσιος. Ο πληρεξούσιος ασύγχρονα εκτελείται κάθε φορά που εμφανίζεται ένα νέο μήνυμα στο κανάλι. Αυτό το παράδειγμα εμφανίζει απλώς το μήνυμα στην Κονσόλα (το μήνυμα θα περιέχει τον τίτλο της καταχώρησης ιστολογίου).

Για να δημοσιεύσετε ένα κανάλι, μια εφαρμογή μπορεί να χρησιμοποιήσετε την εντολή Redis ΔΗΜΟΣΊΕΥΣΗ. Η βιβλιοθήκη StackExchange παρέχει το `IServer.PublishAsync` μέθοδο για να εκτελέσετε αυτήν τη λειτουργία. Το επόμενο τμήμα κώδικα δείχνει πώς μπορείτε να δημοσιεύσετε ένα μήνυμα στο κανάλι "μηνύματα: blogPosts":

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
BlogPost blogpost = ...;
subscriber.PublishAsync("messages:blogPosts", blogPost.Title);
```

Υπάρχουν πολλά σημεία θα πρέπει να γνωρίζετε σχετικά με το μηχανισμό δημοσίευση/εγγραφή:

- Πολλές συνδρομητές να εγγραφείτε στο ίδιο κανάλι και θα όλα λάβει τα μηνύματα που έχουν δημοσιευτεί σε αυτό το κανάλι.
- Οι συνδρομητές μόνο μηνύματα που έχουν δημοσιευτεί αφού έχετε μια συνδρομή. Κανάλια δεν αποθηκεύονται σε buffer και, μόλις δημοσιευτεί ένα μήνυμα, η υποδομή Redis προωθεί το μήνυμα σε κάθε συνδρομητή και, στη συνέχεια, καταργεί.
- Από προεπιλογή, τα μηνύματα λαμβάνονται από τους συνδρομητές με τη σειρά με την οποία αποστέλλονται. Σε ένα σύστημα ιδιαίτερα ενεργό με μεγάλο αριθμό των μηνυμάτων και πολλά συνδρομητές και εκδότες, εγγυημένη διαδοχικές παράδοσης των μηνυμάτων μπορεί να επιβραδύνει απόδοση του συστήματος. Εάν κάθε μήνυμα είναι ανεξάρτητο και δεν έχει σημασία τη σειρά, μπορείτε να ενεργοποιήσετε την ταυτόχρονη επεξεργασία από το σύστημα Redis, η οποία μπορεί να σας βοηθήσει να βελτιώσετε την ανταπόκριση. Μπορείτε να επιτύχετε αυτό σε έναν υπολογιστή-πελάτη StackExchange, ορίζοντας την PreserveAsyncOrder από τη σύνδεση που χρησιμοποιείται από το συνδρομητή FALSE (ψευδής):

```csharp
ConnectionMultiplexer redisHostConnection = ...;
redisHostConnection.PreserveAsyncOrder = false;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
```

## <a name="related-patterns-and-guidance"></a>Σχετικές μοτίβα και καθοδήγηση

Το παρακάτω μοτίβο μπορεί επίσης να σχετικά με το σενάριό σας όταν εφαρμόζετε σε cache στις εφαρμογές σας:

- [Μοτίβο cache παύσης](http://msdn.microsoft.com/library/dn589799.aspx): αυτό το μοτίβο περιγράφει τον τρόπο για τη φόρτωση των δεδομένων σε ζήτηση στο cache από ένα χώρο αποθήκευσης δεδομένων. Αυτό το μοτίβο βοηθά, επίσης, για να διατηρήσετε τη συνέπεια μεταξύ των δεδομένων που διατηρείται στο cache και τα δεδομένα στο αρχικό χώρου αποθήκευσης δεδομένων.
- Το [μοτίβο Sharding](http://msdn.microsoft.com/library/dn589797.aspx) παρέχει πληροφορίες σχετικά με την εφαρμογή οριζόντια διαμερισμάτων για βελτίωση της κλιμάκωση κατά την αποθήκευση και την πρόσβαση σε μεγάλους όγκους δεδομένων.

## <a name="more-information"></a>Περισσότερες πληροφορίες

- Η σελίδα [κλάσης MemoryCache](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx) στην τοποθεσία Web της Microsoft
- Η σελίδα [Azure Redis Cache τεκμηρίωση](https://azure.microsoft.com/documentation/services/cache/) στην τοποθεσία Web της Microsoft
- [Azure Redis Cache συνήθεις ερωτήσεις για τη](redis-cache/cache-faq.md) σελίδα στην τοποθεσία Web της Microsoft
- Η σελίδα [μοντέλο ρύθμισης παραμέτρων](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx) στην τοποθεσία Web της Microsoft
- Η σελίδα [Βάσει εργασίας ασύγχρονης μοτίβο](http://msdn.microsoft.com/library/hh873175.aspx) στην τοποθεσία Web της Microsoft
- Η σελίδα [αγωγούς και multiplexers](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md) στην τα StackExchange.Redis GitHub repo
- Η σελίδα [Redis διατήρησης](http://redis.io/topics/persistence) στην τοποθεσία Web του Redis
- Η [σελίδα αναπαραγωγής](http://redis.io/topics/replication) στην τοποθεσία Web του Redis
- Η σελίδα [Redis σύμπλεγμα πρόγραμμα εκμάθησης](http://redis.io/topics/cluster-tutorial) στην τοποθεσία Web του Redis
- Το [διαμέριση: Τρόπος για να διαιρέσετε δεδομένα μεταξύ πολλών παρουσιών Redis](http://redis.io/topics/partitioning) σελίδας στην τοποθεσία Web του Redis
- Σελίδα [Με χρήση Redis ως ένα Cache LRU](http://redis.io/topics/lru-cache) στην τοποθεσία Web του Redis
- Η σελίδα [συναλλαγές](http://redis.io/topics/transactions) στην τοποθεσία Web του Redis
- Η σελίδα [Redis ασφαλείας](http://redis.io/topics/security) στην τοποθεσία Web του Redis
- Η σελίδα [δύο γύρω από το Azure Redis Cache](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) στο ιστολόγιο του Azure
- Η σελίδα [Εκτελείται Redis σε μια Εικονική Linux CentOS στα Azure](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) στην τοποθεσία Web της Microsoft
- Τη σελίδα [ASP.NET περιόδου λειτουργίας κατάσταση υπηρεσίας παροχής για Azure Redis Cache](redis-cache/cache-aspnet-session-state-provider.md) στην τοποθεσία Web της Microsoft
- Σελίδα [ASP.NET εξόδου cache υπηρεσία παροχής που χρησιμοποιείτε για το Azure Redis Cache](redis-cache/cache-aspnet-output-cache-provider.md) στην τοποθεσία Web της Microsoft
- Η σελίδα [Μια εισαγωγή στις Redis τύπους δεδομένων και αντλήσεις](http://redis.io/topics/data-types-intro) στην τοποθεσία Web του Redis
- Σελίδα [βασικές χρήση](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md) στην τοποθεσία Web του StackExchange.Redis
- Η σελίδα [συναλλαγών σε Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Transactions.md) στην το repo StackExchange.Redis
- Ο [Οδηγός δημιουργίας διαμερισμάτων δεδομένων](http://msdn.microsoft.com/library/dn589795.aspx) στην τοποθεσία Web της Microsoft
