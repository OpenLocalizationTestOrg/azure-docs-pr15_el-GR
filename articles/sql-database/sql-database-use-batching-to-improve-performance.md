 <properties
    pageTitle="Πώς μπορείτε να χρησιμοποιήσετε δέσμης για βελτίωση της απόδοσης εφαρμογής βάσης δεδομένων SQL Azure"
    description="Το θέμα παρέχει αποδείξεις που διαδικασίας δέσμης λειτουργίες της βάσης δεδομένων σε μεγάλο βαθμό imroves της ταχύτητας και κλιμάκωση με τις εφαρμογές σας βάση δεδομένων SQL Azure. Παρόλο που λειτουργούν αυτές οι διαδικασίας δέσμης τεχνικές για οποιαδήποτε βάση δεδομένων SQL Server, η εστίαση αυτού του άρθρου είναι σε Azure."
    services="sql-database"
    documentationCenter="na"
    authors="annemill"
    manager="jhubbard"
    editor="" />


<tags
    ms.service="sql-database"
    ms.devlang="na"
    ms.topic="article"
    ms.tgt_pltfrm="na"
    ms.workload="data-management"
    ms.date="07/12/2016"
    ms.author="annemill" />

# <a name="how-to-use-batching-to-improve-sql-database-application-performance"></a>Πώς μπορείτε να χρησιμοποιήσετε δέσμης για βελτίωση της απόδοσης εφαρμογής βάσης δεδομένων SQL

Σημαντικά δέσμης για λειτουργίες με βάση δεδομένων SQL Azure βελτιώνει τις επιδόσεις και κλιμάκωση με τις εφαρμογές σας. Προκειμένου να κατανοήσετε τα πλεονεκτήματα, το πρώτο τμήμα του σε αυτό το άρθρο περιγράφει ορισμένες αποτελέσματα δοκιμής δείγμα που συγκρίνουν διαδοχικές και μαζικής αιτήσεων σε μια βάση δεδομένων SQL. Το υπόλοιπο του άρθρου εμφανίζει το τεχνικές σενάρια και θέματα που πρέπει να σας βοηθήσει να χρησιμοποιήσετε με επιτυχία δέσμης στις εφαρμογές σας Azure.

**Οι συντάκτες**: Jason Roth, Silvano Coriani, Trent Swanson (επίσης πλήρους κλίμακας 180)

**Οι αναθεωρητές**: Conor Cunningham, Michael Thomassy

## <a name="why-is-batching-important-for-sql-database"></a>Γιατί είναι δέσμης για σημαντικές για βάση δεδομένων SQL;
Δέσμης για κλήσεις σε μια υπηρεσία remote είναι μια γνωστή στρατηγική για την αύξηση της επιδόσεις και κλιμάκωση. Είναι το σταθερό κόστος επεξεργασίας σε οποιαδήποτε αλληλεπιδράσεις με μια απομακρυσμένη υπηρεσία, όπως σειριοποίησης, μεταφορά δικτύου και αποσειριοποίησης. Συσκευασία πόσες συναλλαγές ξεχωριστά σε μία δέσμη ελαχιστοποιεί αυτά τα κόστη.

Σε αυτό το έγγραφο, θέλουμε να εξετάσετε διάφορες βάση δεδομένων SQL δέσμης στρατηγικές και σενάρια. Παρόλο που αυτές τις στρατηγικές είναι επίσης σημαντικό για εφαρμογές εσωτερικής εγκατάστασης που χρησιμοποιούν SQL Server, υπάρχουν πολλοί λόγοι για την επισήμανση της χρήσης της δέσμης για βάση δεδομένων SQL:

- Υπάρχει πιθανώς μεγαλύτερο λανθάνων χρόνος δικτύου στο πρόσβαση σε βάση δεδομένων SQL, ειδικά εάν έχετε πρόσβαση σε βάση δεδομένων SQL από έξω από το ίδιο κέντρο δεδομένων Microsoft Azure.
- Τα χαρακτηριστικά multitenant της βάσης δεδομένων SQL σημαίνει ότι η απόδοση του το συσχετίζεται επίπεδο πρόσβασης δεδομένων για τη συνολική κλιμάκωση της βάσης δεδομένων. Βάση δεδομένων SQL πρέπει να εμποδίζουν το μονοπωλώντας πόρους βάσεων δεδομένων σε βάρος των άλλων μισθωτές οποιοδήποτε μεμονωμένο μισθωτή/χρήστη. Απάντηση χρήση που υπερβαίνουν τις προκαθορισμένες ορίων, βάση δεδομένων SQL μπορεί να μειώσει την ταχύτητα μετάδοσης ή Απαντήστε με περιορισμού εξαιρέσεις. Βελτίωση της αποτελεσματικότητας, όπως δέσμης, σάς επιτρέπουν να κάνετε περισσότερη εργασία από βάση δεδομένων SQL πριν φτάσει αυτά τα όρια. 
- Δέσμης είναι επίσης αποτελεσματική για αρχιτεκτονικές που χρησιμοποιούν πολλά βάσεων δεδομένων (sharding). Η απόδοση της αλληλεπίδρασης με κάθε μονάδας βάσης δεδομένων εξακολουθεί να είναι κλειδιού παράγοντα για τις συνολικές δυνατότητες κλιμάκωσης. 

Ένα από τα οφέλη της χρήσης της βάσης δεδομένων SQL είναι ότι δεν χρειάζεται να διαχειριστείτε τους διακομιστές που φιλοξενούν τη βάση δεδομένων. Ωστόσο, αυτήν την υποδομή διαχειριζόμενων σημαίνει επίσης ότι πρέπει να σκεφτείτε διαφορετικά βελτιστοποιήσεις βάσης δεδομένων. Μπορείτε πλέον να δείτε για να βελτιώσετε την υποδομή δικτύου ή υλικού βάσης δεδομένων. Στοιχεία ελέγχου Microsoft Azure αυτά τα περιβάλλοντα. Στην περιοχή κύριου που μπορείτε να ελέγξετε είναι πώς η εφαρμογή σας αλληλεπιδρά με βάση δεδομένων SQL. Δέσμης είναι μία από αυτές τις βελτιστοποιήσεις. 

Το πρώτο τμήμα του χαρτιού εξετάζει διάφορες τεχνικές διαδικασίας δέσμης για εφαρμογές .NET που χρησιμοποιούν τη βάση δεδομένων SQL. Τα τελευταία δύο ενότητες καλύπτει διαδικασίας δέσμης γενικές οδηγίες και σενάρια.

## <a name="batching-strategies"></a>Στρατηγικές δέσμης

### <a name="note-about-timing-results-in-this-topic"></a>Σημείωση σχετικά με τα αποτελέσματα χρονισμό σε αυτό το θέμα
>[AZURE.NOTE] Τα αποτελέσματα δεν είναι σημεία αναφοράς αλλά προορίζονται για την εμφάνιση **σχετικών απόδοσης**. Χρονισμών βασίζονται σε μέσο όρο τουλάχιστον 10 εκτελείται δοκιμής. Οι λειτουργίες είναι εισάγει σε έναν κενό πίνακα. Αυτές οι δοκιμές έχουν μετράται προ-V12 και όχι απαραίτητα αντιστοιχούν μετάδοσης που ενδέχεται να αντιμετωπίσετε σε μια βάση δεδομένων V12 χρησιμοποιώντας τη νέα [επίπεδα υπηρεσίας](sql-database-service-tiers.md). Η σχετική πλεονέκτημα της διαδικασίας δέσμης την τεχνική πρέπει να είναι παρόμοια.

### <a name="transactions"></a>Συναλλαγές
Φαίνεται ασυνήθιστο για να ξεκινήσετε μια αναθεώρηση της δέσμης, συζητάτε συναλλαγές. Αλλά τη χρήση των συναλλαγών πλευρά του προγράμματος-πελάτη έχει μια διακριτική εφέ διαδικασίας δέσμης ενεργειών του διακομιστή που βελτιώνει τις επιδόσεις. Και συναλλαγές μπορούν να προστεθούν με μόνο μερικές γραμμές κώδικα, ώστε να παρέχουν ένα γρήγορο τρόπο για να βελτιώσετε την απόδοση των διαδοχικών εργασιών.

Λάβετε υπόψη τα παρακάτω C# κώδικα που περιέχει μια ακολουθία εισαγωγή και ενημέρωση εργασιών σε ένα απλό πίνακα.

    List<string> dbOperations = new List<string>();
    dbOperations.Add("update MyTable set mytext = 'updated text' where id = 1");
    dbOperations.Add("update MyTable set mytext = 'updated text' where id = 2");
    dbOperations.Add("update MyTable set mytext = 'updated text' where id = 3");
    dbOperations.Add("insert MyTable values ('new value',1)");
    dbOperations.Add("insert MyTable values ('new value',2)");
    dbOperations.Add("insert MyTable values ('new value',3)");

Ο ακόλουθος κώδικας ADO.NET εκτελεί διαδοχικά αυτές τις λειτουργίες.

    using (SqlConnection connection = new SqlConnection(CloudConfigurationManager.GetSetting("Sql.ConnectionString")))
    {
        conn.Open();
    
        foreach(string commandString in dbOperations)
        {
            SqlCommand cmd = new SqlCommand(commandString, conn);
            cmd.ExecuteNonQuery();                   
        }
    }

Είναι ο καλύτερος τρόπος για να βελτιστοποιήσετε αυτόν τον κωδικό για την υλοποίηση κάποια μορφή δέσμης πλευρά του προγράμματος-πελάτη για αυτές τις κλήσεις. Αλλά υπάρχει ένας απλός τρόπος για να αυξήσετε την απόδοση του αυτόν τον κωδικό με αναδίπλωση απλώς την ακολουθία των κλήσεων σε μια συναλλαγή. Παρακάτω θα δείτε τον ίδιο κωδικό που χρησιμοποιεί μια συναλλαγή.

    using (SqlConnection connection = new SqlConnection(CloudConfigurationManager.GetSetting("Sql.ConnectionString")))
    {
        conn.Open();
        SqlTransaction transaction = conn.BeginTransaction();
    
        foreach (string commandString in dbOperations)
        {
            SqlCommand cmd = new SqlCommand(commandString, conn, transaction);
            cmd.ExecuteNonQuery();
        }
    
        transaction.Commit();
    }

Συναλλαγές που χρησιμοποιούνται στην πραγματικότητα τόσο από αυτά τα παραδείγματα. Στο πρώτο παράδειγμα, κάθε μεμονωμένα κλήσης είναι μια μη ρητή συναλλαγή. Στο δεύτερο παράδειγμα, μια ρητή συναλλαγή αναδιπλώνεται όλες τις κλήσεις. Ανά την τεκμηρίωση για την [εγγραφή-ahead αρχείο καταγραφής συναλλαγών](https://msdn.microsoft.com/library/ms186259.aspx), εγγραφές καταγραφής γίνεται η εκκαθάριση στο δίσκο όταν η συναλλαγή δεσμεύεται. Επομένως, συμπεριλαμβανομένων των περισσότερων κλήσεων σε μια συναλλαγή, η εγγραφή στο αρχείο καταγραφής συναλλαγών μπορεί να καθυστερήσει μέχρι της συναλλαγής. Στην πραγματικότητα, ενεργοποιείτε δέσμης για οι εγγραφές καταγραφής συναλλαγών του διακομιστή.

Ο παρακάτω πίνακας δείχνει ορισμένα αποτελέσματα δοκιμής ad-hoc. Τους ελέγχους που εκτελείται το ίδιο διαδοχικές εισάγεται με και χωρίς συναλλαγές. Για περισσότερες προοπτική, το πρώτο σύνολο των δοκιμών που εκτελέσατε το από απόσταση από έναν φορητό υπολογιστή στη βάση δεδομένων στο Microsoft Azure. Το δεύτερο σύνολο των δοκιμών που εκτελέστηκε από μια υπηρεσία στο cloud και βάση δεδομένων που βρίσκονται μέσα σε το ίδιο κέντρο δεδομένων Microsoft Azure (Δυτική η.π.α.). Ο παρακάτω πίνακας εμφανίζει τη διάρκεια σε χιλιοστά του δευτερολέπτου από διαδοχικές εισάγεται με και χωρίς συναλλαγές.

**Εσωτερικής εγκατάστασης για να Azure**:

| Λειτουργίες | Κίνηση (ms) | Συναλλαγών (ms) |
|---|---|---|
| 1 | 130 | 402 |
| 10 | αριθ | 1226 |
| 100 | 12662 | 10395 |
| 1000 | 128852 | 102917 |


**Azure να Azure (ίδια κέντρο δεδομένων)**:

| Λειτουργίες | Κίνηση (ms) | Συναλλαγών (ms) |
|---|---|---|
| 1 | 21 | 26 |
| 10 | 220 | 56 |
| 100 | 2145 | 341 |
| 1000 | 21479 | 2756 |

>[AZURE.NOTE] Αποτελέσματα δεν είναι σημεία αναφοράς. Δείτε τη [Σημείωση σχετικά με το χρονισμό αποτελέσματα σε αυτό το θέμα](#note-about-timing-results-in-this-topic).

Με βάση τα προηγούμενα αποτελέσματα δοκιμής, στην πραγματικότητα αναδίπλωση μία λειτουργία σε μια συναλλαγή μειώνει επιδόσεων. Αλλά καθώς αυξάνετε τον αριθμό των λειτουργιών μέσα σε μία συναλλαγή, γίνεται πιο σήμανση τη βελτίωση των επιδόσεων. Η διαφορά απόδοσης είναι πιο εμφανών επίσης όταν όλες οι λειτουργίες που εκτελούνται εντός του κέντρου δεδομένων του Microsoft Azure. Η αυξημένη λανθάνων χρόνος της χρήσης βάσης δεδομένων SQL από έξω από το κέντρο δεδομένων Microsoft Azure επισκιάζει το κέρδος απόδοσης της χρήσης συναλλαγές.

Αν και η χρήση των συναλλαγών μπορεί να αυξήσετε την απόδοση, συνεχίστε να [παρακολουθήσετε βέλτιστες πρακτικές για συναλλαγές και συνδέσεις](https://msdn.microsoft.com/library/ms187484.aspx). Διατήρηση της όσο το δυνατόν βραχεία συναλλαγής και κλείστε τη σύνδεση βάσης δεδομένων μετά την ολοκλήρωση της εργασίας. Η χρήση δήλωση στο προηγούμενο παράδειγμα διασφαλίζει ότι η σύνδεση είναι κλειστή, όταν ολοκληρωθεί το μπλοκ οι επόμενες κώδικα.

Το προηγούμενο παράδειγμα δείχνει ότι μπορείτε να προσθέσετε μια τοπική συναλλαγή οποιονδήποτε κωδικό ADO.NET με δύο γραμμές. Συναλλαγές προσφέρουν ένα γρήγορο τρόπο για να βελτιώσετε την απόδοση του κώδικα που κάνει διαδοχική εισαγωγή, ενημέρωση και διαγραφή λειτουργίες. Ωστόσο, για τις καλύτερες επιδόσεις, μπορείτε να αλλάξετε τον κωδικό μετά επωφεληθείτε από την πλευρά του προγράμματος-πελάτη δέσμης, όπως οι παράμετροι με πίνακα τιμών.

Για περισσότερες πληροφορίες σχετικά με τις συναλλαγές ADO.NET, ανατρέξτε στο θέμα [Τοπικό συναλλαγών σε ADO.NET](https://msdn.microsoft.com/library/vstudio/2k2hy99x.aspx).

### <a name="table-valued-parameters"></a>Παράμετροι με πίνακα τιμών
Παράμετροι με πίνακα τιμών υποστηρίζουν τύπους πίνακα που ορίζονται από το χρήστη ως παράμετροι στην προτάσεις Transact-SQL, αποθηκευμένες διαδικασίες και συναρτήσεις. Αυτήν την πλευρά του προγράμματος-πελάτη διαδικασίας δέσμης τεχνική σάς επιτρέπει να στέλνετε πολλές γραμμές δεδομένων εντός της παραμέτρου με πίνακα τιμών. Για να χρησιμοποιήσετε τις παραμέτρους με πίνακα τιμών, πρέπει πρώτα να ορίσετε έναν τύπο πίνακα. Η ακόλουθη πρόταση Transact-SQL δημιουργεί έναν τύπο πίνακα με το όνομα **MyTableType**.

    CREATE TYPE MyTableType AS TABLE 
    ( mytext TEXT,
      num INT );
 

Στον κώδικα, μπορείτε να δημιουργήσετε ένα **DataTable** με τα ακριβή ίδια ονόματα και οι τύποι του τύπου πίνακα. Εισάγετε αυτό το **DataTable** μια παράμετρο σε ένα ερώτημα κείμενο ή την αποθηκευμένη διαδικασία κλήσης. Το παρακάτω παράδειγμα εμφανίζει αυτήν την τεχνική:

    using (SqlConnection connection = new SqlConnection(CloudConfigurationManager.GetSetting("Sql.ConnectionString")))
    {
        connection.Open();
    
        DataTable table = new DataTable();
        // Add columns and rows. The following is a simple example.
        table.Columns.Add("mytext", typeof(string));
        table.Columns.Add("num", typeof(int));    
        for (var i = 0; i < 10; i++)
        {
            table.Rows.Add(DateTime.Now.ToString(), DateTime.Now.Millisecond);
        }
    
        SqlCommand cmd = new SqlCommand(
            "INSERT INTO MyTable(mytext, num) SELECT mytext, num FROM @TestTvp",
            connection);
                    
        cmd.Parameters.Add(
            new SqlParameter()
            {
                ParameterName = "@TestTvp",
                SqlDbType = SqlDbType.Structured,
                TypeName = "MyTableType",
                Value = table,
            });
    
        cmd.ExecuteNonQuery();
    }

Στο προηγούμενο παράδειγμα, το αντικείμενο **SqlCommand** εισάγει τις γραμμές από μια παράμετρο με πίνακα τιμών, **@TestTvp**. Το αντικείμενο που δημιουργήσατε προηγουμένως **DataTable** έχει αντιστοιχιστεί σε αυτήν την παράμετρο με τη μέθοδο **SqlCommand.Parameters.Add** . Σημαντικά δέσμης για την εισάγει σε μια κλήση αυξάνει την απόδοση μέσω διαδοχικές εισάγει.

Για να βελτιώσετε περαιτέρω το προηγούμενο παράδειγμα, χρησιμοποιήστε μια αποθηκευμένη διαδικασία αντί για μια εντολή που βασίζεται σε κείμενο. Η παρακάτω εντολή Transact-SQL δημιουργεί μια αποθηκευμένη διαδικασία που λαμβάνει την παράμετρο **SimpleTestTableType** με πίνακα τιμών.

    CREATE PROCEDURE [dbo].[sp_InsertRows] 
    @TestTvp as MyTableType READONLY
    AS
    BEGIN
    INSERT INTO MyTable(mytext, num) 
    SELECT mytext, num FROM @TestTvp
    END
    GO

Στη συνέχεια, αλλάξτε τη δήλωση αντικειμένου **SqlCommand** στο προηγούμενο παράδειγμα κώδικα με το εξής.

    SqlCommand cmd = new SqlCommand("sp_InsertRows", connection);
    cmd.CommandType = CommandType.StoredProcedure;

Στις περισσότερες περιπτώσεις, οι παράμετροι με πίνακα τιμών έχουν ισοδύναμο ή καλύτερες επιδόσεις από άλλες τεχνικές διαδικασίας δέσμης. Με πίνακα τιμών παράμετροι συχνά είναι προτιμότερη, επειδή είναι πιο ευέλικτη από άλλες επιλογές. Για παράδειγμα, άλλες τεχνικές, όπως το αντίγραφο μαζικής SQL, μόνο επιτρέπουν την εισαγωγή νέων γραμμών. Αλλά με παραμέτρους με πίνακα τιμών, μπορείτε να χρησιμοποιήσετε λογικής της αποθηκευμένης διαδικασίας για να καθορίσει ποιες σειρές ενημερώσεις και που είναι εισάγει. Ο τύπος πίνακα μπορεί να τροποποιηθεί επίσης να περιέχει μια στήλη "Η λειτουργία" που υποδεικνύει εάν τη συγκεκριμένη γραμμή θα πρέπει να είναι που έχει εισαχθεί, ενημέρωση ή διαγραφεί.

Ο παρακάτω πίνακας εμφανίζει τα αποτελέσματα δοκιμής ad-hoc για τη χρήση των παραμέτρων με πίνακα τιμών σε χιλιοστά του δευτερολέπτου.

| Λειτουργίες | Εσωτερικής εγκατάστασης για να Azure (ms)  | Azure ίδιο κέντρο δεδομένων (ms) |
|---|---|---|
| 1 | 124 | 32 |
| 10 | 131 | 25 |
| 100 | 338 | 51 |
| 1000 | 2615 | 382 |
| 10000 | 23830 | 3586 |

>[AZURE.NOTE] Αποτελέσματα δεν είναι σημεία αναφοράς. Δείτε τη [Σημείωση σχετικά με το χρονισμό αποτελέσματα σε αυτό το θέμα](#note-about-timing-results-in-this-topic).

Το κέρδος απόδοσης από δέσμης είναι εμφανή αμέσως. Στην προηγούμενη διαδοχική δοκιμή, λειτουργίες 1000 εκτελέσατε 129 δευτερόλεπτα έξω από το κέντρο δεδομένων και 21 δευτερολέπτων από μέσα του κέντρου δεδομένων. Αλλά με παραμέτρους με πίνακα τιμών, λειτουργίες 1000 διαρκέσει μόνο 2.6 δευτερόλεπτα έξω από το κέντρο δεδομένων και 0,4 δευτερόλεπτα εντός του κέντρου δεδομένων.

Για περισσότερες πληροφορίες σχετικά με τις παραμέτρους με πίνακα τιμών, ανατρέξτε στο θέμα [Table-Valued παράμετροι](https://msdn.microsoft.com/library/bb510489.aspx).

### <a name="sql-bulk-copy"></a>Αντιγραφή μαζικής SQL
Αντιγραφή μαζικής SQL είναι ένας άλλος τρόπος για να εισαγάγετε μεγάλες ποσότητες δεδομένων σε μια βάση δεδομένων προορισμού. Εφαρμογές .NET μπορούν να χρησιμοποιήσουν την κλάση **SqlBulkCopy** για να εκτελέσετε λειτουργίες μαζικής εισαγωγής. **SqlBulkCopy** είναι παρόμοια σε συνάρτηση με το εργαλείο γραμμής εντολών, **Bcp.exe**ή η πρόταση Transact-SQL, **ΜΑΖΙΚΉ εισαγωγή**. Το ακόλουθο παράδειγμα κώδικα δείχνει τον τρόπο για τη μαζική αντιγραφή των γραμμών στο αρχείο προέλευσης **DataTable**, πίνακα, στον πίνακα προορισμού στον SQL Server, πίνακας.

    using (SqlConnection connection = new SqlConnection(CloudConfigurationManager.GetSetting("Sql.ConnectionString")))
    {
        connection.Open();
    
        using (SqlBulkCopy bulkCopy = new SqlBulkCopy(connection))
        {
            bulkCopy.DestinationTableName = "MyTable";
            bulkCopy.ColumnMappings.Add("mytext", "mytext");
            bulkCopy.ColumnMappings.Add("num", "num");
            bulkCopy.WriteToServer(table);
        }
    }

Υπάρχουν ορισμένες περιπτώσεις όπου μαζική αντιγραφή είναι προτιμώμενη επάνω από τις παραμέτρους με πίνακα τιμών. Ανατρέξτε στον πίνακα σύγκρισης των παραμέτρων με πίνακα τιμών έναντι ΜΑΖΙΚΉ εισαγωγή λειτουργίες στο θέμα [Table-Valued παράμετροι](https://msdn.microsoft.com/library/bb510489.aspx).

Τα ακόλουθα αποτελέσματα δοκιμής ad-hoc εμφανίζουν τις επιδόσεις της δέσμης με **SqlBulkCopy** σε χιλιοστά του δευτερολέπτου.

| Λειτουργίες | Εσωτερικής εγκατάστασης για να Azure (ms)  | Azure ίδιο κέντρο δεδομένων (ms) |
|---|---|---|
| 1 | 433 | 57 |
| 10 | 441 | 32 |
| 100 | 636 | 53 |
| 1000 | 2535 | 341 |
| 10000 | 21605 | 2737 |

>[AZURE.NOTE] Αποτελέσματα δεν είναι σημεία αναφοράς. Δείτε τη [Σημείωση σχετικά με το χρονισμό αποτελέσματα σε αυτό το θέμα](#note-about-timing-results-in-this-topic).

Σε μικρότερα μεγέθη δέσμη, οι παράμετροι με πίνακα τιμών χρήση outperformed την κλάση **SqlBulkCopy** . Ωστόσο, **SqlBulkCopy** που έχει εκτελεστεί 12 – 31% ταχύτερα από με πίνακα τιμών παραμέτρους για τις δοκιμές 1.000 έως 10.000 γραμμών. Όπως με πίνακα τιμών παραμέτρους, **SqlBulkCopy** είναι μια καλή επιλογή για μαζικής εισάγει, ιδίως όταν σε σύγκριση με την απόδοση των μη μαζικής λειτουργιών.

Για περισσότερες πληροφορίες σχετικά με αντιγραφή μαζικής στο ADO.NET, ανατρέξτε στο θέμα [Λειτουργίες αντιγραφής μαζικής στον SQL Server](https://msdn.microsoft.com/library/7ek5da1a.aspx).

### <a name="multiple-row-parameterized-insert-statements"></a>Δηλώσεις με παραμέτρους εισαγωγή πολλών γραμμών
Μια εναλλακτική λύση για μικρές δέσμες είναι να δημιουργήσετε μια μεγάλη πρόταση INSERT με παραμέτρους που εισάγεται με πολλές γραμμές. Το ακόλουθο παράδειγμα κώδικα επιδεικνύει αυτήν την τεχνική.

    using (SqlConnection connection = new SqlConnection(CloudConfigurationManager.GetSetting("Sql.ConnectionString")))
    {
        connection.Open();
    
        string insertCommand = "INSERT INTO [MyTable] ( mytext, num ) " +
            "VALUES (@p1, @p2), (@p3, @p4), (@p5, @p6), (@p7, @p8), (@p9, @p10)";
    
        SqlCommand cmd = new SqlCommand(insertCommand, connection);
    
        for (int i = 1; i <= 10; i += 2)
        {
            cmd.Parameters.Add(new SqlParameter("@p" + i.ToString(), "test"));
            cmd.Parameters.Add(new SqlParameter("@p" + (i+1).ToString(), i));
        }
    
        cmd.ExecuteNonQuery();
    }
 

Αυτό το παράδειγμα προορίζεται για να εμφανίσετε το βασικές έννοιες. Ένα σενάριο πιο ρεαλιστική θα επανάληψη μέσω των απαιτούμενων οντοτήτων για να δημιουργήσετε τη συμβολοσειρά ερωτήματος και τις παραμέτρους εντολής ταυτόχρονα. Είστε υποχρεωμένοι να συνολικά παράμετροι ερωτήματος 2100, αυτό περιορίζει τον συνολικό αριθμό των γραμμών που είναι δυνατή η επεξεργασία με αυτόν τον τρόπο.

Τα ακόλουθα αποτελέσματα δοκιμής ad-hoc εμφανίζουν την εκτέλεση αυτού του τύπου της πρότασης εισαγωγή σε χιλιοστά του δευτερολέπτου.

| Λειτουργίες | Παράμετροι με πίνακα τιμών (ms) | Εισαγωγή μίας πρότασης (ms) |
|---|---|---|
| 1 | 32 | 20 |
| 10 | 30 | 25 |
| 100 | 33 | 51 |

>[AZURE.NOTE] Αποτελέσματα δεν είναι σημεία αναφοράς. Δείτε τη [Σημείωση σχετικά με το χρονισμό αποτελέσματα σε αυτό το θέμα](#note-about-timing-results-in-this-topic).

Αυτή η προσέγγιση μπορεί να είναι λίγο πιο γρήγορες για δέσμες που είναι μικρότερη από 100 γραμμών. Παρόλο που η βελτίωση είναι μικρό, αυτή η τεχνική είναι μια άλλη επιλογή που ενδέχεται να λειτουργούν σωστά στη δική σας περίπτωση συγκεκριμένη εφαρμογή.

### <a name="dataadapter"></a>DataAdapter
Τάξη **DataAdapter** σάς επιτρέπει να τροποποιήσετε ένα αντικείμενο **συνόλου δεδομένων** και, στη συνέχεια, να υποβάλετε τις αλλαγές κατά την εισαγωγή, ΕΝΗΜΈΡΩΣΗ και ΔΙΑΓΡΑΦΉ λειτουργίες. Εάν χρησιμοποιείτε το **DataAdapter** με αυτόν τον τρόπο, είναι σημαντικό να λάβετε υπόψη ότι ξεχωριστή κλήσεις γίνονται για κάθε διακριτές λειτουργία. Για να βελτιώσετε τις επιδόσεις, χρησιμοποιήστε την ιδιότητα **UpdateBatchSize** στον αριθμό των λειτουργιών που θα πρέπει να είναι batched κάθε φορά. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [Εκτέλεση δέσμης λειτουργίες χρησιμοποιώντας DataAdapters](https://msdn.microsoft.com/library/aadf8fk2.aspx).

### <a name="entity-framework"></a>Πλαίσιο οντότητα
Πλαίσιο οντότητα δεν υποστηρίζει τη συγκεκριμένη στιγμή δέσμης. Επιχειρήσατε διαφορετικούς προγραμματιστές στην Κοινότητα για μια επίδειξη λύσεις, όπως η παράκαμψη της μεθόδου **SaveChanges** . Αλλά οι λύσεις είναι συνήθως σύνθετη και προσαρμοσμένων για την εφαρμογή και μοντέλο δεδομένων. Το έργο codeplex Framework οντότητα έχει αυτήν τη στιγμή μια σελίδα συζητήσεων σε αυτήν τη δυνατότητα αίτησης. Για να εμφανίσετε αυτήν τη συζήτηση, ανατρέξτε στο θέμα [Σχεδίαση σημειώσεις σύσκεψης – 2 Αυγούστου 2012](http://entityframework.codeplex.com/wikipage?title=Design%20Meeting%20Notes%20-%20August%202%2c%202012).

### <a name="xml"></a>XML
Για λόγους πληρότητας, θα σας αισθάνεστε ότι είναι σημαντικό να αναφερθούμε XML ως μιας διαδικασίας δέσμης στρατηγικής. Ωστόσο, η χρήση της XML έχει χωρίς πλεονεκτήματα σε σύγκριση με άλλες μεθόδους και διάφορα μειονεκτήματα. Η προσέγγιση είναι παρόμοια με τις παραμέτρους με πίνακα τιμών, αλλά ένα αρχείο XML ή μια συμβολοσειρά που του μεταβιβάστηκε μια αποθηκευμένη διαδικασία αντί για έναν πίνακα που ορίζονται από το χρήστη. Αποθηκευμένη διαδικασία αναλύει τις εντολές της αποθηκευμένης διαδικασίας.

Υπάρχουν διάφορα μειονεκτήματα αυτής της προσέγγισης:

- Εργασία με XML μπορεί να είναι εύκολα και σφάλματα.
- Ανάλυση του XML από τη βάση δεδομένων μπορεί να είναι υπολογιστική.
- Στις περισσότερες περιπτώσεις, αυτή η μέθοδος είναι μικρότερη από παραμέτρους με πίνακα τιμών.

Για αυτούς τους λόγους, δεν συνιστάται η χρήση της XML για ερωτήματα δέσμης.

## <a name="batching-considerations"></a>Δέσμης για ζητήματα
Οι παρακάτω ενότητες παρέχουν περισσότερες οδηγίες για τη χρήση της δέσμης σε εφαρμογές της βάσης δεδομένων SQL.

### <a name="tradeoffs"></a>Ισορροπιών
Ανάλογα με την αρχιτεκτονική, δέσμης μπορούν να περιλαμβάνουν ανταλλαγή μεταξύ επιδόσεις και υποστηρίζεται. Για παράδειγμα, εξετάστε το σενάριο όπου μεταβαίνει απροσδόκητα ο ρόλος σας προς τα κάτω. Εάν χάσετε μία γραμμή δεδομένων, την επίδραση είναι μικρότερη από την επίδραση των να χάσετε μια μεγάλη δέσμη των γραμμών που δεν έχουν υποβληθεί. Υπάρχει ένα μεγαλύτερο κίνδυνο όταν buffer γραμμές πριν από την αποστολή τους στη βάση δεδομένων σε ένα παράθυρο του καθορισμένου χρονικού.

Λόγω αυτό ανταλλαγή, το αποτέλεσμα είναι το είδος των υπηρεσιών που κάνετε μαζική. Μαζική πιο ταχύτητα (μεγαλύτερο δέσμες και περισσότερο χρόνο windows) με δεδομένα που είναι λιγότερο σημαντικά.

### <a name="batch-size"></a>Μέγεθος δέσμης
Δοκιμές μας, σημειώθηκε συνήθως χωρίς πλεονέκτημα διακοπή μεγάλο δέσμες σε μικρότερο μέγεθος μπλοκ. Στην πραγματικότητα, αυτή η υποδιαίρεση συχνά οδήγησε σε πιο αργές επιδόσεις από την υποβολή ενός μεγάλου μαζικά. Για παράδειγμα, εξετάστε το ενδεχόμενο να ένα σενάριο όπου θέλετε να εισαγάγετε 1000 γραμμές. Ο παρακάτω πίνακας εμφανίζει πόσος χρόνος χρειάζεται για να χρησιμοποιήσετε τις παραμέτρους με πίνακα τιμών για την εισαγωγή γραμμών 1000 όταν διαιρεθεί σε δέσμες με μικρότερο μέγεθος.

| Μέγεθος δέσμης | Διαδοχικές προσεγγίσεις | Παράμετροι με πίνακα τιμών (ms) |
| -------- | --- | --- |
| 1000 | 1 | 347 |
| 500 | 2 | 355 |
| 100 | 10 | 465 |
| 50 | 20 | 630 |

>[AZURE.NOTE] Αποτελέσματα δεν είναι σημεία αναφοράς. Δείτε τη [Σημείωση σχετικά με το χρονισμό αποτελέσματα σε αυτό το θέμα](#note-about-timing-results-in-this-topic).

Μπορείτε να δείτε τις καλύτερες επιδόσεις για γραμμές 1000 είναι να υποβάλετε τα όλα ταυτόχρονα. Στις άλλες δοκιμές (δεν εμφανίζεται εδώ) υπήρχε κέρδος μικρές απόδοσης για να διασπάσετε μια δέσμη 10000 γραμμής σε δύο δέσμες 5000. Αλλά τη διάταξη πίνακα για αυτές τις δοκιμές είναι σχετικά απλή, επομένως θα πρέπει να κάνετε δοκιμές σε συγκεκριμένα δεδομένα και μεγέθη δέσμη για να επαληθεύσετε αυτές τις συμπεράσματα.

Ένας άλλος παράγοντας πρέπει να λάβετε υπόψη είναι ότι εάν η συνολική δέσμη γίνει πολύ μεγάλος, βάση δεδομένων SQL ενδέχεται να επιτάχυνσης και να αρνηθεί για να οριστικοποιήσετε τη δέσμη. Για καλύτερα αποτελέσματα, ελέγξτε το συγκεκριμένο σενάριο για να προσδιορίσετε εάν υπάρχει ένα μέγεθος ιδανική δέσμης. Κάντε το μέγεθος δέσμης με δυνατότητα ρύθμισης παραμέτρων κατά το χρόνο εκτέλεσης για να ενεργοποιήσετε την γρήγορη διορθώσεις με βάση τις επιδόσεις ή σφάλματα.

Τέλος, Υπόλοιπο το μέγεθος της δέσμης με τους κινδύνους που σχετίζονται με δέσμης. Εάν υπάρχουν σφάλματα μεταβατικές ή το ρόλο αποτύχει, μπορείτε να τις συνέπειες επιχειρήσετε ξανά τη λειτουργία ή να χάσετε τα δεδομένα στη δέσμη.

### <a name="parallel-processing"></a>Παράλληλες επεξεργασίας
Τι γίνεται εάν εκτελέσατε η προσέγγιση της μείωσης του μεγέθους δέσμης αλλά χρησιμοποιείται πολλά νήματα για την εκτέλεση της εργασίας; Ξανά, τους ελέγχους που εμφάνιζε ότι πολλές μικρότερο πολυνηματική δέσμες συνήθως πραγματοποιείται περισσότερο από το μεγαλύτερο μαζικά. Η ακόλουθη δοκιμή προσπαθεί να εισαγωγή 1000 γραμμών σε μία ή περισσότερες παράλληλες δέσμες. Αυτή η δοκιμή δείχνει πώς περισσότερες ταυτόχρονη δέσμες όντως μειωθεί επιδόσεων.

| Μέγεθος δέσμης [αριθμός διαδοχικών προσεγγίσεων] | Δύο νήματα (ms) | Τέσσερα νήματα (ms) | Έξι νήματα (ms) |
| -------- | --- | --- | --- |
| 1000 [1] | 277 | 315 | 266 |
| 500 [2] | 548 | 278 | 256 |
| 250 [4] | 405 | 329 | 265 |
| 100 [10] | 488 | 439 | 391 |

>[AZURE.NOTE] Αποτελέσματα δεν είναι σημεία αναφοράς. Δείτε τη [Σημείωση σχετικά με το χρονισμό αποτελέσματα σε αυτό το θέμα](#note-about-timing-results-in-this-topic).

Υπάρχουν διάφορες πιθανές αιτίες για την υποβάθμιση των επιδόσεων λόγω παραλληλισμό:

- Υπάρχουν πολλές κλήσεις ταυτόχρονη δικτύου αντί για ένα.
- Πολλές λειτουργίες σε έναν πίνακα μπορεί να οδηγήσει σε διένεξη και αποκλεισμού.
- Υπάρχουν έξοδα που αφορούν πολλαπλών νημάτων.
- Τα έξοδα ανοίγματος πολλές συνδέσεις υπερβαίνει το όφελος των παράλληλες επεξεργασίας.

Εάν το που στοχεύουν σε διαφορετικούς πίνακες ή σε βάσεις δεδομένων, είναι πιθανό να δείτε ορισμένα επιδόσεις του αποκτήσει με αυτή τη στρατηγική. Sharding βάσης δεδομένων ή ομοσπονδίες θα ήταν ένα σενάριο για αυτήν την προσέγγιση. Sharding χρησιμοποιεί πολλαπλές βάσεις δεδομένων και δρομολογεί διαφορετικά δεδομένα για κάθε βάση δεδομένων. Αν πρόκειται κάθε μικρές δέσμη σε διαφορετική βάση δεδομένων, στη συνέχεια, να εκτελούν τις εργασίες παράλληλα μπορεί να είναι πιο αποτελεσματική. Ωστόσο, το κέρδος επιδόσεις δεν είναι αρκετά σημαντικά ώστε να χρησιμοποιήσετε ως βάση για τη λήψη απόφασης για να χρησιμοποιήσετε sharding βάσης δεδομένων στη λύση σας.

Σε ορισμένες σχέδια, παράλληλη εκτέλεση των μικρότερο δέσμες μπορεί να έχει ως αποτέλεσμα βελτιωμένη απόδοση των αιτήσεων σε ένα σύστημα φόρτος. Σε αυτήν την περίπτωση, παρόλο που είναι πιο γρήγορο να επεξεργαστεί μαζικά μεγαλύτερο, επεξεργασίας πολλαπλές δέσμες παράλληλα μπορεί να είναι πιο αποτελεσματική.

Εάν χρησιμοποιείτε παράλληλη εκτέλεση, εξετάστε το ενδεχόμενο να ελέγχει ο μέγιστος αριθμός νήματα εργασίας. Ένα μικρότερο αριθμό ενδέχεται να έχει ως αποτέλεσμα λιγότερο διένεξη και μια ταχύτερη χρόνος εκτέλεσης. Επίσης, μπορείτε να το πρόσθετο φορτίο που αυτό τοποθετεί στη βάση δεδομένων προορισμού σε συνδέσεις και συναλλαγές.

### <a name="related-performance-factors"></a>Παράγοντες επιδόσεων σχετικών
Τυπικές οδηγίες σχετικά με την απόδοση της βάσης δεδομένων επηρεάζει επίσης τις δέσμης. Για παράδειγμα, εισαγάγετε επιδόσεων μειώνεται για πίνακες που έχουν ένα μεγάλο πρωτεύον κλειδί ή πολλές μη συγκεντρωτικών ευρετηρίων.

Εάν με πίνακα τιμών παράμετροι να χρησιμοποιήσετε μια αποθηκευμένη διαδικασία, μπορείτε να χρησιμοποιήσετε την εντολή **SET NOCOUNT ON** στην αρχή της διαδικασίας. Αυτή η δήλωση αποκρύπτει την επιστροφή το πλήθος των γραμμών που επηρεάζεται στη διαδικασία. Ωστόσο, στο μας δοκιμές, τη χρήση του **SET NOCOUNT ON** είτε δεν είχαν επιπτώσεις ή μειώθηκε επιδόσεων. Η διαδικασία δοκιμής που είναι αποθηκευμένα έχει απλή με μια μεμονωμένη **Εισαγωγή** εντολής από την παράμετρο με πίνακα τιμών. Είναι πιθανό ότι πιο σύνθετες αποθηκευμένες διαδικασίες θα επωφεληθούν από αυτήν τη δήλωση. Αλλά δεν λαμβάνεται ως δεδομένο ότι αυτόματη προσθήκη **SET NOCOUNT ON** σας αποθηκευμένη διαδικασία βελτιώνει τις επιδόσεις. Για να κατανοήσετε το εφέ, ελέγξτε την αποθηκευμένη διαδικασία με και χωρίς την πρόταση **SET NOCOUNT ON** .

## <a name="batching-scenarios"></a>Δέσμης για σενάρια
Οι παρακάτω ενότητες περιγράφουν τον τρόπο για να χρησιμοποιήσετε τις παραμέτρους με πίνακα τιμών σε τρία σενάρια εφαρμογής. Το πρώτο σενάριο δείχνει τον τρόπο αποθήκευσης στο buffer και δέσμης για να συνεργαστείτε με άλλους. Το δεύτερο σενάριο βελτιώνει τις επιδόσεις κατά την εκτέλεση λειτουργιών κύριο / λεπτομέρειες σε κλήση μόνο αποθηκευμένη διαδικασία. Το τελικό σενάριο δείχνει πώς μπορείτε να χρησιμοποιήσετε τις παραμέτρους με πίνακα τιμών σε μια λειτουργία "UPSERT".

### <a name="buffering"></a>Αποθήκευση σε buffer
Παρόλο που υπάρχουν ορισμένα σενάρια που αφορούν δέσμης εμφανείς υποψηφίου, υπάρχουν τρία σενάρια που μπορεί να επωφεληθείτε από δέσμης για καθυστερημένη επεξεργασίας. Ωστόσο, Καθυστερημένο επεξεργασίας φέρει επίσης ότι τα δεδομένα θα χαθούν, σε περίπτωση μη αναμενόμενη αποτυχία μεγαλύτερο τον κίνδυνο. Είναι σημαντικό να κατανοήσετε τον κίνδυνο και να λάβετε υπόψη τις συνέπειες.

Για παράδειγμα, εξετάστε το ενδεχόμενο μια εφαρμογή web που παρακολουθεί το ιστορικό περιήγησης κάθε χρήστη. Στην πρόσκληση σε κάθε σελίδα, η εφαρμογή μπορεί να κάνει μια βάση δεδομένων κλήσης για την εγγραφή της προβολής σελίδας του χρήστη. Αλλά υψηλότερες επιδόσεις και κλιμάκωση μπορεί να είναι επίτευξη προσωρινής δραστηριότητες περιήγησης των χρηστών και, στη συνέχεια, στέλνοντας αυτά τα δεδομένα στη βάση δεδομένων σε δέσμες. Μπορείτε να ενεργοποιήσετε την ενημέρωση βάσης δεδομένων κατά το χρόνο που πέρασε ή/και το μέγεθος του buffer. Για παράδειγμα, ένας κανόνας μπορούσατε να καθορίσετε ότι η μαζική επεξεργασία πρέπει να γίνει μετά 20 δευτερόλεπτα ή όταν το buffer φτάσει 1000 στοιχεία.

Το ακόλουθο παράδειγμα κώδικα χρησιμοποιεί [Αντίδρασης επεκτάσεις - λήψης](https://msdn.microsoft.com/data/gg577609) για την επεξεργασία σε buffer συμβάντων που προκύπτουν από ένα εκπαιδευτικό παρακολούθησης. Όταν το buffer συμπληρώνει ή ένας φτάσει χρονικού ορίου, η δέσμη των δεδομένων χρήστη αποστέλλονται στη βάση δεδομένων με μια παράμετρο με πίνακα τιμών.

Η ακόλουθη κλάση NavHistoryData μοντέλα τις λεπτομέρειες της περιήγησης χρήστη. Περιέχει βασικές πληροφορίες, όπως το αναγνωριστικό χρήστη, τη διεύθυνση URL πρόσβαση και την ώρα.

    public class NavHistoryData
    {
        public NavHistoryData(int userId, string url, DateTime accessTime)
        { UserId = userId; URL = url; AccessTime = accessTime; }
        public int UserId { get; set; }
        public string URL { get; set; }
        public DateTime AccessTime { get; set; }
    }

Η κλάση NavHistoryDataMonitor είναι υπεύθυνος για την προσωρινή αποθήκευση των δεδομένων περιήγησης χρήστη στη βάση δεδομένων. Περιέχει μια μέθοδο, RecordUserNavigationEntry, οι οποίες απαντούν με ανύψωση συμβάντος **OnAdded** . Ο ακόλουθος κώδικας εμφανίζει τη λογική κατασκευή που χρησιμοποιεί λήψης για να δημιουργήσετε μια συλλογή παρατηρήσιμα με βάση το συμβάν. Το, στη συνέχεια, στο οποίο έχει εγγραφεί σε αυτήν τη συλλογή παρατηρήσιμα με τη μέθοδο Buffer. Το υπερφόρτωσης Καθορίζει ότι πρέπει να σταλεί buffer κάθε 20 δευτερόλεπτα ή καταχωρήσεις 1000.

    public NavHistoryDataMonitor()
    {
        var observableData =
            Observable.FromEventPattern<NavHistoryDataEventArgs>(this, "OnAdded");
    
        observableData.Buffer(TimeSpan.FromSeconds(20), 1000).Subscribe(Handler);           
    }

Το πρόγραμμα χειρισμού μετατρέπει όλα τα στοιχεία buffered σε έναν τύπο με πίνακα τιμών και, στη συνέχεια, μεταφέρει αυτόν τον τύπο σε μια αποθηκευμένη διαδικασία που επεξεργάζεται τη δέσμη. Ο ακόλουθος κώδικας εμφανίζει τον πλήρη ορισμό για το NavHistoryDataEventArgs και οι κλάσεις NavHistoryDataMonitor.

    public class NavHistoryDataEventArgs : System.EventArgs
    {
        public NavHistoryDataEventArgs(NavHistoryData data) { Data = data; }
        public NavHistoryData Data { get; set; }
    }
    
    public class NavHistoryDataMonitor
    {
        public event EventHandler<NavHistoryDataEventArgs> OnAdded;
    
        public NavHistoryDataMonitor()
        {
            var observableData =
                Observable.FromEventPattern<NavHistoryDataEventArgs>(this, "OnAdded");
    
            observableData.Buffer(TimeSpan.FromSeconds(20), 1000).Subscribe(Handler);           
        }
    
        public void RecordUserNavigationEntry(NavHistoryData data)
        {    
            if (OnAdded != null)
                OnAdded(this, new NavHistoryDataEventArgs(data));
        }
    
        protected void Handler(IList<EventPattern<NavHistoryDataEventArgs>> items)
        {
            DataTable navHistoryBatch = new DataTable("NavigationHistoryBatch");
            navHistoryBatch.Columns.Add("UserId", typeof(int));
            navHistoryBatch.Columns.Add("URL", typeof(string));
            navHistoryBatch.Columns.Add("AccessTime", typeof(DateTime));
            foreach (EventPattern<NavHistoryDataEventArgs> item in items)
            {
                NavHistoryData data = item.EventArgs.Data;
                navHistoryBatch.Rows.Add(data.UserId, data.URL, data.AccessTime);
            }
    
            using (SqlConnection connection = new SqlConnection(CloudConfigurationManager.GetSetting("Sql.ConnectionString")))
            {
                connection.Open();
    
                SqlCommand cmd = new SqlCommand("sp_RecordUserNavigation", connection);
                cmd.CommandType = CommandType.StoredProcedure;
    
                cmd.Parameters.Add(
                    new SqlParameter()
                    {
                        ParameterName = "@NavHistoryBatch",
                        SqlDbType = SqlDbType.Structured,
                        TypeName = "NavigationHistoryTableType",
                        Value = navHistoryBatch,
                    });
    
                cmd.ExecuteNonQuery();
            }
        }
    }

Για να χρησιμοποιήσετε αυτήν την κλάση κάνετε προσωρινή αποθήκευση, την εφαρμογή δημιουργεί ένα στατικό αντικείμενο NavHistoryDataMonitor. Κάθε φορά που ένας χρήστης έχει πρόσβαση σε μια σελίδα, η εφαρμογή καλεί τη μέθοδο NavHistoryDataMonitor.RecordUserNavigationEntry. Η λογική κάνετε προσωρινή αποθήκευση συνεχίζει να αναλάβουν την αποστολή αυτές τις καταχωρήσεις στη βάση δεδομένων σε δέσμες.

### <a name="master-detail"></a>Κύρια λεπτομερειών
Παράμετροι με πίνακα τιμών είναι χρήσιμη για απλές εισαγωγή σενάρια. Ωστόσο, μπορεί να είναι δύσκολη περισσότερες εισάγει δέσμη που αφορούν σε περισσότερους από έναν πίνακα. Το σενάριο "Κύριο/Λεπτομέρειες" είναι ένα καλό παράδειγμα. Ο βασικός πίνακας προσδιορίζει την κύρια οντότητα. Έναν ή περισσότερους πίνακες λεπτομερειών αποθηκεύουν περισσότερα δεδομένα σχετικά με την οντότητα. Σε αυτό το σενάριο, οι σχέσεις εξωτερικού κλειδιού επιβολή τη σχέση των λεπτομερειών σε μια μοναδική κύρια οντότητα. Εξετάστε το ενδεχόμενο μια απλοποιημένη εκδοχή του πίνακα PurchaseOrder και το σχετικό πίνακα OrderDetail. Το παρακάτω Transact-SQL δημιουργεί τον πίνακα PurchaseOrder με τέσσερις στήλες: κωδικός παραγγελίας, OrderDate, CustomerID και κατάστασης.

    CREATE TABLE [dbo].[PurchaseOrder](
    [OrderID] [int] IDENTITY(1,1) NOT NULL,
    [OrderDate] [datetime] NOT NULL,
    [CustomerID] [int] NOT NULL,
    [Status] [nvarchar](50) NOT NULL,
     CONSTRAINT [PrimaryKey_PurchaseOrder] 
    PRIMARY KEY CLUSTERED ( [OrderID] ASC ))

Κάθε παραγγελία περιέχει μία ή περισσότερες αγορές προϊόντων. Αυτές οι πληροφορίες είναι καταγράφονται στον πίνακα PurchaseOrderDetail. Το παρακάτω Transact-SQL δημιουργεί τον πίνακα PurchaseOrderDetail με πέντε στήλες: κωδικός παραγγελίας, OrderDetailID, ProductID, UnitPrice και OrderQty.

    CREATE TABLE [dbo].[PurchaseOrderDetail](
    [OrderID] [int] NOT NULL,
    [OrderDetailID] [int] IDENTITY(1,1) NOT NULL,
    [ProductID] [int] NOT NULL,
    [UnitPrice] [money] NULL,
    [OrderQty] [smallint] NULL,
     CONSTRAINT [PrimaryKey_PurchaseOrderDetail] PRIMARY KEY CLUSTERED 
    ( [OrderID] ASC, [OrderDetailID] ASC ))

Η στήλη Κωδικός παραγγελίας στον πίνακα PurchaseOrderDetail πρέπει να αναφέρεται σε μια σειρά από τον πίνακα PurchaseOrder. Το ακόλουθο ορισμό ενός εξωτερικού κλειδιού επιβάλλει αυτόν τον περιορισμό.

    ALTER TABLE [dbo].[PurchaseOrderDetail]  WITH CHECK ADD 
    CONSTRAINT [FK_OrderID_PurchaseOrder] FOREIGN KEY([OrderID])
    REFERENCES [dbo].[PurchaseOrder] ([OrderID])

Για να χρησιμοποιήσετε τις παραμέτρους με πίνακα τιμών, πρέπει να έχετε έναν τύπο πίνακα που ορίζονται από το χρήστη για κάθε πίνακα προορισμού.

    CREATE TYPE PurchaseOrderTableType AS TABLE 
    ( OrderID INT,
      OrderDate DATETIME,
      CustomerID INT,
      Status NVARCHAR(50) );
    GO
    
    CREATE TYPE PurchaseOrderDetailTableType AS TABLE 
    ( OrderID INT,
      ProductID INT,
      UnitPrice MONEY,
      OrderQty SMALLINT );
    GO

Στη συνέχεια, ορίστε μια αποθηκευμένη διαδικασία που δέχεται πίνακες από αυτούς τους τύπους. Αυτή η διαδικασία επιτρέπει σε μια εφαρμογή για μαζική τοπικά ένα σύνολο παραγγελίες και λεπτομέρειες παραγγελίας σε μία κλήση. Το παρακάτω Transact-SQL παρέχει τη δήλωση ολοκλήρωσης αποθηκευμένη διαδικασία για αυτό το παράδειγμα παραγγελίας αγοράς.

    CREATE PROCEDURE sp_InsertOrdersBatch (
    @orders as PurchaseOrderTableType READONLY,
    @details as PurchaseOrderDetailTableType READONLY )
    AS
    SET NOCOUNT ON;
    
    -- Table that connects the order identifiers in the @orders
    -- table with the actual order identifiers in the PurchaseOrder table
    DECLARE @IdentityLink AS TABLE ( 
    SubmittedKey int, 
    ActualKey int, 
    RowNumber int identity(1,1)
    );
     
          -- Add new orders to the PurchaseOrder table, storing the actual
    -- order identifiers in the @IdentityLink table   
    INSERT INTO PurchaseOrder ([OrderDate], [CustomerID], [Status])
    OUTPUT inserted.OrderID INTO @IdentityLink (ActualKey)
    SELECT [OrderDate], [CustomerID], [Status] FROM @orders ORDER BY OrderID;
    
    -- Match the passed-in order identifiers with the actual identifiers
    -- and complete the @IdentityLink table for use with inserting the details
    WITH OrderedRows As (
    SELECT OrderID, ROW_NUMBER () OVER (ORDER BY OrderID) As RowNumber 
    FROM @orders
    )
    UPDATE @IdentityLink SET SubmittedKey = M.OrderID
    FROM @IdentityLink L JOIN OrderedRows M ON L.RowNumber = M.RowNumber;
    
    -- Insert the order details into the PurchaseOrderDetail table, 
          -- using the actual order identifiers of the master table, PurchaseOrder
    INSERT INTO PurchaseOrderDetail (
    [OrderID],
    [ProductID],
    [UnitPrice],
    [OrderQty] )
    SELECT L.ActualKey, D.ProductID, D.UnitPrice, D.OrderQty
    FROM @details D
    JOIN @IdentityLink L ON L.SubmittedKey = D.OrderID;
    GO

Σε αυτό το παράδειγμα, τα τοπικά καθορισμένο @IdentityLink πίνακας αποθηκεύει τις πραγματικές τιμές OrderID από τις γραμμές που έχουν εισαχθεί πρόσφατα. Αυτά τα αναγνωριστικά σειρά διαφέρουν από τις προσωρινό τιμές OrderID το @orders και @details παράμετροι με πίνακα τιμών. Για αυτόν το λόγο, η @IdentityLink πίνακα στη συνέχεια, συνδέεται τις τιμές OrderID από το @orders παραμέτρου το πραγματικό OrderID τιμές για τις νέες γραμμές στον πίνακα PurchaseOrder. Μετά από αυτό το βήμα, το @IdentityLink πίνακα μπορούν να διευκολύνουν εισάγοντας τις λεπτομέρειες της σειράς με την πραγματική κωδικός παραγγελίας που ικανοποιεί ο περιορισμός εξωτερικού κλειδιού.

Αυτή η αποθηκευμένη διαδικασία μπορεί να χρησιμοποιηθεί από κώδικα ή από άλλες κλήσεις Transact-SQL. Ανατρέξτε στην ενότητα με πίνακα τιμών παραμέτρους αυτού του εγγράφου για ένα παράδειγμα κώδικα. Το παρακάτω Transact-SQL δείχνει πώς μπορείτε να καλέσετε το sp_InsertOrdersBatch.

    declare @orders as PurchaseOrderTableType
    declare @details as PurchaseOrderDetailTableType
    
    INSERT @orders 
    ([OrderID], [OrderDate], [CustomerID], [Status])
    VALUES(1, '1/1/2013', 1125, 'Complete'),
    (2, '1/13/2013', 348, 'Processing'),
    (3, '1/12/2013', 2504, 'Shipped')
    
    INSERT @details
    ([OrderID], [ProductID], [UnitPrice], [OrderQty])
    VALUES(1, 10, $11.50, 1),
    (1, 12, $1.58, 1),
    (2, 23, $2.57, 2),
    (3, 4, $10.00, 1)
    
    exec sp_InsertOrdersBatch @orders, @details

Αυτή η λύση επιτρέπει κάθε δέσμη για να χρησιμοποιήσετε ένα σύνολο τιμών κωδικός παραγγελίας που αρχίζουν από 1. Αυτές οι τιμές OrderID προσωρινό περιγράφουν τις σχέσεις στη δέσμη, αλλά τις πραγματικές τιμές OrderID καθορίζονται κατά τη διάρκεια του τη λειτουργία εισαγωγής. Μπορείτε να εκτελέσετε επανειλημμένα τις ίδιες προτάσεις στο προηγούμενο παράδειγμα και να δημιουργήσετε μοναδικά παραγγελίες στη βάση δεδομένων. Για αυτόν το λόγο, εξετάστε το ενδεχόμενο Προσθήκη περισσότερων λογικής κώδικα ή βάση δεδομένων που αποτρέπει διπλότυπων παραγγελίες κατά τη χρήση αυτό δέσμης τεχνική.

Αυτό το παράδειγμα δείχνει ότι μπορεί να είναι batched ακόμα πιο σύνθετες λειτουργιών βάσης δεδομένων, όπως το κύριο / λεπτομέρειες λειτουργίες, χρησιμοποιώντας παραμέτρους με πίνακα τιμών.

### <a name="upsert"></a>UPSERT
Ένα άλλο σενάριο διαδικασίας δέσμης περιλαμβάνει την ταυτόχρονη ενημέρωση υπάρχουσες γραμμές και εισαγωγή νέων γραμμών. Αυτή η λειτουργία μερικές φορές αποκαλείται μια λειτουργία "UPSERT" (ενημέρωση + insert). Αντί να πραγματοποιήσετε κλήσεις ξεχωριστή για να ΕΙΣΑΓΆΓΕΤΕ και να ΕΝΗΜΕΡΏΣΕΤΕ, η πρόταση ΣΥΓΧΏΝΕΥΣΗΣ είναι ταιριάζει καλύτερα με αυτήν την εργασία. Τη δήλωση ΣΥΓΧΏΝΕΥΣΗΣ να εκτελέσετε στοιχεία εισαγωγή και να ενημερώσετε τις εργασίες σε μια κλήση μόνο.

Παράμετροι με πίνακα τιμών μπορεί να χρησιμοποιηθεί με τη δήλωση ΣΥΓΧΏΝΕΥΣΗΣ για την εκτέλεση ενημερώσεων και εισάγει. Για παράδειγμα, εξετάστε το ενδεχόμενο να απλοποιημένη υπαλλήλου πίνακα που περιέχει τις παρακάτω στήλες: EmployeeID, όνομα, επώνυμο, SocialSecurityNumber:

    CREATE TABLE [dbo].[Employee](
    [EmployeeID] [int] IDENTITY(1,1) NOT NULL,
    [FirstName] [nvarchar](50) NOT NULL,
    [LastName] [nvarchar](50) NOT NULL,
    [SocialSecurityNumber] [nvarchar](50) NOT NULL,
     CONSTRAINT [PrimaryKey_Employee] PRIMARY KEY CLUSTERED 
    ([EmployeeID] ASC ))
 
Σε αυτό το παράδειγμα, μπορείτε να χρησιμοποιήσετε το γεγονός ότι το SocialSecurityNumber είναι μοναδικό για να εκτελέσετε ΣΥΓΧΏΝΕΥΣΗ των πολλών υπαλλήλων. Πρώτα, δημιουργήστε τον τύπο πίνακα που ορίζονται από το χρήστη:

    CREATE TYPE EmployeeTableType AS TABLE 
    ( Employee_ID INT,
      FirstName NVARCHAR(50),
      LastName NVARCHAR(50),
      SocialSecurityNumber NVARCHAR(50) );
    GO

Στη συνέχεια, δημιουργήστε μια αποθηκευμένη διαδικασία ή να γράψετε κώδικα που χρησιμοποιεί την πρόταση ΣΥΓΧΏΝΕΥΣΗΣ για να εκτελέσετε την ενημέρωση και να εισαγάγετε. Το ακόλουθο παράδειγμα χρησιμοποιεί τη δήλωση ΣΥΓΧΏΝΕΥΣΗΣ στην παράμετρο με πίνακα τιμών, @employees, του τύπου EmployeeTableType. Τα περιεχόμενα του @employees πίνακα δεν εμφανίζονται εδώ.

    MERGE Employee AS target
    USING (SELECT [FirstName], [LastName], [SocialSecurityNumber] FROM @employees) 
    AS source ([FirstName], [LastName], [SocialSecurityNumber])
    ON (target.[SocialSecurityNumber] = source.[SocialSecurityNumber])
    WHEN MATCHED THEN 
    UPDATE SET
    target.FirstName = source.FirstName, 
    target.LastName = source.LastName
    WHEN NOT MATCHED THEN
       INSERT ([FirstName], [LastName], [SocialSecurityNumber])
       VALUES (source.[FirstName], source.[LastName], source.[SocialSecurityNumber]);

Για περισσότερες πληροφορίες, ανατρέξτε στην τεκμηρίωση και παραδείγματα για την πρόταση ΣΥΓΧΏΝΕΥΣΗΣ. Παρόλο που η ίδια εργασία ήταν δυνατό να εκτελεστεί σε ένα βήμα πολλαπλάσιο που είναι αποθηκευμένα διαδικασία κλήσης με το διαχωρισμό εισαγωγή και λειτουργίες ΕΝΗΜΈΡΩΣΗΣ, την πρόταση ΣΥΓΧΏΝΕΥΣΗΣ είναι πιο αποτελεσματική. Να δημιουργήσετε κλήσεις Transact-SQL που χρησιμοποιούν τη δήλωση ΣΥΓΧΏΝΕΥΣΗ απευθείας χωρίς να απαιτείται δύο κλήσεων βάσης δεδομένων για εισαγωγή και ΕΝΗΜΈΡΩΣΗ κώδικα βάσης δεδομένων.

## <a name="recommendation-summary"></a>Σύνοψη πρότασης

Η παρακάτω λίστα παρέχει μια σύνοψη των διαδικασίας δέσμης συστάσεων που περιγράφονται σε αυτό το θέμα:

- Χρήση προσωρινής και δέσμης για να αυξήσετε την απόδοση και κλιμάκωση της βάσης δεδομένων SQL εφαρμογές.
- Κατανόηση των ισορροπιών μεταξύ δέσμης/προσωρινής και υποστηρίζεται. Κατά τη διάρκεια μιας αποτυχίας ρόλο, ο κίνδυνος απώλειας μια δέσμη ως έχουν σημαντικά εταιρικά δεδομένα μπορεί να αντισταθμίζουν το όφελος απόδοσης της δέσμης.
- Προσπαθήστε να διατηρήσετε όλες τις κλήσεις στη βάση δεδομένων μέσα σε ένα μεμονωμένο κέντρο δεδομένων για να μειώσετε λανθάνοντος χρόνου.
- Εάν επιλέξετε ένα μεμονωμένο διαδικασίας δέσμης τεχνική, με πίνακα τιμών παράμετροι προσφέρουν τις καλύτερες επιδόσεις και ευελιξία.
- Για τις καλύτερες επιδόσεις εισαγωγή, ακολουθήστε αυτές τις γενικές οδηγίες αλλά δοκιμή το σενάριό σας:
    - Για < 100 γραμμές, χρησιμοποιήστε μία με παραμέτρους εντολή εισαγωγή.
    - Για γραμμές < 1000, χρησιμοποιήστε τις παραμέτρους με πίνακα τιμών.
    - Για το > = 1000 γραμμές, χρησιμοποιήστε SqlBulkCopy.
- Για ενημέρωση και διαγραφή, χρήση παραμέτρων με πίνακα τιμών με λογική αποθηκευμένη διαδικασία που καθορίζει τη σωστή λειτουργία σε κάθε γραμμή στην παράμετρο πίνακα.
- Μαζική μέγεθος οδηγίες:
    - Χρησιμοποιήστε το μεγαλύτερο μεγέθη δέσμη που έχει νόημα για την εφαρμογή και επιχειρηματικές απαιτήσεις.
    - Υπόλοιπο το κέρδος απόδοσης των μεγάλων δέσμες με τους κινδύνους προσωρινό ή καταστροφικό αποτυχιών. Τι είναι η συνέπεια των επαναλήψεων ή απώλεια των δεδομένων στη δέσμη; 
    - Δοκιμάστε το μεγαλύτερο μέγεθος δέσμης για να επαληθεύσετε ότι βάση δεδομένων SQL δεν το απορρίψετε.
    - Δημιουργία ρυθμίσεις παραμέτρων που ελέγχου δέσμης, όπως το μέγεθος δέσμης ή του χρονικού διαστήματος που κάνετε προσωρινή αποθήκευση. Αυτές οι ρυθμίσεις παρέχει ευελιξία. Μπορείτε να αλλάξετε τη συμπεριφορά διαδικασίας δέσμης παραγωγή χωρίς επανάληψη ανάπτυξης την υπηρεσία cloud.
- Αποφύγετε την παράλληλη εκτέλεση των δεσμών που λειτουργούν σε έναν πίνακα σε μια βάση δεδομένων. Εάν επιλέξετε να γίνει η διαίρεση μαζικά σε πολλά νήματα εργασίας, εκτελέστε δοκιμές για να καθορίσετε τον αριθμό ιδανική νήματα. Μετά από μια οριακή ακαθόριστες, περισσότερα νήματα θα μειωθεί η απόδοση αντί να αυξήσετε το.
- Εξετάστε το ενδεχόμενο ενεργός μέγεθος και την ώρα ως ένας τρόπος εφαρμογής δέσμης για περισσότερα σενάρια.

## <a name="next-steps"></a>Επόμενα βήματα

Σε αυτό το άρθρο εστιάζει στην πώς σχεδίασης βάσης δεδομένων και κωδικοποίηση τεχνικές που σχετίζονται με δέσμης για να βελτιώσετε την εφαρμογή επιδόσεις και κλιμάκωση. Αλλά αυτό είναι ένα μόνο παραγόντων στη συνολική στρατηγική σας. Για περισσότερους τρόπους για να βελτιώσετε τις επιδόσεις και κλιμάκωση, ανατρέξτε στο θέμα [οδηγίες επιδόσεων βάση δεδομένων SQL Azure για μία μόνο βάσεις δεδομένων](sql-database-performance-guidance.md) και [ζητήματα τιμής και απόδοσης για ένα χώρο συγκέντρωσης ελαστικότητας βάσης δεδομένων](sql-database-elastic-pool-guidance.md).
