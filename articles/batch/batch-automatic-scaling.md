<properties
    pageTitle="Αυτόματη κλίμακα τον υπολογισμό κόμβους σε ένα σύνολο δέσμη Azure | Microsoft Azure"
    description="Ενεργοποίηση αυτόματης κλίμακας σε ένα χώρο συγκέντρωσης cloud για να προσαρμόσετε δυναμικά τον αριθμό των κόμβους υπολογιστικών στο χώρο συγκέντρωσης."
    services="batch"
    documentationCenter=""
    authors="mmacy"
    manager="timlt"
    editor="tysonn"/>

<tags
    ms.service="batch"
    ms.devlang="na"
    ms.topic="article"
    ms.tgt_pltfrm="vm-windows"
    ms.workload="multiple"
    ms.date="10/14/2016"
    ms.author="marsma"/>

# <a name="automatically-scale-compute-nodes-in-an-azure-batch-pool"></a>Αυτόματη κλίμακα τον υπολογισμό κόμβους σε ένα σύνολο δέσμη Azure

Με αυτόματη κλίμακα, η υπηρεσία Azure δέσμη μπορεί να δυναμικά Προσθαφαίρεση κόμβους υπολογιστικών σε ένα χώρο συγκέντρωσης βάσει των παραμέτρων που έχετε καθορίσει. Μπορείτε να αποθηκεύσετε ενδεχομένως χρόνο και χρήμα, προσαρμόζοντας αυτόματα το ποσό του power υπολογισμού που χρησιμοποιείται από την εφαρμογή σας--Προσθήκη κόμβους καθώς αυξάνονται απαιτήσεις εργασιών του έργου σας, και καταργήστε τις όταν αυτές μείωση.

Ενεργοποίηση αυτόματης κλίμακας σε ένα χώρο συγκέντρωσης κόμβους υπολογιστικών, συσχετίζοντας με έναν *τύπο autoscale* που έχετε καθορίσει, όπως με την [PoolOperations.EnableAutoScale] [ net_enableautoscale] μέθοδο στη βιβλιοθήκη [Δέσμη .NET](batch-dotnet-get-started.md) . Η υπηρεσία δέσμη, στη συνέχεια, χρησιμοποιεί αυτόν τον τύπο για να καθορίσετε τον αριθμό των κόμβους υπολογιστικών που απαιτούνται για την εκτέλεση του φόρτου εργασίας σας. Μαζική αποκρίνεται σε υπηρεσία μετρικά δείγματα δεδομένων που έχουν συλλεχθεί περιοδικά και ρυθμίζει τον αριθμό των κόμβους υπολογιστικών στο χώρο συγκέντρωσης σε με δυνατότητα ρύθμισης παραμέτρων χρονικό διάστημα, με βάση τον τύπο σας.

Μπορείτε να ενεργοποιήσετε την αυτόματη κλιμάκωση κατά τη δημιουργία ενός χώρου συγκέντρωσης ή σε έναν υπάρχοντα χώρο συγκέντρωσης. Μπορείτε επίσης να αλλάξετε έναν τύπο που ήδη σε ένα χώρο συγκέντρωσης που είναι "autoscale" με δυνατότητα. Μαζική παρέχει τη δυνατότητα να αξιολογήσετε τους τύπους σας πριν από την ανάθεσή τους σε χώρους συγκέντρωσης, καθώς και να παρακολουθείτε την κατάσταση της αυτόματης κλιμάκωσης εκτελείται.

## <a name="automatic-scaling-formulas"></a>Αυτόματη κλίμακας τύπων

Τύπο αυτόματης κλιμάκωσης είναι μια τιμή συμβολοσειράς που έχετε καθορίσει που περιέχει μία ή περισσότερες προτάσεις και έχει αντιστοιχιστεί σε ένα χώρο συγκέντρωσης [autoScaleFormula] [ rest_autoscaleformula] στοιχείο (το ΥΠΌΛΟΙΠΟ δέσμη) ή [CloudPool.AutoScaleFormula] [ net_cloudpool_autoscaleformula] ιδιότητα (δέσμη .NET). Όταν αντιστοιχιστεί σε ένα χώρο συγκέντρωσης, η υπηρεσία δέσμης χρησιμοποιεί τον τύπο σας για να καθορίσετε τον αριθμό προορισμού κόμβους υπολογιστικών στο χώρο συγκέντρωσης για το επόμενο χρονικό διάστημα της επεξεργασίας (περισσότερα σε χρονικά διαστήματα αργότερα). Η συμβολοσειρά τύπου δεν μπορεί να υπερβαίνει 8 KB στο μέγεθος, μπορούν να περιλαμβάνουν έως 100 δηλώσεις που χωρίζονται με ελληνικά ερωτηματικά, καθώς και να συμπεριλάβετε αλλαγές γραμμών και σχόλια.

Μπορείτε να θεωρήσετε αυτόματης κλιμάκωσης τύπων με τη χρήση μιας δέσμης autoscale "Γλώσσα". Οι προτάσεις τύπου είναι δωρεάν διαμορφωμένο παραστάσεων που μπορεί να περιλαμβάνει μεταβλητές που ορίζονται από το υπηρεσίας (μεταβλητές που ορίζονται από την υπηρεσία δέσμη) και μεταβλητές που ορίζονται από το χρήστη (μεταβλητές που έχετε καθορίσει). Μπορούν να εκτελούν διάφορες λειτουργίες σε αυτές τις τιμές με χρήση ενσωματωμένων τύπους, τελεστές και συναρτήσεις. Για παράδειγμα, μια πρόταση μπορεί να λαμβάνουν την εξής μορφή:

```
$myNewVariable = function($ServiceDefinedVariable, $myCustomVariable);
```

Τύποι περιέχουν γενικά πολλαπλές δηλώσεις που εκτελούν λειτουργίες σε τιμές που λαμβάνονται στο προηγούμενο δηλώσεις. Για παράδειγμα, θα σας πρώτα να λάβετε μια τιμή για `variable1`, να μια συνάρτηση για να συμπληρώσετε `variable2`:

```
$variable1 = function1($ServiceDefinedVariable);
$variable2 = function2($OtherServiceDefinedVariable, $variable1);
```

Με αυτές τις προτάσεις στον τύπο σας, ο στόχος σας είναι να παραδίδεται σε έναν αριθμό κόμβους υπολογιστικών που να--θα πρέπει να έχει το χώρο συγκέντρωσης τον αριθμό **προορισμού** **αποκλειστικό κόμβους**. Αυτός ο αριθμός μπορεί να είναι υψηλότερο, lower ή το ίδιο με τον αριθμό της τρέχουσας τους κόμβους στο χώρο συγκέντρωσης. Μαζική αξιολογεί χώρου συγκέντρωσης autoscale τύπου στο συγκεκριμένο χρονικό διάστημα ([αυτόματα διαστήματα κλίμακας](#automatic-scaling-interval) εξετάζονται παρακάτω). Στη συνέχεια, αυτό θα ρυθμίσετε τον αριθμό προορισμού κόμβους στο χώρο συγκέντρωσης στον αριθμό που καθορίζει τον τύπο autoscale τη στιγμή της αξιολόγησης.

Ως ένα γρήγορο παράδειγμα, αυτός ο τύπος autoscale δύο γραμμών καθορίζει ότι ο αριθμός των κόμβους πρέπει να προσαρμοστεί ανάλογα με τον αριθμό των ενεργών εργασιών, έως και 10 κόμβους υπολογιστικών:

```
$averageActiveTaskCount = avg($ActiveTasks.GetSample(TimeInterval_Minute * 15));
$TargetDedicated = min(10, $averageActiveTaskCount);
```

Οι επόμενες ενότητες μερικά αυτού του άρθρου συζήτηση των διάφορων οντοτήτων που θα αποτελούν τους τύπους σας autoscale, συμπεριλαμβανομένων των μεταβλητών, τελεστές, Λειτουργίες και συναρτήσεις. Θα μάθετε πώς μπορείτε να αποκτήσετε διάφορες υπολογισμού πόρων και εργασιών μετρήσεις εντός δέσμης. Μπορείτε να χρησιμοποιήσετε αυτές τις μετρήσεις για να προσαρμόσετε κάνουν count κόμβο του χώρου συγκέντρωσης πόρων χρήση και την κατάσταση εργασίας με βάση. Στη συνέχεια, θα μάθετε πώς να δημιουργήσετε έναν τύπο και να ενεργοποιήσετε την αυτόματη κλιμάκωση σε ένα χώρο συγκέντρωσης με τη χρήση τόσο τα ΥΠΌΛΟΙΠΑ δέσμη όσο και το .NET API του Te104090127. Θα σας θα τελειώσει με μερικά παραδείγματα τύπων.

> [AZURE.IMPORTANT] Κάθε λογαριασμό δέσμη Azure περιορίζεται σε ένα μέγιστο αριθμό πυρήνων (και επομένως κόμβους υπολογιστικών) που μπορούν να χρησιμοποιηθούν για επεξεργασία. Η υπηρεσία δέσμη θα δημιουργήσετε κόμβους μόνο μέχρι το όριο των πυρήνα. Επομένως, αυτή δεν μπορεί να φτάσει τον αριθμό προορισμού κόμβους υπολογιστικών που καθορίζεται από έναν τύπο. Ανατρέξτε στο θέμα [όρια και περιορισμοί για την υπηρεσία Azure δέσμη](batch-quota-limit.md) για πληροφορίες σχετικά με την προβολή και αύξηση του ορίου λογαριασμού.

## <a name="variables"></a>Μεταβλητές

Μπορείτε να χρησιμοποιήσετε τόσο **που ορίζονται από την υπηρεσία** και **που ορίζονται από το χρήστη** μεταβλητές σε τύπους autoscale. Η υπηρεσία που ορίζεται από μεταβλητές είναι ενσωματωμένη στην υπηρεσία δέσμη--ορισμένες είναι ανάγνωση και εγγραφή και ορισμένα είναι μόνο για ανάγνωση. Μεταβλητές που ορίζονται από το χρήστη είναι οι μεταβλητές που *μπορείτε* να καθορίσετε. Στην παραπάνω, ο τύπος του παραδείγματος δύο γραμμών `$TargetDedicated` είναι μια υπηρεσία που ορίζονται από το μεταβλητής, ενώ `$averageActiveTaskCount` είναι μια μεταβλητή που ορίζονται από το χρήστη.

Οι παρακάτω πίνακες εμφανίζουν μεταβλητές τόσο ανάγνωση και εγγραφή και μόνο για ανάγνωση που ορίζονται από την υπηρεσία δέσμης.

Μπορείτε να κάνετε **λήψη** και να **ορίσετε** τις τιμές από αυτές τις μεταβλητές που ορίζονται από την υπηρεσία για να διαχειριστείτε τον αριθμό των κόμβους υπολογιστικών σε ένα χώρο συγκέντρωσης:

| Ανάγνωση και εγγραφή μεταβλητές που ορίζονται από το υπηρεσίας | Περιγραφή |
| --- | --- |
| $TargetDedicated | Ο αριθμός **προορισμού** του **αφοσιωμένη κόμβους υπολογιστικών** για το χώρο συγκέντρωσης. Αυτός είναι ο αριθμός των κόμβους υπολογιστικών που να πρέπει να έχει το χώρο συγκέντρωσης. Είναι ένας αριθμός "προορισμού" δεδομένου ότι είναι δυνατό για ένα χώρο συγκέντρωσης δεν για την επίτευξη τον αριθμό προορισμού κόμβους. Αυτό μπορεί να συμβεί εάν ο αριθμός προορισμού κόμβους τροποποιηθεί ξανά από μια αξιολόγηση επόμενες autoscale πριν από το χώρο συγκέντρωσης έχει φτάσει στο αρχικό στόχο. Επίσης, αυτό μπορεί να συμβεί εάν ένα όριο δέσμη λογαριασμό κόμβου ή πυρήνα χρονικού πριν από τον αριθμό προορισμού κόμβους. |
| $NodeDeallocationOption | Η ενέργεια που πραγματοποιείται όταν κόμβους υπολογιστικών καταργούνται από ένα χώρο συγκέντρωσης. Πιθανές τιμές είναι:<ul><li>**requeue**--τερματίζει αμέσως εργασιών και τοποθετεί επιστρέψτε στην ουρά έργων, έτσι ώστε οι προγραμματίζονται ξανά.<li>**Τερματισμός**--τερματίζει εργασίες αμέσως και τα καταργεί από ουρά έργων.<li>**taskcompletion**--αναμονή για αυτήν τη στιγμή εκτελούνται εργασίες για να ολοκληρώσετε και, στη συνέχεια, καταργεί τον κόμβο από το χώρο συγκέντρωσης.<li>**retaineddata**– περιμένει για όλα τα τοπικά δεδομένα διατηρούνται εργασίας στον κόμβο εκκαθάριση πριν να καταργήσετε τον κόμβο από το χώρο συγκέντρωσης.</ul> |

Μπορείτε να **λάβετε** την τιμή από αυτές τις μεταβλητές που ορίζονται από την υπηρεσία για να κάνετε προσαρμογές που βασίζονται σε μετρήσεις από την υπηρεσία δέσμη:

| Μόνο για ανάγνωση μεταβλητές που ορίζονται από το υπηρεσίας | Περιγραφή |
| --- | --- |
| $CPUPercent | Ο μέσος όρος ποσοστό της CPU. |
| $WallClockSeconds | Τον αριθμό των δευτερολέπτων που καταναλώθηκε. |
| $MemoryBytes | Ο μέσος αριθμός megabyte που χρησιμοποιείται. |
| $DiskBytes | Ο μέσος όρος των gigabyte χρησιμοποιείται το τοπικό δίσκων. |
| $DiskReadBytes | Διαβάστε τον αριθμό των byte. |
| $DiskWriteBytes | Ο αριθμός των byte που έχουν εγγραφεί. |
| $DiskReadOps | Το πλήθος των λειτουργιών ανάγνωσης δίσκου που εκτελούνται. |
| $DiskWriteOps | Το πλήθος των λειτουργιών δίσκου εγγραφής που εκτελούνται. |
| $NetworkInBytes | Ο αριθμός των εισερχόμενων byte. |
| $NetworkOutBytes | Ο αριθμός των byte που εξερχομένων. |
| $SampleNodeCount | Το πλήθος των κόμβους υπολογιστικών. |
| $ActiveTasks | Ο αριθμός των εργασιών σε μια ενεργή κατάσταση. |
| $RunningTasks | Ο αριθμός των εργασιών σε κατάσταση λειτουργίας. |
| $PendingTasks | Το άθροισμα των $ActiveTasks και $RunningTasks. |
| $SucceededTasks | Ο αριθμός των εργασιών που ολοκληρώθηκε με επιτυχία. |
| $FailedTasks | Ο αριθμός των εργασιών που απέτυχε. |
| $CurrentDedicated | Ο τρέχων αριθμός των αποκλειστικό υπολογίσετε κόμβους. |

> [AZURE.TIP] Οι μεταβλητές μόνο για ανάγνωση, που ορίζονται από την υπηρεσία που εμφανίζονται παραπάνω είναι *αντικείμενα* που παρέχει διάφορες μεθόδους για να αποκτήσετε πρόσβαση σε δεδομένα που σχετίζονται με κάθε μία. Για περισσότερες πληροφορίες, ανατρέξτε στο θέμα [λήψη δείγματος δεδομένων](#getsampledata) κάτω από το στοιχείο.

## <a name="types"></a>Τύποι

Αυτοί οι **τύποι** υποστηρίζονται σε έναν τύπο.

- διπλά
- doubleVec
- doubleVecList
- συμβολοσειρά
- χρονική σήμανση--χρονικής σήμανσης είναι μια σύνθετη δομή που περιέχει τα ακόλουθα μέλη:

    - έτος
    - μήνα (1-12)
    - Day (1-31)
    - Weekday (στη μορφή αριθμού, π.χ. 1 για τη Δευτέρα)
    - Hour (σε 24ωρη μορφή αριθμού, π.χ. 13 σημαίνει 1 μ.μ.)
    - τα λεπτά (00-59)
    - Second (00-59)
- timeinterval

    - TimeInterval_Zero
    - TimeInterval_100ns
    - TimeInterval_Microsecond
    - TimeInterval_Millisecond
    - TimeInterval_Second
    - TimeInterval_Minute
    - TimeInterval_Hour
    - TimeInterval_Day
    - TimeInterval_Week
    - TimeInterval_Year

## <a name="operations"></a>Λειτουργίες

Αυτές οι **Λειτουργίες** επιτρέπονται σχετικά με τους τύπους που αναφέρονται παραπάνω.

| Η λειτουργία                             | Υποστηριζόμενες τελεστές   | Τύπος αποτελεσμάτων   |
| ------------------------------------- | --------------------- | ------------- |
| διπλά *τελεστή* διπλά              | +, -, *, /            | διπλά            |
| διπλά *τελεστή* timeinterval        | *                     | timeinterval      |
| doubleVec *τελεστής* διπλά           | +, -, *, /            | doubleVec         |
| doubleVec *τελεστής* doubleVec        | +, -, *, /            | doubleVec         |
| timeinterval *τελεστής* διπλά        | *, /                  | timeinterval      |
| timeinterval *τελεστής* timeinterval  | +, -                  | timeinterval      |
| χρονική σήμανση *τελεστή* timeinterval     | +                     | χρονική σήμανση         |
| timeinterval *τελεστής* χρονικής σήμανσης     | +                     | χρονική σήμανση         |
| χρονική σήμανση *τελεστή* χρονικής σήμανσης        | -                     | timeinterval      |
| *τελεστής*διπλά                      | -, !                  | διπλά            |
| *τελεστής*timeinterval                | -                     | timeinterval      |
| διπλά *τελεστή* διπλά              | <, < =, ==, > =, >,! =  | διπλά            |
| συμβολοσειρά *τελεστή* συμβολοσειράς              | <, < =, ==, > =, >,! =  | διπλά            |
| χρονική σήμανση *τελεστή* χρονικής σήμανσης        | <, < =, ==, > =, >,! =  | διπλά            |
| timeinterval *τελεστής* timeinterval  | <, < =, ==, > =, >,! =  | διπλά            |
| διπλά *τελεστή* διπλά              | & &, & #124- & #124-      | διπλά            |

Κατά τη δοκιμή μια τιμή διπλής με έναν τελεστή τριμερή (`double ? statement1 : statement2`), εκτός από μηδέν είναι **Αληθής**και μηδέν είναι **Ψευδής**.

## <a name="functions"></a>Συναρτήσεις

Αυτές τις προκαθορισμένες **Λειτουργίες** είναι διαθέσιμες για να χρησιμοποιήσετε για τον καθορισμό τύπο αυτόματης κλιμάκωσης.

| Συνάρτηση                          | Τύπος επιστροφής   | Περιγραφή
| --------------------------------- | ------------- | --------- |
| AVG(doubleVecList)                | διπλά        | Επιστρέφει τον μέσο όρο όλων των τιμών του doubleVecList.
| Len(doubleVecList)                | διπλά        | Επιστρέφει το μήκος του φορέα που δημιουργείται από το doubleVecList.
| LG(Double)                        | διπλά        | Επιστρέφει το αρχείο καταγραφής του διπλού με βάση το 2.
| LG(doubleVecList)                 | doubleVec     | Επιστρέφει το αρχείο καταγραφής componentwise από το doubleVecList με βάση το 2. Ένα vec(double) πρέπει να περάσουν ρητά για την παράμετρο. Διαφορετικά, λαμβάνεται η έκδοση διπλά lg(double).
| ln(Double)                        | διπλά        | Επιστρέφει το φυσικό αρχείο καταγραφής του διπλού.
| ln(doubleVecList)                 | doubleVec     | Επιστρέφει το αρχείο καταγραφής componentwise από το doubleVecList με βάση το 2. Ένα vec(double) πρέπει να διαβιβαστεί ρητά για την παράμετρο. Διαφορετικά, λαμβάνεται η έκδοση διπλά lg(double).
| log(Double)                       | διπλά        | Επιστρέφει το αρχείο καταγραφής του διπλού με βάση το 10.
| log(doubleVecList)                | doubleVec     | Επιστρέφει το αρχείο καταγραφής componentwise από το doubleVecList με βάση το 10. Ένα vec(double) πρέπει να να διαβιβαστεί ρητά για την παράμετρο μία διπλό. Διαφορετικά, λαμβάνεται η έκδοση διπλά log(double).
| Max(doubleVecList)                | διπλά        | Επιστρέφει τη μέγιστη τιμή του doubleVecList.
| min(doubleVecList)                | διπλά        | Επιστρέφει την ελάχιστη τιμή του doubleVecList.
| norm(doubleVecList)               | διπλά        | Επιστρέφει τα δύο συνήθη επίπεδα του φορέα που δημιουργείται από το doubleVecList.
| συνάρτηση PERCENTILE (v doubleVec, διπλά p) | διπλά        | Επιστρέφει το στοιχείο εκατοστημόριο του φορέα v.
| rand()                            | διπλά        | Επιστρέφει μια τυχαία τιμή μεταξύ 0,0 και 1,0.
| Range(doubleVecList)              | διπλά        | Επιστρέφει τη διαφορά μεταξύ της ελάχιστο και μέγιστο τιμές το doubleVecList.
| Std(doubleVecList)                | διπλά        | Επιστρέφει την τυπική απόκλιση του δείγματος των τιμών του doubleVecList.
| STOP()                            |               | Διακόπτει την αξιολόγηση της παράστασης autoscaling.
| SUM(doubleVecList)                | διπλά        | Επιστρέφει το άθροισμα όλων των στοιχείων από το doubleVecList.
| ώρα (dateTime συμβολοσειράς = "")          | χρονική σήμανση     | Επιστρέφει τη χρονική σήμανση της τρέχουσας ώρας εάν οι παράμετροι δεν μεταβιβάζονται ή τη χρονική σήμανση της συμβολοσειράς ημερομηνίας/ώρας, εάν μεταβιβάζεται. Υποστηριζόμενες dateTime μορφές είναι W3C-DTF και RFC 1123.
| Val (v doubleVec, διπλά i)        | διπλά        | Επιστρέφει την τιμή του στοιχείου που είναι σε θέση i σε ανύσματος v, με ένα αρχικό ευρετήριο 0.

Ορισμένες από τις συναρτήσεις που περιγράφονται στον παραπάνω πίνακα μπορεί να αποδεχτεί μια λίστα ως όρισμα. Η λίστα διαχωρισμένες με κόμματα είναι οποιοσδήποτε συνδυασμός *δύο* και *doubleVec*. Για παράδειγμα:

`doubleVecList := ( (double | doubleVec)+(, (double | doubleVec) )* )?`

Η τιμή *doubleVecList* μετατρέπεται σε ένα μεμονωμένο *doubleVec* πριν από την αξιολόγηση. Για παράδειγμα, εάν `v = [1,2,3]`, στη συνέχεια, κλήση `avg(v)` είναι ισοδύναμο με κλήση `avg(1,2,3)`. Κλήση `avg(v, 7)` είναι ισοδύναμο με κλήση `avg(1,2,3,7)`.

## <a name="getsampledata"></a>Λήψη δείγματος δεδομένων

Οι τύποι Autoscale ενεργούν μετρικά δεδομένα (δείγματα) που παρέχεται από την υπηρεσία δέσμης. Ένας τύπος μεγαλώνει ή συρρικνώνεται μέγεθος του χώρου συγκέντρωσης με βάση τις τιμές που λαμβάνει από την υπηρεσία. Οι μεταβλητές που ορίζονται από την υπηρεσία που περιγράφονται παραπάνω είναι αντικείμενα που παρέχει διάφορες μεθόδους για να αποκτήσετε πρόσβαση σε δεδομένα που σχετίζονται με αυτό το αντικείμενο. Για παράδειγμα, η παρακάτω παράσταση εμφανίζει μια αίτηση για να λάβετε τα τελευταία πέντε λεπτά της χρήση CPU:

```
$CPUPercent.GetSample(TimeInterval_Minute * 5)
```

| Μέθοδος | Περιγραφή |
| --- | --- |
| GetSample() | Το `GetSample()` μέθοδος επιστρέφει ανύσματος δείγματα δεδομένων.<br/><br/>Δείγμα είναι 30 δευτερόλεπτα αξίζει μετρικά δεδομένων. Με άλλα λόγια, τα δείγματα λαμβάνονται κάθε 30 δευτερόλεπτα. Αλλά, όπως σημειώνονται παρακάτω, υπάρχει μια καθυστέρηση μεταξύ όταν ένα δείγμα συλλέγονται και όταν είναι διαθέσιμος σε έναν τύπο. Ως εκ τούτου, δεν όλα τα δείγματα για μια δεδομένη χρονική περίοδο μπορεί να είναι διαθέσιμο για αξιολόγηση από έναν τύπο.<ul><li>`doubleVec GetSample(double count)`<br/>Καθορίζει τον αριθμό των δειγμάτων για τη λήψη από το πιο πρόσφατο δείγματα που έχουν συλλεχθεί.<br/><br/>`GetSample(1)`Επιστρέφει το τελευταίο δείγμα διαθέσιμη. Για μετρικά όπως `$CPUPercent`, ωστόσο, αυτό δεν πρέπει να χρησιμοποιούνται επειδή δεν είναι δυνατό να γνωρίζετε *Όταν* έχουν συλλεχθεί το δείγμα. Αυτό μπορεί να πρόσφατες ή, λόγω προβλημάτων συστήματος, ενδέχεται να είναι πολύ παλαιότερων. Είναι καλύτερη σε αυτές τις περιπτώσεις για να χρησιμοποιήσετε ένα χρονικό διάστημα, όπως φαίνεται παρακάτω.<li>`doubleVec GetSample((timestamp or timeinterval) startTime [, double samplePercent])`<br/>Καθορίζει ένα χρονικό πλαίσιο για τη συγκέντρωση δείγματα δεδομένων. Προαιρετικά, καθορίζει επίσης το ποσοστό των δειγμάτων που πρέπει να είναι διαθέσιμες στο ζητήθηκε χρονικό πλαίσιο.<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10)`θα επιστρέψει 20 δείγματα, εάν υπάρχουν στο ιστορικό CPUPercent όλα τα δείγματα για τα τελευταία δέκα λεπτά. Εάν το τελευταίο λεπτό του ιστορικού δεν ήταν διαθέσιμες, ωστόσο, μόνο 18 δείγματα θα επιστραφεί. Σε αυτήν την περίπτωση:<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)`θα αποτύχει, επειδή είναι διαθέσιμες μόνο 90 τοις εκατό των δειγμάτων.<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)`θα ολοκληρωθεί με επιτυχία.<li>`doubleVec GetSample((timestamp or timeinterval) startTime, (timestamp or timeinterval) endTime [, double samplePercent])`<br/>Καθορίζει ένα χρονικό πλαίσιο για τη συγκέντρωση δεδομένων, με ώρα έναρξης και την ώρα λήξης.<br/><br/>Όπως προαναφέρθηκε, υπάρχει μια καθυστέρηση μεταξύ όταν ένα δείγμα συλλέγονται και όταν είναι διαθέσιμος σε έναν τύπο. Αυτό πρέπει να ληφθούν υπόψη όταν χρησιμοποιείτε το `GetSample` μέθοδο. Ανατρέξτε στο θέμα `GetSamplePercent` κάτω από το στοιχείο.|
| GetSamplePeriod() | Επιστρέφει την περίοδο των δειγμάτων που έγιναν σε ένα σύνολο δεδομένων ιστορικού δείγμα. |
| Count() | Επιστρέφει τον συνολικό αριθμό των δειγμάτων στο ιστορικό μετρικό. |
| HistoryBeginTime() | Επιστρέφει τη χρονική σήμανση από το παλιότερο δείγμα δεδομένα που είναι διαθέσιμα για τη μέτρηση. |
| GetSamplePercent() |Επιστρέφει το ποσοστό των δειγμάτων που είναι διαθέσιμες για ένα συγκεκριμένο χρονικό διάστημα. Για παράδειγμα:<br/><br/>`doubleVec GetSamplePercent( (timestamp or timeinterval) startTime [, (timestamp or timeinterval) endTime] )`<br/><br/>Επειδή το `GetSample` μέθοδος αποτυγχάνει εάν το ποσοστό των δειγμάτων που επιστρέφεται είναι μικρότερο από το `samplePercent` που καθορίζονται, μπορείτε να χρησιμοποιήσετε το `GetSamplePercent` μέθοδο για να ελέγξετε πρώτα. Στη συνέχεια, μπορείτε να εκτελέσετε μια άλλη ενέργεια εάν υπάρχουν, ανεπαρκές δείγματα χωρίς διακοπή αυτόματης κλιμάκωσης αξιολόγησης.|

### <a name="samples-sample-percentage-and-the-getsample-method"></a>Δείγματα, δείγμα ποσοστό και τη μέθοδο *GetSample()*

Η λειτουργία πυρήνα τύπου autoscale είναι να αποκτήσετε εργασιών και πόρων μετρικά δεδομένα και στη συνέχεια, προσαρμόστε το μέγεθος του χώρου συγκέντρωσης που βασίζονται σε αυτά τα δεδομένα. Ως εκ τούτου, είναι σημαντικό να έχετε κατανοήσει απαλοιφή των πώς τύπους autoscale αλληλεπίδραση με δεδομένα μετρικά ή "Δείγματα".

**Δείγματα**

Η υπηρεσία δέσμη περιοδικά λαμβάνει *δείγματα* μετρικά εργασιών και πόρων και είναι διαθέσιμες για τους τύπους σας autoscale. Αυτά τα δείγματα καταγράφονται κάθε 30 δευτερόλεπτα από την υπηρεσία δέσμης. Ωστόσο, υπάρχει συνήθως ορισμένες λανθάνων χρόνος που προκαλεί μια καθυστέρηση μεταξύ όταν έχουν καταγραφεί αυτά τα δείγματα και όταν γίνονται διαθέσιμοι για να (και μπορεί να διαβαστεί από) τους τύπους σας autoscale. Επιπλέον, λόγω διάφορους παράγοντες όπως δικτύου ή άλλα προβλήματα υποδομής, δείγματα ενδέχεται να μην έχουν εγγραφεί για ένα συγκεκριμένο χρονικό διάστημα. Το αποτέλεσμα είναι "λείπει" δείγματα.

**Δείγμα ποσοστό**

Όταν `samplePercent` που του μεταβιβάστηκε η `GetSample()` μέθοδο ή το `GetSamplePercent()` μέθοδος καλείται, "Ποσοστό" αναφέρεται σε μια σύγκριση μεταξύ του συνόλου *πιθανών* αριθμού των δειγμάτων που καταγράφονται από την υπηρεσία δέσμης και τον αριθμό των δειγμάτων που είναι στην πραγματικότητα *διαθέσιμα* στον τύπο σας autoscale.

Ας δούμε ένα χρονικό διάστημα 10 λεπτά ως παράδειγμα. Επειδή δείγματα καταγράφονται κάθε 30 δευτερόλεπτα, μέσα σε ένα χρονικό διάστημα 10 λεπτά, το μέγιστο συνολικό αριθμό των δειγμάτων που καταγράφονται από δέσμη θα ήταν 20 δείγματα (2 ανά λεπτό). Ωστόσο, λόγω εγγενή λανθάνοντος χρόνου του μηχανισμού αναφοράς ή ορισμένες άλλες ζήτημα εντός της υποδομής Azure, μπορεί να υπάρχουν μόνο 15 δείγματα που είναι διαθέσιμα στον τύπο σας autoscale για ανάγνωση. Αυτό σημαίνει ότι, για τη συγκεκριμένη περίοδο 10 λεπτών, μόνο **75 τοις εκατό** της τον συνολικό αριθμό των δειγμάτων καταγραφεί είναι στην πραγματικότητα διαθέσιμα στον τύπο σας.

**Περιοχές GetSample() και δείγματα**

Τους τύπους σας autoscale πρόκειται να είναι μεγέθυνσης και σμίκρυνσης σας χώρους συγκέντρωσης--Προσθήκη κόμβους ή την κατάργηση κόμβους. Επειδή οι κόμβοι κόστος, που θέλετε να βεβαιωθείτε ότι τους τύπους σας να χρησιμοποιήσετε μια έξυπνη μέθοδος ανάλυσης που βασίζεται σε επαρκή δεδομένα. Επομένως, συνιστάται να χρησιμοποιήσετε μια ανάλυση δημοφιλείς, τύπος στους τύπους σας. Αυτός ο τύπος θα μεγέθυνση και σμίκρυνση σας χώρους συγκέντρωσης που βασίζεται σε μια *περιοχή* που έχουν συλλεχθεί δείγματα.

Για να το κάνετε αυτό, χρησιμοποιήστε `GetSample(interval look-back start, interval look-back end)` για να επιστρέψετε **ανύσματος** των δειγμάτων:

```
$runningTasksSample = $RunningTasks.GetSample(1 * TimeInterval_Minute, 6 * TimeInterval_Minute);
```

Κατά την αξιολόγηση της παραπάνω γραμμής με δέσμη, θα επιστρέψει μια περιοχή των δειγμάτων ως άνυσμα τιμών. Για παράδειγμα:

```
$runningTasksSample=[1,1,1,1,1,1,1,1,1,1];
```

Αφού έχετε συγκεντρώσει το ανύσματος δειγμάτων, μπορείτε να χρησιμοποιήσετε συναρτήσεις, όπως `min()`, `max()`, και `avg()` να εντοπίζουμε χαρακτηριστικό τιμές από την περιοχή που έχουν συλλεχθεί.

Για πρόσθετη ασφάλεια, μπορείτε να επιβάλετε μια τύπου αξιολόγησης *Αποτυχία* εάν μικρότερη από ένα συγκεκριμένο ποσοστό του δείγματος είναι διαθέσιμη για μια συγκεκριμένη χρονική περίοδο. Όταν επιβάλλετε ενός τύπου αξιολόγησης αποτυχία, πείτε δέσμη να διακόψει περαιτέρω αξιολόγηση του τύπου, εάν δεν είναι διαθέσιμη--στο συγκεκριμένο ποσοστό των δειγμάτων και θα γίνει καμία αλλαγή στο μέγεθος του χώρου συγκέντρωσης. Για να καθορίσετε ένα ποσοστό απαιτείται δειγμάτων για τον υπολογισμό με επιτυχία, το καθορίσετε ως η τρίτη παράμετρος να `GetSample()`. Εδώ, καθορίζεται προϋπόθεση 75 τοις εκατό των δειγμάτων:

```
$runningTasksSample = $RunningTasks.GetSample(60 * TimeInterval_Second, 120 * TimeInterval_Second, 75);
```

Είναι επίσης σημαντικό, λόγω την παραπάνω καθυστέρηση στη διαθεσιμότητα δείγμα, για να καθορίσετε πάντα μια περιοχή ώρας με ώρα έναρξης πίσω εμφάνισης που είναι παλαιότερα από ένα λεπτό. Αυτό συμβαίνει επειδή το διαρκεί περίπου ένα λεπτό για δείγματα για μεταδοθούν μέσω του συστήματος, επομένως δειγμάτων στην περιοχή `(0 * TimeInterval_Second, 60 * TimeInterval_Second)` συχνά δεν θα είναι διαθέσιμη. Και πάλι, μπορείτε να χρησιμοποιήσετε την παράμετρο ποσοστό της `GetSample()` για να επιβάλετε το δείγμα συγκεκριμένο ποσοστό απαίτηση.

> [AZURE.IMPORTANT] Θα σας **συνιστάται ιδιαίτερα να** που θα * *αποφύγετε βασίζεστε *μόνο* σε `GetSample(1)` στο σας τύπους autoscale **. Αυτό συμβαίνει επειδή `GetSample(1)` ουσιαστικά αναφέρει ότι με την υπηρεσία δέσμη, "να λαμβάνω το τελευταίο δείγμα που έχετε, ανεξάρτητα από το πόσο καιρό που λάβατε." Εφόσον είναι μόνο ένα δείγμα και μπορεί να είναι μια παλαιότερη δείγματα, δεν μπορεί να είναι εκπρόσωπο της εικόνας μεγαλύτερο πρόσφατης εργασίας ή πόρου κατάσταση. Εάν χρησιμοποιείτε το `GetSample(1)`, βεβαιωθείτε ότι είναι μέρος του μια πρόταση μεγαλύτερα και όχι το σημείο μόνο τα δεδομένα που ο τύπος σας που βασίζεται σε.

## <a name="metrics"></a>Μετρήσεις

Μπορείτε να χρησιμοποιήσετε μετρικά **πόρων** και **εργασιών** , όταν ορίζετε έναν τύπο. Μπορείτε να προσαρμόσετε τον αριθμό προορισμού αποκλειστικό κόμβους στο χώρο συγκέντρωσης με βάση τα δεδομένα μετρικά που μπορείτε να αποκτήσετε και να υπολογιστεί. Ανατρέξτε στην ενότητα [μεταβλητές](#variables) παραπάνω για περισσότερες πληροφορίες σε κάθε μετρικό σύστημα.

<table>
  <tr>
    <th>Μέτρηση</th>
    <th>Περιγραφή</th>
  </tr>
  <tr>
    <td><b>Πόρων</b></td>
    <td><p><b>Μετρικά πόρων</b> είναι με βάση τη χρήση CPU, το εύρος ζώνης και μνήμη κόμβους υπολογιστικών, καθώς και τον αριθμό των κόμβους.</p>
        <p> Αυτές οι μεταβλητές που ορίζονται από την υπηρεσία είναι χρήσιμες για προσαρμογές που βασίζονται σε πλήθος κόμβου:</p>
    <p><ul>
      <li>$TargetDedicated</li>
            <li>$CurrentDedicated</li>
            <li>$SampleNodeCount</li>
    </ul></p>
    <p>Αυτές οι μεταβλητές που ορίζονται από την υπηρεσία είναι χρήσιμες για προσαρμογές που βασίζονται σε κόμβο χρήση πόρων:</p>
    <p><ul>
      <li>$CPUPercent</li>
      <li>$WallClockSeconds</li>
      <li>$MemoryBytes</li>
      <li>$DiskBytes</li>
      <li>$DiskReadBytes</li>
      <li>$DiskWriteBytes</li>
      <li>$DiskReadOps</li>
      <li>$DiskWriteOps</li>
      <li>$NetworkInBytes</li>
      <li>$NetworkOutBytes</li></ul></p>
  </tr>
  <tr>
    <td><b>Εργασία</b></td>
    <td><p><b>Εργασίας μετρικά</b> είναι βάσει της κατάστασης των εργασιών, όπως η ενεργή, σε εκκρεμότητα, και να ολοκληρωθεί. Οι παρακάτω μεταβλητές που ορίζονται από την υπηρεσία είναι χρήσιμες για το μέγεθος του χώρου συγκέντρωσης προσαρμογές βάσει μετρικών εργασίας:</p>
    <p><ul>
      <li>$ActiveTasks</li>
      <li>$RunningTasks</li>
      <li>$PendingTasks</li>
      <li>$SucceededTasks</li>
            <li>$FailedTasks</li></ul></p>
        </td>
  </tr>
</table>

## <a name="write-an-autoscale-formula"></a>Γράψτε έναν τύπο autoscale

Δημιουργία ενός τύπου autoscale με σχηματίζοντας δηλώσεις που χρησιμοποιούν τα παραπάνω στοιχεία και κατόπιν συνδυασμός αυτές τις προτάσεις σε έναν τύπο ολοκλήρωσης. Σε αυτήν την ενότητα, θα δημιουργήσουμε έναν τύπο autoscale παράδειγμα που μπορεί να εκτελέσει ορισμένες αποφάσεις κλίμακας ρεαλιστικό.

Πρώτα, ας καθορίζουν τις απαιτήσεις για το νέο τύπο autoscale. Ο τύπος θα πρέπει να:

1. **Αύξηση** του αριθμού προορισμού των κόμβους υπολογιστικών σε ένα χώρο συγκέντρωσης εάν η χρήση της CPU είναι υψηλή.
2. **Μειώστε** τον αριθμό προορισμού κόμβους υπολογιστικών σε ένα χώρο συγκέντρωσης όταν η χρήση της CPU είναι χαμηλή.
3. Περιορισμός πάντα τον **μέγιστο** αριθμό κόμβους 400.

Για να *αυξήσετε* τον αριθμό των κόμβους κατά τη διάρκεια μεγάλη χρήση της CPU, θα σας να ορίσετε τη δήλωση που συμπληρώνει μια μεταβλητή που ορίζονται από το χρήστη (`$totalNodes`) με μια τιμή που είναι 110 τοις εκατό του τρέχοντος αριθμού προορισμού κόμβους, αλλά μόνο αν έχει το ελάχιστο μέσο της CPU κατά τα τελευταία 10 λεπτά παραπάνω 70 τοις εκατό. Διαφορετικά, χρησιμοποιήστε την τρέχουσα τιμή αποκλειστικό.

```
$totalNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicated * 1.1) : $CurrentDedicated;
```

Για να *μειώσετε* τον αριθμό των κόμβους κατά τη διάρκεια της CPU χαμηλή, η επόμενη δήλωση σε τύπο μας ορίζει το ίδιο `$totalNodes` μεταβλητής με 90 τοις εκατό του τρέχοντος αριθμού προορισμού κόμβους αν η χρήση της CPU average στο τα τελευταία 60 λεπτά στην περιοχή ήταν 20 τοις εκατό. Διαφορετικά, χρησιμοποιήστε την τρέχουσα τιμή της `$totalNodes` που θα σας συμπληρωθεί στην παραπάνω πρόταση.

```
$totalNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicated * 0.9) : $totalNodes;
```

Τώρα περιορισμός του αριθμού προορισμού κόμβους αποκλειστικό υπολογιστικών σε μια **μέγιστη** 400:

```
$TargetDedicated = min(400, $totalNodes)
```

Ακολουθεί τον πλήρη τύπο:

```
$totalNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicated * 1.1) : $CurrentDedicated;
$totalNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicated * 0.9) : $totalNodes;
$TargetDedicated = min(400, $totalNodes)
```

## <a name="create-an-autoscale-enabled-pool"></a>Δημιουργία ενός χώρου συγκέντρωσης με δυνατότητα autoscale

Για να δημιουργήσετε ένα νέο σύνολο με autoscaling ενεργοποιημένο, μπορείτε να χρησιμοποιήσετε μία από τις εξής τεχνικές:

**Μαζική .NET**

1. Δημιουργήστε το χώρο συγκέντρωσης με [BatchClient.PoolOperations.CreatePool](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createpool.aspx).
1. Ορίστε την ιδιότητα [CloudPool.AutoScaleEnabled](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleenabled.aspx) σε `true`.
1. Ορίστε την ιδιότητα [CloudPool.AutoScaleFormula](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx) με τον τύπο autoscale.
1. (Προαιρετικό) Ορίστε την ιδιότητα [CloudPool.AutoScaleEvaluationInterval](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoScaleevaluationinterval.aspx) (η προεπιλογή είναι 15 λεπτά).
1. Ολοκλήρωση του χώρου συγκέντρωσης με [CloudPool.Commit](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.commit.aspx) ή [CommitAsync](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.commitasync.aspx).

**Μαζική REST API**

* [Προσθήκη ενός χώρου συγκέντρωσης για ένα λογαριασμό](https://msdn.microsoft.com/library/azure/dn820174.aspx): Καθορίστε το `enableAutoScale` και `autoScaleFormula` στοιχεία στην πρόσκληση σε REST API για να ρυθμίσετε τις παραμέτρους αυτόματης κλίμακας για ένα χώρο συγκέντρωσης κατά τη δημιουργία της.

Το παρακάτω τμήμα κώδικα δημιουργεί ένα σύνολο με δυνατότητα autoscale χρησιμοποιώντας τη [Μαζική .NET] [ net_api] βιβλιοθήκη. Τύπος autoscale χώρο συγκέντρωσης ορίζει τον αριθμό προορισμού κόμβους έως 5 Δευτέρες και 1 σε κάθε δεύτερη ημέρα της εβδομάδας. Το [χρονικό διάστημα αυτόματης κλιμάκωσης](#automatic-scaling-interval) έχει οριστεί σε 30 λεπτά. Σε αυτό και τα άλλα C# τμήματα κώδικα σε αυτό το άρθρο, "myBatchClient" είναι μια έχει προετοιμαστεί κατάλληλα παρουσία της [BatchClient][net_batchclient].

```csharp
CloudPool pool = myBatchClient.PoolOperations.CreatePool("mypool", "3", "small");
pool.AutoScaleEnabled = true;
pool.AutoScaleFormula = "$TargetDedicated = (time().weekday == 1 ? 5:1);";
pool.AutoScaleEvaluationInterval = TimeSpan.FromMinutes(30);
pool.Commit();
```

Εκτός από τη δέσμη REST API και .NET SDK, μπορείτε να χρησιμοποιήσετε οποιοδήποτε από τα άλλα [Δέσμη SDK](batch-technical-overview.md#batch-development-apis), [cmdlet του PowerShell δέσμης](batch-powershell-cmdlets-get-started.md)και τη [Δέσμη CLI](batch-cli-get-started.md) για να εργαστείτε με autoscaling.

> [AZURE.IMPORTANT] Όταν δημιουργείτε ένα χώρο συγκέντρωσης autoscale με δυνατότητα, πρέπει να **δεν** καθορίσετε το `targetDedicated` παραμέτρου. Επίσης, εάν θέλετε με μη αυτόματο τρόπο για να αλλάξετε το μέγεθος ενός χώρου συγκέντρωσης με δυνατότητα autoscale (για παράδειγμα, με [BatchClient.PoolOperations.ResizePool][net_poolops_resizepool]), στη συνέχεια, θα πρέπει να πρώτη **Απενεργοποίηση** αυτόματης κλιμάκωσης στο χώρο συγκέντρωσης, στη συνέχεια, αλλάξετε το μέγεθός του.

### <a name="automatic-scaling-interval"></a>Διάστημα αυτόματης κλιμάκωσης

Από προεπιλογή, η υπηρεσία δέσμη προσαρμόζεται μέγεθος χώρου συγκέντρωσης σύμφωνα με τον τύπο autoscale κάθε **15 λεπτά**. Αυτό το χρονικό διάστημα είναι με δυνατότητα ρύθμισης παραμέτρων, ωστόσο, χρησιμοποιώντας τις ακόλουθες ιδιότητες χώρου συγκέντρωσης:

* [CloudPool.AutoScaleEvaluationInterval] [ net_cloudpool_autoscaleevalinterval] (μαζική .NET)
* [autoScaleEvaluationInterval] [ rest_autoscaleinterval] (REST API)

Το ελάχιστο διάστημα είναι πέντε λεπτά και ο μέγιστος αριθμός είναι 168 ώρες. Εάν έχει οριστεί χρονικό διάστημα εκτός αυτής της περιοχής, η υπηρεσία δέσμη θα επιστρέψει ένα σφάλμα ακατάλληλη αίτηση (400).

> [AZURE.NOTE] Autoscaling αυτήν τη στιγμή δεν προορίζεται για να ανταποκριθείτε σε αλλαγές σε λιγότερο από ένα λεπτό, αλλά Αντιθέτως προορίζεται για να προσαρμόσετε το μέγεθος του χώρου συγκέντρωσης σταδιακά κατά την εκτέλεση μιας φόρτο εργασίας.

## <a name="enable-autoscaling-on-an-existing-pool"></a>Ενεργοποίηση autoscaling σε έναν υπάρχοντα χώρο συγκέντρωσης

Εάν έχετε ήδη δημιουργήσει ένα χώρο συγκέντρωσης με έναν ορισμένο αριθμό κόμβους υπολογιστικών, χρησιμοποιώντας την παράμετρο *targetDedicated* , εξακολουθείτε να μπορείτε να ενεργοποιήσετε autoscaling στο χώρο συγκέντρωσης. Κάθε SDK δέσμη παρέχει μια λειτουργία "Ενεργοποίηση autoscale", για παράδειγμα:

* [BatchClient.PoolOperations.EnableAutoScale] [ net_enableautoscale] (μαζική .NET)
*  [Ενεργοποίηση αυτόματης κλίμακας σε ένα χώρο συγκέντρωσης] [ rest_enableautoscale] (REST API)

Όταν ενεργοποιείτε autoscaling σε έναν υπάρχοντα χώρο συγκέντρωσης, ισχύουν τα εξής:

* Εάν αυτόματης κλίμακας είναι προς το παρόν **απενεργοποιημένη** στο χώρο συγκέντρωσης όταν εκδώσετε την πρόσκληση σε "Ενεργοποίηση autoscale", *πρέπει να* καθορίσετε έναν τύπο έγκυρη autoscale όταν εκδώσετε την αίτηση. *Προαιρετικά* , μπορείτε να καθορίσετε ένα χρονικό διάστημα autoscale αξιολόγησης. Εάν δεν καθορίσετε ένα χρονικό διάστημα, χρησιμοποιείται η προεπιλεγμένη τιμή της 15 λεπτά.

* Εάν autoscale είναι αυτήν τη στιγμή **με δυνατότητα** σε χώρο συγκέντρωσης, μπορείτε να καθορίσετε έναν τύπο autoscale, ένα διάστημα αξιολόγησης ή και τα δύο. Δεν μπορείτε να παραλείψετε και τις δύο ιδιότητες.

  * Εάν καθορίσετε μια νέα διάστημα αξιολόγησης autoscale, στη συνέχεια, το υπάρχον χρονοδιάγραμμα αξιολόγησης έχει διακοπεί και ξεκινήσει με ένα νέο χρονοδιάγραμμα. Ώρα έναρξης του νέου χρονοδιαγράμματος είναι η ώρα κατά την οποία έχει εκδοθεί την αίτηση "Ενεργοποίηση autoscale".

  * Εάν παραλειφθεί το όρισμα τον τύπο autoscale ή αξιολόγησης χρονικό διάστημα, η υπηρεσία δέσμη θα συνεχίσει να χρησιμοποιεί την τρέχουσα τιμή της αυτήν τη ρύθμιση.

> [AZURE.NOTE] Εάν μια τιμή έχει καθοριστεί για την παράμετρο *targetDedicated* κατά τη δημιουργία του χώρου συγκέντρωσης, παραβλέπεται κατά την αξιολόγηση της αυτόματης κλιμάκωσης τύπου.

Αυτό C# τμήμα κώδικα χρησιμοποιεί το [.NET δέσμη] [ net_api] βιβλιοθήκη για να ενεργοποιήσετε την autoscaling σε έναν υπάρχοντα χώρο συγκέντρωσης:

```csharp
// Define the autoscaling formula. This formula sets the target number of nodes
// to 5 on Mondays, and 1 on every other day of the week
string myAutoScaleFormula = "$TargetDedicated = (time().weekday == 1 ? 5:1);";

// Set the autoscale formula on the existing pool
myBatchClient.PoolOperations.EnableAutoScale(
    "myexistingpool",
    autoscaleFormula: myAutoScaleFormula);
```

### <a name="update-an-autoscale-formula"></a>Ενημέρωση έναν τύπο autoscale

Μπορείτε να χρησιμοποιήσετε την ίδια πρόσκληση σε "Ενεργοποίηση autoscale" για να *ενημερώσετε* τον τύπο σε έναν υπάρχοντα χώρο συγκέντρωσης με δυνατότητα autoscale (για παράδειγμα, με [EnableAutoScale] [ net_enableautoscale] στο .NET δέσμη). Δεν υπάρχει καμία ειδική λειτουργία "Ενημέρωση autoscale". Για παράδειγμα, εάν έχει ήδη ενεργοποιηθεί autoscaling για "myexistingpool", όταν εκτελείται ο ακόλουθος κώδικας, τον τύπο autoscale αντικαθίσταται με τα περιεχόμενα του `myNewFormula`.

```csharp
myBatchClient.PoolOperations.EnableAutoScale(
    "myexistingpool",
    autoscaleFormula: myNewFormula);
```

### <a name="update-the-autoscale-interval"></a>Το χρονικό διάστημα autoscale ενημέρωσης

Όπως με την ενημέρωση ενός τύπου autoscale, μπορείτε να χρησιμοποιήσετε την ίδια [EnableAutoScale] [ net_enableautoscale] μέθοδο για να αλλάξετε το διάστημα αξιολόγησης autoscale έναν υπάρχοντα χώρο συγκέντρωσης με δυνατότητα autoscale. Για παράδειγμα, για να ορίσετε το χρονικό διάστημα αξιολόγησης autoscale σε 60 λεπτά για ένα χώρο συγκέντρωσης που είναι ήδη ενεργοποιημένη autoscale:

```csharp
myBatchClient.PoolOperations.EnableAutoScale(
    "myexistingpool",
    autoscaleEvaluationInterval: TimeSpan.FromMinutes(60));
```

## <a name="evaluate-an-autoscale-formula"></a>Υπολογισμός ενός τύπου autoscale

Μπορείτε να αξιολογήσετε τύπου πριν να την εφαρμόσετε σε ένα χώρο συγκέντρωσης. Με αυτόν τον τρόπο, μπορείτε να εκτελέσετε μια "δοκιμή εκτέλεση" του τύπου για να δείτε πώς το δηλώσεις αξιολόγηση πριν να τοποθετήσετε τον τύπο σε παραγωγής.

Για να υπολογιστεί έναν τύπο autoscale, πρέπει να πρώτη **Ενεργοποίηση autoscaling** στο χώρο συγκέντρωσης με έναν **έγκυρο τύπο**. Εάν θέλετε να δοκιμάσετε έναν τύπο σε ένα χώρο συγκέντρωσης που δεν έχει ακόμα autoscaling με δυνατότητα, μπορείτε να χρησιμοποιήσετε τον τύπο μίας γραμμής `$TargetDedicated = 0` όταν ενεργοποιείτε πρώτα autoscaling. Στη συνέχεια, χρησιμοποιήστε ένα από τα εξής για να αξιολογήσετε τον τύπο που θέλετε να ελέγξετε:

* [BatchClient.PoolOperations.EvaluateAutoScale](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscale.aspx) ή [EvaluateAutoScaleAsync](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscaleasync.aspx)

    Αυτές οι μέθοδοι .NET δέσμη απαιτούν το Αναγνωριστικό του έναν υπάρχοντα χώρο συγκέντρωσης και μια συμβολοσειρά που περιέχει τον τύπο autoscale να αξιολογήσετε. Τα αποτελέσματα του υπολογισμού περιέχονται στην παρουσία επιστρέφεται [AutoScaleEvaluation](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscaleevaluation.aspx) .

* [Υπολογισμός μιας αυτόματης κλιμάκωσης τύπου](https://msdn.microsoft.com/library/azure/dn820183.aspx)

    Σε αυτήν την αίτηση REST API, καθορίστε το Αναγνωριστικό του χώρου συγκέντρωσης στο URI και ο τύπος autoscale στο στοιχείο *autoScaleFormula* της σώμα της αίτησης. Η απόκριση της λειτουργίας περιέχει όλες τις πληροφορίες σφάλματος που μπορεί να σχετίζεται με τον τύπο.

Σε αυτό το [.NET δέσμη] [ net_api] κώδικα, θα σας Υπολογισμός τύπου πριν από την εφαρμογή για να το [CloudPool][net_cloudpool]. Εάν το χώρο συγκέντρωσης δεν έχει ενεργοποιηθεί autoscaling, θα σας ενεργοποιήσετε πρώτα.

```csharp
// First obtain a reference to an existing pool
CloudPool pool = batchClient.PoolOperations.GetPool("myExistingPool");

// If autoscaling isn't already enabled on the pool, enable it.
// You can't evaluate an autoscale formula on non-autoscale-enabled pool.
if (pool.AutoScaleEnabled == false)
{
    // We need a valid autoscale formula to enable autoscaling on the
    // pool. This formula is valid, but won't resize the pool:
    pool.EnableAutoScale(
        autoscaleFormula: $"$TargetDedicated = {pool.CurrentDedicated};",
        autoscaleEvaluationInterval: TimeSpan.FromMinutes(5));

    // Batch limits EnableAutoScale calls to once every 30 seconds.
    // Because we want to apply our new autoscale formula below if it
    // evaluates successfully, and we *just* enabled autoscaling on
    // this pool, we pause here to ensure we pass that threshold.
    Thread.Sleep(TimeSpan.FromSeconds(31));

    // Refresh the properties of the pool so that we've got the
    // latest value for AutoScaleEnabled
    pool.Refresh();
}

// We must ensure that autoscaling is enabled on the pool prior to
// evaluating a formula
if (pool.AutoScaleEnabled == true)
{
    // The formula to evaluate - adjusts target number of nodes based on
    // day of week and time of day
    string myFormula = @"
        $curTime = time();
        $workHours = $curTime.hour >= 8 && $curTime.hour < 18;
        $isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
        $isWorkingWeekdayHour = $workHours && $isWeekday;
        $TargetDedicated = $isWorkingWeekdayHour ? 20:10;
    ";

    // Perform the autoscale formula evaluation. Note that this does not
    // actually apply the formula to the pool.
    AutoScaleRun eval =
        batchClient.PoolOperations.EvaluateAutoScale(pool.Id, myFormula);

    if (eval.Error == null)
    {
        // Evaluation success - print the results of the AutoScaleRun.
        // This will display the values of each variable as evaluated by the
        // autoscale formula.
        Console.WriteLine("AutoScaleRun.Results: " +
            eval.Results.Replace("$", "\n    $"));

        // Apply the formula to the pool since it evaluated successfully
        batchClient.PoolOperations.EnableAutoScale(pool.Id, myFormula);
    }
    else
    {
        // Evaluation failed, output the message associated with the error
        Console.WriteLine("AutoScaleRun.Error.Message: " +
            eval.Error.Message);
    }
}
```

Επιτυχής αξιολόγηση του τύπου σε αυτό το τμήμα κώδικα θα έχει ως αποτέλεσμα εξόδου παρόμοια με τα εξής:

```
AutoScaleRun.Results:
    $TargetDedicated=10;
    $NodeDeallocationOption=requeue;
    $curTime=2016-10-13T19:18:47.805Z;
    $isWeekday=1;
    $isWorkingWeekdayHour=0;
    $workHours=0
```

## <a name="get-information-about-autoscale-runs"></a>Λήψη πληροφοριών σχετικά με autoscale εκτελείται

Για να βεβαιωθείτε ότι ο τύπος αποδίδει με τον αναμενόμενο τρόπο, συνιστάται να επιλέγετε περιοδικά τα αποτελέσματα του autoscaling "εκτελείται" δέσμη εκτελεί σε το χώρο συγκέντρωσης. Ναι, μεταβείτε (ή ανανέωση) μιας αναφοράς στο χώρο συγκέντρωσης, και εξετάστε τις ιδιότητες του την τελευταία autoscale εκτέλεση.

Στο .NET δέσμη, η ιδιότητα [CloudPool.AutoScaleRun](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscalerun.aspx) έχει πολλές ιδιότητες, παρέχοντας πληροφορίες σχετικά με την πιο πρόσφατη αυτόματη κλιμάκωση εκτέλεση έχει πραγματοποιηθεί στο χώρο συγκέντρωσης με την υπηρεσία δέσμης.

* [AutoScaleRun.Timestamp](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.timestamp.aspx)
* [AutoScaleRun.Results](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.results.aspx)
* [AutoScaleRun.Error](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.error.aspx)

Στο το REST API, την αίτηση [λήψη πληροφοριών σχετικά με ένα χώρο συγκέντρωσης](https://msdn.microsoft.com/library/dn820165.aspx) επιστρέφει πληροφορίες για το χώρο συγκέντρωσης, το οποίο περιλαμβάνει την πιο πρόσφατη αυτόματη κλιμάκωση εκτέλεση πληροφορίες στο [autoScaleRun](https://msdn.microsoft.com/library/dn820165.aspx#bk_autrun).

Το παρακάτω C# τμήμα κώδικα χρησιμοποιεί τη βιβλιοθήκη .NET δέσμη για να εκτυπώσετε πληροφορίες σχετικά με την τελευταία autoscaling εκτελείται σε χώρο συγκέντρωσης "myPool":

```csharp
Cloud pool = myBatchClient.PoolOperations.GetPool("myPool");
Console.WriteLine("Last execution: " + pool.AutoScaleRun.Timestamp);
Console.WriteLine("Result:" + pool.AutoScaleRun.Results.Replace("$", "\n  $"));
Console.WriteLine("Error: " + pool.AutoScaleRun.Error);
```

Δείγμα εξόδου από το προηγούμενο τμήμα κώδικα:

```
Last execution: 10/14/2016 18:36:43
Result:
  $TargetDedicated=10;
  $NodeDeallocationOption=requeue;
  $curTime=2016-10-14T18:36:43.282Z;
  $isWeekday=1;
  $isWorkingWeekdayHour=0;
  $workHours=0
Error:
```

## <a name="example-autoscale-formulas"></a>Παραδείγματα τύπων autoscale

Ας ρίξουμε μια ματιά σε μερικά τύπους που δείχνουν διαφορετικούς τρόπους για να προσαρμόσετε το μέγεθος του υπολογισμού πόρων σε ένα χώρο συγκέντρωσης.

### <a name="example-1-time-based-adjustment"></a>Παράδειγμα 1: Προσαρμογή βάσει χρόνου

Ίσως θέλετε να προσαρμόσετε το μέγεθος του χώρου συγκέντρωσης με βάση την ημέρα της εβδομάδας και την ώρα της ημέρας, για να αυξήσετε ή να μειώσετε τον αριθμό των κόμβους στο χώρο συγκέντρωσης αντίστοιχα.

Αυτός ο τύπος λαμβάνει πρώτα την τρέχουσα ώρα. Εάν πρόκειται για μια ημέρα της εβδομάδας (1-5) και εντός των ωρών εργασίας (8 π.μ. με 6 μ.μ.), το μέγεθος του χώρου συγκέντρωσης προορισμού έχει οριστεί σε 20 κόμβους. Διαφορετικά, ορίζεται σε 10 κόμβους.

```
$curTime = time();
$workHours = $curTime.hour >= 8 && $curTime.hour < 18;
$isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
$isWorkingWeekdayHour = $workHours && $isWeekday;
$TargetDedicated = $isWorkingWeekdayHour ? 20:10;
```

### <a name="example-2-task-based-adjustment"></a>Παράδειγμα 2: Προσαρμογή βάσει εργασίας

Σε αυτό το παράδειγμα, το μέγεθος του χώρου συγκέντρωσης προσαρμόζεται με βάση τον αριθμό των εργασιών στην ουρά. Σημειώστε ότι και τα σχόλια και οι αλλαγές γραμμών είναι αποδεκτές σε συμβολοσειρές τύπου.

```csharp
// Get pending tasks for the past 15 minutes.
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
// If we have fewer than 70 percent data points, we use the last sample point,
// otherwise we use the maximum of last sample point and the history average.
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1), avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// If number of pending tasks is not 0, set targetVM to pending tasks, otherwise
// half of current dedicated.
$targetVMs = $tasks > 0? $tasks:max(0, $TargetDedicated/2);
// The pool size is capped at 20, if target VM value is more than that, set it
// to 20. This value should be adjusted according to your use case.
$TargetDedicated = max(0, min($targetVMs, 20));
// Set node deallocation mode - keep nodes active only until tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-3-accounting-for-parallel-tasks"></a>Παράδειγμα 3: Accounting για παράλληλες εργασίες

Αυτό είναι ένα άλλο παράδειγμα που προσαρμόζει το μέγεθος του χώρου συγκέντρωσης με βάση τον αριθμό των εργασιών. Αυτός ο τύπος λαμβάνει επίσης υπόψη τα [MaxTasksPerComputeNode] [ net_maxtasks] τιμή που έχει οριστεί για το χώρο συγκέντρωσης. Αυτό είναι ιδιαίτερα χρήσιμο στις περιπτώσεις όπου έχει ενεργοποιηθεί [εκτέλεσης παράλληλες εργασιών](batch-parallel-node-tasks.md) σε το χώρο συγκέντρωσης.

```csharp
// Determine whether 70 percent of the samples have been recorded in the past
// 15 minutes; if not, use last sample
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1),avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// Set the number of nodes to add to one-fourth the number of active tasks (the
// MaxTasksPerComputeNode property on this pool is set to 4, adjust this number
// for your use case)
$cores = $TargetDedicated * 4;
$extraVMs = (($tasks - $cores) + 3) / 4;
$targetVMs = ($TargetDedicated + $extraVMs);
// Attempt to grow the number of compute nodes to match the number of active
// tasks, with a maximum of 3
$TargetDedicated = max(0,min($targetVMs,3));
// Keep the nodes active until the tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-4-setting-an-initial-pool-size"></a>Παράδειγμα 4: Ρύθμιση ένα αρχικό μέγεθος

Αυτό το παράδειγμα εμφανίζει ένα τμήμα κώδικα C# με έναν τύπο autoscale που καθορίζει το μέγεθος του χώρου συγκέντρωσης για έναν ορισμένο αριθμό κόμβους για μια αρχική χρονική περίοδο. Στη συνέχεια, το ρυθμίζει το μέγεθος του χώρου συγκέντρωσης με βάση τον αριθμό των εκτελείται και ενεργά εργασίες παρέλθει το αρχικό χρονικό διάστημα.

Το τμήμα κώδικα παρακάτω τύπο:

- Ορίζει το αρχικό μέγεθος σε τέσσερα κόμβους.
- Δεν προσαρμόζεται στο μέγεθος του χώρου συγκέντρωσης μέσα τα πρώτα 10 λεπτά του κύκλου ζωής του χώρου συγκέντρωσης.
- Μετά από 10 λεπτά, λαμβάνει η μέγιστη τιμή του αριθμού των εργασιών εκτελείται και ενεργά μέσα τα τελευταία 60 λεπτά.
  - Εάν και οι δύο τιμές είναι 0 (που υποδεικνύει ότι δεν υπάρχουν εργασίες έχουν εκτελείται ή ενεργό τα τελευταία 60 λεπτά), το μέγεθος του χώρου συγκέντρωσης έχει οριστεί στην τιμή 0.
  - Εάν οποιαδήποτε τιμή είναι μεγαλύτερο του μηδενός, θα γίνει καμία αλλαγή.

```csharp
string now = DateTime.UtcNow.ToString("r");
string formula = string.Format(@"
    $TargetDedicated = {1};
    lifespan         = time() - time(""{0}"");
    span             = TimeInterval_Minute * 60;
    startup          = TimeInterval_Minute * 10;
    ratio            = 50;

    $TargetDedicated = (lifespan > startup ? (max($RunningTasks.GetSample(span, ratio), $ActiveTasks.GetSample(span, ratio)) == 0 ? 0 : $TargetDedicated) : {1});
    ", now, 4);
```

## <a name="next-steps"></a>Επόμενα βήματα

* [Μεγιστοποίηση δέσμη Azure τον υπολογισμό χρήση πόρων με εργασίες ταυτόχρονες κόμβου](batch-parallel-node-tasks.md) περιέχει λεπτομέρειες σχετικά με το πώς μπορείτε να εκτελέσετε πολλών εργασιών ταυτόχρονα σε τους κόμβους υπολογισμού του χώρου συγκέντρωσης. Εκτός από την autoscaling, αυτή η δυνατότητα μπορεί να σας βοηθήσουν να μειώσετε διάρκεια έργου για ορισμένες φόρτους εργασίας, χωρίς να χρήματα.

* Για μια άλλη της αποδοτικότητας προώθησης, βεβαιωθείτε ότι η εφαρμογή σας δέσμη θέτει ερωτήματα στην υπηρεσία δέσμη με τον τρόπο πιο βέλτιστη. Στο [ερώτημα στην υπηρεσία δέσμη Azure αποτελεσματικά](batch-efficient-list-queries.md), θα μάθετε πώς μπορείτε να περιορίσετε την ποσότητα των δεδομένων που τέμνει σύρματος όταν πραγματοποιείτε ερώτημα για την κατάσταση της ενδεχομένως χιλιάδες κόμβους υπολογιστικών ή εργασίες.

[net_api]: https://msdn.microsoft.com/library/azure/mt348682.aspx
[net_batchclient]: http://msdn.microsoft.com/library/azure/microsoft.azure.batch.batchclient.aspx
[net_cloudpool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.aspx
[net_cloudpool_autoscaleformula]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx
[net_cloudpool_autoscaleevalinterval]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval.aspx
[net_enableautoscale]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.enableautoscale.aspx
[net_maxtasks]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.maxtaskspercomputenode.aspx
[net_poolops_resizepool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.resizepool.aspx

[rest_api]: https://msdn.microsoft.com/library/azure/dn820158.aspx
[rest_autoscaleformula]: https://msdn.microsoft.com/library/azure/dn820173.aspx
[rest_autoscaleinterval]: https://msdn.microsoft.com/library/azure/dn820173.aspx
[rest_enableautoscale]: https://msdn.microsoft.com/library/azure/dn820173.aspx
