<properties
    pageTitle="Εργασία με αξιόπιστη συλλογές | Microsoft Azure"
    description="Μάθετε τις βέλτιστες πρακτικές για την εργασία με συλλογές αξιόπιστη."
    services="service-fabric"
    documentationCenter=".net"
    authors="JeffreyRichter"
    manager="timlt"
    editor="" />

<tags
    ms.service="multiple"
    ms.devlang="dotnet"
    ms.topic="article"
    ms.tgt_pltfrm="na"
    ms.workload="multiple"
    ms.date="03/28/2016"
    ms.author="jeffreyr" />

# <a name="working-with-reliable-collections"></a>Εργασία με αξιόπιστη συλλογές

Υπηρεσία ύφασμα προσφέρει ένα κατάστασης μοντέλο προγραμματισμού που είναι διαθέσιμες για τους προγραμματιστές .NET μέσω αξιόπιστη συλλογών. Συγκεκριμένα, ύφασμα υπηρεσία παρέχει αξιόπιστη λεξικό και κλάσεις αξιόπιστη ουρά. Όταν χρησιμοποιείτε αυτά τα μαθήματα, την κατάσταση είναι διαμερίσματα (για κλιμάκωση) αναπαραχθούν (για διαθεσιμότητα) και συναλλαγή μέσα σε ένα διαμερίσματα (για ΟΞΈΟΣ σημασιολογία). Ας δούμε μια τυπική χρήση ενός αντικειμένου αξιόπιστη λεξικό και δείτε τι τα πραγματικά κάνοντας.

~~~
retry:
try {
   // Create a new Transaction object for this partition
   using (ITransaction tx = base.StateManager.CreateTransaction()) {
      // AddAsync takes key's write lock; if >4 secs, TimeoutException
      // Key & value put in temp dictionary (read your own writes),
      // serialized, redo/undo record is logged & sent to  
      // secondary replicas
      await m_dic.AddAsync(tx, key, value, cancellationToken);

      // CommitAsync sends Commit record to log & secondary replicas
      // After quorum responds, all locks released
      await tx.CommitAsync();
   }
   // If CommitAsync not called, Dispose sends Abort
   // record to log & all locks released
}
catch (TimeoutException) { 
   await Task.Delay(100, cancellationToken); goto retry; 
}
~~~

Όλες οι λειτουργίες σε αξιόπιστη λεξικό αντικειμένων (με εξαίρεση ClearAsync που είναι δυνατή η αναίρεσή), απαιτείται ένα αντικείμενο ITransaction. Αυτό το αντικείμενο είναι συσχετισμένη με το οποιαδήποτε και όλες τις αλλαγές που προσπαθείτε να κάνετε οποιαδήποτε αξιόπιστη λεξικό ή/και αξιόπιστη ουρά αντικείμενα μέσα σε ένα μεμονωμένο διαμερίσματα. Αποκτάτε ITransaction ένα αντικείμενο καλώντας τα διαμερίσματα της μεθόδου CreateTransaction του StateManager.
 
Στο παραπάνω κώδικα, το αντικείμενο ITransaction περνούν ένα αξιόπιστο λεξικό AddAsync μέθοδο. Εσωτερικά, μεθόδους λεξικό που αποδέχεται έναν αριθμό-κλειδί λαμβάνουν ένα κλείδωμα ανάγνωσης/εγγραφής που σχετίζεται με τον αριθμό-κλειδί. Εάν η μέθοδος τροποποιεί τιμή του κλειδιού, η μέθοδος τίθεται σε μια κλειδώματος εγγραφής σε τον αριθμό-κλειδί και εάν τη μέθοδο διαβάζει μόνο από την τιμή του κλειδιού, στη συνέχεια, κλείδωμα ανάγνωσης λαμβάνεται το κλειδί. Επειδή το AddAsync τροποποιεί τιμή του κλειδιού στην τιμή νέο, που εισήχθησαν στο, λαμβάνεται τον αριθμό-κλειδί του κλειδώματος εγγραφής. Επομένως, εάν επιχειρείτε νήματα 2 (ή περισσότερα) για να προσθέσετε τιμές με το ίδιο κλειδί την ίδια στιγμή, ένα νήμα θα απόκτηση κλειδώματος εγγραφής και αποκλείει τα άλλα νήματα. Από προεπιλογή, μεθόδους μπλοκ για έως 4 δευτερόλεπτα για να αποκτήσετε το κλείδωμα; μετά από 4 δευτερόλεπτα, τις μεθόδους εμφανίσουν μια TimeoutException. Τύποι μέθοδο υπάρχει επιτρέποντάς σας να περάσει μια τιμή ρητή χρονικού ορίου Εάν προτιμάτε.
 
Συνήθως, μπορείτε να γράψετε τον κωδικό απάντησης σε μια TimeoutException κατά την αλίευση και επανάληψη ολόκληρη η λειτουργία (όπως φαίνεται στο παραπάνω κώδικα). Μου απλό κώδικα, απλώς οποίο καλείτε Task.Delay διέρχεται 100 χιλιοστά του δευτερολέπτου κάθε φορά. Ωστόσο, στην πραγματικότητα, ενδέχεται να είναι καλύτερα να χρησιμοποιείτε κάποιο είδος εκθετική πίσω απενεργοποίηση καθυστέρηση αντί για αυτό.
 
Όταν λαμβάνεται το κλείδωμα, AddAsync προσθέτει το κλειδί και τιμή αναφορών αντικειμένων σε μια εσωτερική προσωρινό λεξικού που σχετίζεται με το αντικείμενο ITransaction. Αυτό γίνεται για την παροχή σημασιολογία ανάγνωση-σας-κάτοχος-εγγραφές. Αυτό σημαίνει ότι, μετά την κλήση AddAsync, μετέπειτα κλήση στη TryGetValueAsync (χρησιμοποιώντας το ίδιο αντικείμενο ITransaction) θα επιστρέψει την τιμή ακόμα και αν δεν έχετε ακόμη ολοκληρώσει τη συναλλαγή. Στη συνέχεια, AddAsync τοποθετεί σειριακά τον αριθμό-κλειδί και τιμή αντικείμενα σε πίνακες byte και τοποθετεί τα παρακάτω πίνακες byte σε ένα αρχείο καταγραφής στον τοπικό κόμβο. Τέλος, AddAsync στέλνει των πινάκων byte σε όλα τα δευτερεύοντα τα αντίγραφα, ώστε να έχουν τις ίδιες πληροφορίες κλειδιού/τιμής. Παρόλο που οι πληροφορίες του αριθμού-κλειδιού/τιμής έχει εγγραφεί σε ένα αρχείο καταγραφής, οι πληροφορίες δεν θεωρείται τμήμα του λεξικού μέχρι να ολοκληρωθεί η συναλλαγή οποία συσχετίζονται με δεσμευμένη. 

Στο παραπάνω κώδικα, την κλήση σε CommitAsync δεσμεύεται όλων των λειτουργιών της συναλλαγής. Συγκεκριμένα, προσαρτά υποβολή πληροφορίες στο αρχείο καταγραφής στον τοπικό κόμβο και στέλνει επίσης η εγγραφή ολοκλήρωσης για όλα τα δευτερεύοντα τα αντίγραφα. Μόλις απάντησε απαρτία (μεγαλύτερο μέρος) τα αντίγραφα, όλες οι αλλαγές δεδομένων θεωρούνται μόνιμο και οποιαδήποτε κλειδωμάτων που σχετίζονται με τα πλήκτρα που ήταν ο χειρισμός μέσω του αντικειμένου ITransaction έχουν κυκλοφορήσει, ώστε να διαχειριστείτε τα άλλα νήματα/συναλλαγές τα ίδια πλήκτρα και τις τιμές τους.

Εάν δεν καλείται CommitAsync (συνήθως λόγω που δημιουργήθηκε μια εξαίρεση), στη συνέχεια, το αντικείμενο ITransaction λαμβάνει διάθεση. Κατά την απόσυρση μη ολοκληρωμένη αντικειμένου ITransaction, υπηρεσία ύφασμα προσαρτά ματαίωση πληροφορίες αρχείου καταγραφής τον τοπικό κόμβο και δεν χρειάζεται να σταλεί σε οποιαδήποτε από τα δευτερεύοντα αντίγραφα. Και, στη συνέχεια, έχουν κυκλοφορήσει οποιαδήποτε κλειδωμάτων που σχετίζονται με τα πλήκτρα που ήταν ο χειρισμός μέσω της συναλλαγής.

## <a name="common-pitfalls-and-how-to-avoid-them"></a>Κοινές παγίδες και πώς να αποφύγετε τους
Τώρα που έχετε κατανοήσει πώς λειτουργούν εσωτερικά των συλλογών αξιόπιστη, ας ρίξουμε μια ματιά σε ορισμένες συνήθεις καταχρήσεις από αυτές. Δείτε τον παρακάτω κώδικα:

~~~
using (ITransaction tx = StateManager.CreateTransaction()) {
   // AddAsync serializes the name/user, logs the bytes, 
   // & sends the bytes to the secondary replicas.
   await m_dic.AddAsync(tx, name, user);

   // The line below updates the property’s value in memory only; the
   // new value is NOT serialized, logged, & sent to secondary replicas.
   user.LastLogin = DateTime.UtcNow;  // Corruption!

   await tx.CommitAsync();
}
~~~

Όταν εργάζεστε με ένα κανονικό λεξικό .NET, μπορείτε να προσθέσετε έναν αριθμό-κλειδί/τιμής στο λεξικό και να, στη συνέχεια, αλλάξτε την τιμή της ιδιότητας (όπως LastLogin). Ωστόσο, αυτός ο κωδικός δεν θα λειτουργεί σωστά με μια αξιόπιστη λεξικό. Να θυμάστε ότι από την προηγούμενη συζήτηση, την κλήση σε AddAsync τοποθετεί σειριακά τα αντικείμενα κλειδιού/τιμής με τους πίνακες, byte και, στη συνέχεια, αποθηκεύει των πινάκων σε ένα τοπικό αρχείο και να τους αποστέλλεται επίσης για το δευτερεύον αντίγραφα. Εάν αλλάξετε αργότερα μια ιδιότητα, αυτό αλλάζει την τιμή της ιδιότητας στη μνήμη μόνο. δεν επηρεάζει το τοπικό αρχείο ή τα δεδομένα αποστέλλονται τα αντίγραφα. Εάν η διαδικασία διακοπεί η λειτουργία, τι υπάρχει στη μνήμη προκαλείται, δεν βρίσκομαι στον υπολογιστή. Όταν ξεκινά μια νέα διαδικασία ή μια άλλη ρεπλίκα γίνεται κύρια, στη συνέχεια, η παλιά τιμή της ιδιότητας είναι τι είναι διαθέσιμη. 

Που δεν είναι δυνατό να τονίσετε αρκετά πόσο εύκολο είναι να κάνετε το είδος του λάθος φαίνεται παραπάνω. Και θα μόνο μάθετε σχετικά με το λάθος αν/όταν η διαδικασία μεταβαίνει προς τα κάτω. Τον σωστό τρόπο για να γράψετε ο κώδικας είναι απλώς να αντιστρέψετε τις δύο γραμμές:

~~~
using (ITransaction tx = StateManager.CreateTransaction()) {
   user.LastLogin = DateTime.UtcNow;  // Do this BEFORE calling AddAsync
   await m_dic.AddAsync(tx, name, user);
   await tx.CommitAsync(); 
}
~~~

Ακολουθεί ένα ακόμη παράδειγμα που εμφανίζει ένα συνηθισμένο λάθος:

~~~
using (ITransaction tx = StateManager.CreateTransaction()) {
   // Use the user’s name to look up their data
   ConditionalValue<User> user = 
      await m_dic.TryGetValueAsync(tx, name);

   // The user exists in the dictionary, update one of their properties.
   if (user.HasValue) {
      // The line below updates the property’s value in memory only; the
      // new value is NOT serialized, logged, & sent to secondary replicas.
      user.Value.LastLogin = DateTime.UtcNow; // Corruption!
      await tx.CommitAsync(); 
   }
}
~~~

Ξανά, με κανονική .NET λεξικά, τον παραπάνω κώδικα λειτουργεί καλά και είναι ένα κοινό μοτίβο: ο προγραμματιστής χρησιμοποιεί έναν αριθμό-κλειδί για να αναζητήσετε μια τιμή. Εάν η τιμή υπάρχει, ο προγραμματιστής αλλάζει την τιμή της ιδιότητας. Ωστόσο, με αξιόπιστη συλλογές, αυτός ο κωδικός παρουσιάζει το ίδιο πρόβλημα που περιγράφεται ως ήδη: __δεν θα πρέπει να τροποποιήσετε ένα αντικείμενο, αφού έχετε δώσει το σε μια αξιόπιστη συλλογή.__
 
Τον σωστό τρόπο για να ενημερώσετε μια τιμή σε μια αξιόπιστη συλλογή, είναι να λάβετε μια αναφορά στην υπάρχουσα τιμή και εξετάστε το ενδεχόμενο να του αντικειμένου στα οποία αναφέρονται αυτή η αναφορά αμετάβλητες. Στη συνέχεια, δημιουργήστε ένα νέο αντικείμενο το οποίο είναι ένα ακριβές αντίγραφο του αρχικού αντικειμένου. Τώρα, μπορείτε να τροποποιήσετε την κατάσταση αυτού του νέου αντικειμένου και να γράψετε το νέο αντικείμενο στη συλλογή, έτσι ώστε το λαμβάνει σειριοποιηθεί σε byte πίνακες, προσαρτημένο στο τοπικό αρχείο και αποστέλλονται τα αντίγραφα. Μετά από την οριστικοποίηση των οι αλλαγές, τα αντικείμενα στη μνήμη, το τοπικό αρχείο και όλα τα αντίγραφα του έχουν το ίδιο ακριβή κατάσταση. Όλα είναι καλή!

Ο παρακάτω κώδικας παρουσιάζει τον σωστό τρόπο για να ενημερώσετε μια τιμή σε μια αξιόπιστη συλλογή:

~~~
using (ITransaction tx = StateManager.CreateTransaction()) {
   // Use the user’s name to look up their data
   ConditionalValue<User> currentUser = 
      await m_dic.TryGetValueAsync(tx, name);

   // The user exists in the dictionary, update one of their properties.
   if (currentUser.HasValue) {
      // Create new user object with the same state as the current user object.
      // NOTE: This must be a deep copy; not a shallow copy. Specifically, only
      // immutable state can be shared by currentUser & updatedUser object graphs.
      User updatedUser = new User(currentUser);

      // In the new object, modify any properties you desire 
      updatedUser.LastLogin = DateTime.UtcNow;

      // Update the key’s value to the updateUser info
      await m_dic.SetValue(tx, name, updatedUser);

      await tx.CommitAsync(); 
   }
}
~~~

## <a name="define-immutable-data-types-to-prevent-programmer-error"></a>Ορισμός τύπων αμετάβλητες δεδομένων για να αποτρέψετε την εμφάνιση σφάλματος προγραμματιστή

Ιδανικά, θα σας θα θέλατε το πρόγραμμα μεταγλώττισης να αναφέρει σφάλματα όταν που παράγει κατά λάθος κωδικό που mutates κατάσταση του αντικειμένου που που πρέπει να λάβετε υπόψη αμετάβλητες. Ωστόσο, το πρόγραμμα μεταγλώττισης C# δεν έχει τη δυνατότητα να το κάνετε αυτό. Επομένως, για να αποφύγετε πιθανά προβλήματα προγραμματιστή, σας συνιστούμε να ορίζετε τους τύπους χρησιμοποιείτε με συλλογές αξιόπιστη για να αμετάβλητες τύποι. Συγκεκριμένα, αυτό σημαίνει ότι τηρείται στους τύπους τιμή πυρήνα (όπως αριθμοί [Int32, UInt64, κ.λπ.], ημερομηνίας/ώρας, Guid, χρονικού εύρους και παρόμοια). Και, φυσικά, μπορείτε επίσης να χρησιμοποιήσετε συμβολοσειρά. Είναι καλύτερα να αποφύγετε Ιδιότητες συλλογής ως σειριοποίησης και αποσειριοποίησης τους να συχνά μπορεί να προκαλέσει προβλήματα επιδόσεων. Ωστόσο, εάν θέλετε να χρησιμοποιήσετε Ιδιότητες συλλογής, σας συνιστούμε τη χρήση του. Βιβλιοθήκη του Καθαρής αμετάβλητες συλλογές (System.Collections.Immutable). Αυτή η βιβλιοθήκη είναι διαθέσιμο για λήψη από το http://nuget.org. Συνιστάται επίσης να σφράγισμα τις σχολικές τάξεις και την πραγματοποίηση πεδία μόνο για ανάγνωση, όποτε είναι δυνατό.

Ο παρακάτω τύπος πληροφοριών χρήστη δείχνει πώς να ορίζετε έναν τύπο αμετάβλητες αξιοποίηση των εν λόγω συστάσεις.

~~~
[DataContract]
// If you don’t seal, you must ensure that any derived classes are also immutable
public sealed class UserInfo {
   private static readonly IEnumerable<ItemId> NoBids = ImmutableList<ItemId>.Empty;
 
   public UserInfo(String email, IEnumerable<ItemId> itemsBidding = null) {
      Email = email;
      ItemsBidding = (itemsBidding == null) ? NoBids : itemsBidding.ToImmutableList();
   }

   [OnDeserialized]
   private void OnDeserialized(StreamingContext context) {
      // Convert the deserialized collection to an immutable collection
      ItemsBidding = ItemsBidding.ToImmutableList();
   }
 
   [DataMember]
   public readonly String Email;
 
   // Ideally, this would be a readonly field but it can't be because OnDeserialized 
   // has to set it. So instead, the getter is public and the setter is private.
   [DataMember]
   public IEnumerable<ItemId> ItemsBidding { get; private set; }

   // Since each UserInfo object is immutable, we add a new ItemId to the ItemsBidding
   // collection by creating a new immutable UserInfo object with the added ItemId.
   public UserInfo AddItemBidding(ItemId itemId) {
      return new UserInfo(Email, ((ImmutableList<ItemId>)ItemsBidding).Add(itemId));
   }
}
~~~

Ο τύπος ItemId είναι επίσης έναν τύπο αμετάβλητες, όπως φαίνεται εδώ:

~~~
[DataContract]
public struct ItemId {

   [DataMember] public readonly String Seller;
   [DataMember] public readonly String ItemName;
   public ItemId(String seller, String itemName) {
      Seller = seller;
      ItemName = itemName;
   }
}
~~~

## <a name="schema-versioning-upgrades"></a>Εκδόσεις του σχήματος (αναβαθμίσεις)

Εσωτερικά, αξιόπιστη συλλογές σειριοποίηση τα αντικείμενα με χρήση. DataContractSerializer του Δικτύου. Τα αντικείμενα σειριακή διατηρούνται την κύρια ρεπλίκα στον τοπικό δίσκο και μεταδίδονται επίσης τα δευτερεύοντα αντίγραφα. Καθώς μεγαλώνει την υπηρεσία, είναι πιθανό που θα θέλετε να αλλάξετε το είδος των δεδομένων (σχήμα) απαιτεί την υπηρεσία. Πρέπει να προσεγγίσετε τήρηση ιστορικού εκδόσεων των δεδομένων σας με εξαιρετική προσοχή. Πρώτα και κύριο λόγο, πρέπει πάντα να μπορούν να αποσειριοποίηση παλιά δεδομένα. Συγκεκριμένα, αυτό σημαίνει ότι το κωδικός αποσειριοποίησης πρέπει να είναι συμβατά με παλαιότερες εκδόσεις πολύ: 333 έκδοση του κώδικα της υπηρεσίας πρέπει να μπορούν να λειτουργούν δεδομένων που τοποθετείται σε μια αξιόπιστη συλλογή από την έκδοση 1 του κώδικα της υπηρεσίας 5 έτη πριν από.

Επιπλέον, η υπηρεσία κώδικα είναι αναβαθμισμένη έναν τομέα αναβάθμισης κάθε φορά. Επομένως, κατά την αναβάθμιση, έχετε δύο διαφορετικές εκδόσεις του κώδικα της υπηρεσίας εκτελείται ταυτόχρονα. Πρέπει να αποφεύγετε τη νέα έκδοση του κώδικα της υπηρεσίας χρησιμοποιήσετε τη νέα διάταξη όπως παλιές εκδόσεις του κώδικα της υπηρεσίας ενδέχεται να μην είναι σε θέση να χειρίζεται το νέο σχήμα. Όταν είναι δυνατό, θα πρέπει να μπορείτε να σχεδιάσετε κάθε έκδοση της υπηρεσίας σας να είναι συμβατό με προς τα εμπρός από την έκδοση 1. Συγκεκριμένα, αυτό σημαίνει ότι V1 του κώδικα της υπηρεσίας πρέπει να μπορείτε να παραβλέψετε απλώς οποιαδήποτε στοιχεία σχήματος δεν χειρίζεται ρητά. Ωστόσο, πρέπει να μπορούν να αποθηκεύσετε οποιαδήποτε δεδομένα αυτό δεν γνωρίζει ρητά και απλώς εγγραφής την ξανά ανάληψη κατά την ενημέρωση λεξικού κλειδιού ή τιμής. 

>[AZURE.WARNING] Ενώ μπορείτε να τροποποιήσετε τη διάταξη ενός κλειδιού, πρέπει να βεβαιωθείτε ότι τον αριθμό-κλειδί του κώδικα κατακερματισμός και αλγορίθμων ισούται με είναι σταθερές. Εάν αλλάξετε πώς λειτουργούν είτε αυτών των αλγορίθμων, δεν θα μπορείτε να αναζητήσετε ποτέ ξανά το πλήκτρο μέσα στο λεξικό αξιόπιστη.
  
Εναλλακτικά, μπορείτε να εκτελέσετε τι συνήθως αναφέρεται ως μια αναβάθμιση φάση 2. Με μια φάση 2 αναβάθμιση, η αναβάθμιση της υπηρεσίας από V1 σε V2: V2 περιέχει τον κωδικό που γνωρίζει πώς να ασχοληθείτε με τη νέα Αλλαγή σχήματος αλλά δεν εκτελεί αυτός ο κωδικός. Όταν ο κώδικας V2 διαβάζει δεδομένα V1, λειτουργεί σε αυτό και συντάσσει V1 δεδομένων. Στη συνέχεια, όταν ολοκληρωθεί η αναβάθμιση σε όλα αναβάθμισης τομείς, μπορείτε να με κάποιον τρόπο σήμα για τις παρουσίες V2 που εκτελούνται ότι η αναβάθμιση ολοκληρώνεται. (Ένας τρόπος να σήματος πρόκειται να αναπτύξετε μια αναβάθμιση ρύθμισης παραμέτρων, αυτό είναι τι κάνει αυτό μια αναβάθμιση φάση 2.) Τώρα, τις παρουσίες V2 μπορεί να διαβάσει V1 δεδομένα, μετατρέψετε σε δεδομένα V2, λειτουργούν σε αυτήν και γράψτε ως δεδομένα V2. Κατά την ανάγνωση δεδομένων V2 άλλες εμφανίσεις, δεν χρειάζεται να τον μετατρέψετε, μπορούν απλώς λειτουργούν σε αυτήν, και γράψτε V2 δεδομένα.

## <a name="next-steps"></a>Επόμενα βήματα
Για να μάθετε σχετικά με τη δημιουργία συμβάσεων προώθηση συμβατά δεδομένων, ανατρέξτε στο θέμα [Συμβάσεων δεδομένων με μελλοντικές εκδόσεις](https://msdn.microsoft.com/library/ms731083.aspx).

Για να μάθετε τις βέλτιστες πρακτικές στη Διαχείριση εκδόσεων συμβάσεων δεδομένων, ανατρέξτε στο θέμα [Διαχείριση εκδόσεων σύμβασης δεδομένων](https://msdn.microsoft.com/library/ms731138.aspx). 

Για να μάθετε πώς μπορείτε να υλοποιήσετε συμβάσεων ανοχή σφαλμάτων δεδομένων έκδοση, ανατρέξτε στο θέμα [Ανοχή σφαλμάτων έκδοση σειριοποίησης επιστροφές κλήσης](https://msdn.microsoft.com/library/ms733734.aspx). 

Για να μάθετε πώς μπορείτε να δώσετε μια δομή δεδομένων που μπορούν να συνεργάζονται σε πολλαπλές εκδόσεις, ανατρέξτε στο θέμα [IExtensibleDataObject](https://msdn.microsoft.com/library/system.runtime.serialization.iextensibledataobject.aspx).
